blueprints (/home/amir/Documents/Info/Duckly/blueprints):


create_db.py (/home/amir/Documents/Info/Duckly/create_db.py):
from site_1 import app, db

with app.app_context():
    db.create_all()
    print("Database tables created successfully.")


Dockerfile (/home/amir/Documents/Info/Duckly/Dockerfile):
FROM python:3.9-slim

WORKDIR /app
COPY . .

# Print confirmation message and show directory structure
RUN echo "Files successfully copied to container!" && \
    find /app -type f -not -path "*/\.*" | sort

# Create instance directory for SQLite database
RUN mkdir -p /app/instance && \
    touch /app/instance/app.db && \
    chmod 777 /app/instance/app.db

# Create directory for Flask sessions
RUN mkdir -p /app/flask_session && \
    chmod 777 /app/flask_session

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
RUN pip install --no-cache-dir -r requirements.txt

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
ENV PYTHONUNBUFFERED=1
ENV FLASK_ENV=production
ENV FLASK_APP=site_1.py

EXPOSE 1800

# –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å —è–≤–Ω—ã–º —É–∫–∞–∑–∞–Ω–∏–µ–º —Ö–æ—Å—Ç–∞ –∏ –ø–æ—Ä—Ç–∞
CMD ["python", "site_1.py"]

fix_static_urls.py (/home/amir/Documents/Info/Duckly/fix_static_urls.py):
#!/usr/bin/env python3
import os
import re

def fix_static_urls(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        content = file.read()
    
    # –ó–∞–º–µ–Ω—è–µ–º {{ /static/... }} –Ω–∞ /static/...
    content = re.sub(r"{{ /static/([^}]+) }}", r"/static/\1", content)
    
    with open(file_path, 'w', encoding='utf-8') as file:
        file.write(content)

def process_templates():
    templates_dir = '/home/amir/Documents/Info/Duckly/templates'
    for root, _, files in os.walk(templates_dir):
        for file in files:
            if file.endswith('.html'):
                file_path = os.path.join(root, file)
                print(f"Processing {file_path}")
                fix_static_urls(file_path)

if __name__ == "__main__":
    process_templates()
    print("Static URL fixes completed!")

fix_urls.py (/home/amir/Documents/Info/Duckly/fix_urls.py):
#!/usr/bin/env python3
import os
import re

def fix_static_urls(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        content = file.read()
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('static', filename='...') –Ω–∞ /static/...
    content = re.sub(r"url_for\('static', filename='([^']+)'\)", r"/static/\1", content)
    content = re.sub(r'url_for\("static", filename="([^"]+)"\)', r'/static/\1', content)
    
    with open(file_path, 'w', encoding='utf-8') as file:
        file.write(content)

def fix_route_urls(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        content = file.read()
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('hello') –Ω–∞ /hello
    content = re.sub(r"url_for\('hello'\)", r'"/hello"', content)
    content = re.sub(r'url_for\("hello"\)', r'"/hello"', content)
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('tests') –Ω–∞ /tests
    content = re.sub(r"url_for\('tests'\)", r'"/tests"', content)
    content = re.sub(r'url_for\("tests"\)', r'"/tests"', content)
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('games') –Ω–∞ /games
    content = re.sub(r"url_for\('games'\)", r'"/games"', content)
    content = re.sub(r'url_for\("games"\)', r'"/games"', content)
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('flashcards_select_module') –Ω–∞ /flashcards_select_module
    content = re.sub(r"url_for\('flashcards_select_module'\)", r'"/flashcards_select_module"', content)
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('word_match_select_module') –Ω–∞ /word_match_select_module
    content = re.sub(r"url_for\('word_match_select_module'\)", r'"/word_match_select_module"', content)
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('sentence_scramble_select_module') –Ω–∞ /sentence_scramble_select_module
    content = re.sub(r"url_for\('sentence_scramble_select_module'\)", r'"/sentence_scramble_select_module"', content)
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('add_tests') –Ω–∞ /add_tests
    content = re.sub(r"url_for\('add_tests'\)", r'"/add_tests"', content)
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('create_test') –Ω–∞ /create_test
    content = re.sub(r"url_for\('create_test'\)", r'"/create_test"', content)
    
    with open(file_path, 'w', encoding='utf-8') as file:
        file.write(content)

def process_templates():
    templates_dir = '/home/amir/Documents/Info/Duckly/templates'
    for root, _, files in os.walk(templates_dir):
        for file in files:
            if file.endswith('.html'):
                file_path = os.path.join(root, file)
                print(f"Processing {file_path}")
                fix_static_urls(file_path)
                fix_route_urls(file_path)

if __name__ == "__main__":
    process_templates()
    print("URL fixes completed!")

flask_session (/home/amir/Documents/Info/Duckly/flask_session):


GAME_IMPROVEMENTS.md (/home/amir/Documents/Info/Duckly/GAME_IMPROVEMENTS.md):
# –£–ª—É—á—à–µ–Ω–∏—è –∏–≥—Ä—ã "–°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –°–ª–æ–≤"

## –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ —Ñ–∞–π–ª–∞ ideas

### 1. –£–ª—É—á—à–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –≤—ã–±–æ—Ä–∞ –º–æ–¥—É–ª—è (game_word_match_select.html)

#### ‚úÖ –†–µ–∂–∏–º—ã –≤—ã–±–æ—Ä–∞:
- **–ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –º–æ–¥—É–ª—å** - –≤—ã–±–æ—Ä –∫–ª–∞—Å—Å–∞ ‚Üí —é–Ω–∏—Ç–∞ ‚Üí –º–æ–¥—É–ª—è
- **–í–µ—Å—å —é–Ω–∏—Ç** - –≤—ã–±–æ—Ä –∫–ª–∞—Å—Å–∞ ‚Üí —é–Ω–∏—Ç–∞ (–≤—Å–µ –º–æ–¥—É–ª–∏ –≤–∫–ª—é—á–µ–Ω—ã)
- **–í–µ—Å—å –∫–ª–∞—Å—Å** - –≤—ã–±–æ—Ä —Ç–æ–ª—å–∫–æ –∫–ª–∞—Å—Å–∞ (–≤—Å–µ —é–Ω–∏—Ç—ã –∏ –º–æ–¥—É–ª–∏)
- **–ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –≤—ã–±–æ—Ä** - –≤—ã–±–æ—Ä –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –º–æ–¥—É–ª–µ–π –∏–∑ —é–Ω–∏—Ç–∞

#### ‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–∞—Ä—Ç–æ—á–µ–∫:
- –°–ª–∞–π–¥–µ—Ä –¥–ª—è –≤—ã–±–æ—Ä–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–∞—Ä—Ç–æ—á–µ–∫ (4-20)
- –ü–æ–ª–µ –≤–≤–æ–¥–∞ –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ —á–∏—Å–ª–∞ –∫–∞—Ä—Ç–æ—á–µ–∫
- –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å–ª–∞–π–¥–µ—Ä–∞ –∏ –ø–æ–ª—è –≤–≤–æ–¥–∞
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–ª–æ–≤
- –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≤—ã–±–æ—Ä–∞ –Ω–µ—á–µ—Ç–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–∞—Ä—Ç–æ—á–µ–∫ (step="1")

#### ‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≤—Ä–µ–º–µ–Ω–∏:
- **–¢–∞–π–º–µ—Ä** —Å –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–º–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ (30 —Å–µ–∫, 1 –º–∏–Ω, 2 –º–∏–Ω, 3 –º–∏–Ω, 5 –º–∏–Ω, 10 –º–∏–Ω)
- **–°–µ–∫—É–Ω–¥–æ–º–µ—Ä** –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã
- –ö–æ–Ω—Ñ–ª–∏–∫—Ç-—Ä–µ–∑–æ–ª—é—Ü–∏—è: –Ω–µ–ª—å–∑—è –≤–∫–ª—é—á–∏—Ç—å —Ç–∞–π–º–µ—Ä –∏ —Å–µ–∫—É–Ω–¥–æ–º–µ—Ä –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ

#### ‚úÖ –£–ª—É—á—à–µ–Ω–Ω—ã–π –¥–∏–∑–∞–π–Ω:
- –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –º–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π –¥–∏–∑–∞–π–Ω
- –ü–ª–∞–≤–Ω—ã–µ –∞–Ω–∏–º–∞—Ü–∏–∏ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫
- –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Å –≤–∏–∑—É–∞–ª—å–Ω–æ–π –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑—å—é
- –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ–¥ –º–æ–±–∏–ª—å–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
- Google Fonts –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è —Ç–∏–ø–æ–≥—Ä–∞—Ñ–∏–∫–∏

### 2. –£–ª—É—á—à–µ–Ω–Ω–∞—è –∏–≥—Ä–∞ —Å –∫—Ä–∞—Å–∏–≤—ã–º–∏ —Å–≤—è–∑—è–º–∏ (game_word_match.html)

#### ‚úÖ –í–∏–∑—É–∞–ª—å–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è:
- **–ö—Ä–∞—Å–∏–≤—ã–µ –∫—Ä–∏–≤—ã–µ —Å–≤—è–∑–∏** –º–µ–∂–¥—É –∫–∞—Ä—Ç–æ—á–∫–∞–º–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º SVG –∏ –∫—Ä–∏–≤—ã—Ö –ë–µ–∑—å–µ
- **–ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–µ —Å–≤—è–∑–∏** - –∑–µ–ª–µ–Ω—ã–µ –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö, –∫—Ä–∞—Å–Ω—ã–µ –¥–ª—è –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö
- **–ê–Ω–∏–º–∞—Ü–∏–∏ –ø–æ—è–≤–ª–µ–Ω–∏—è** —Å–≤—è–∑–µ–π —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è –ª–∏–Ω–∏–∏
- **–ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∫–∞—Ä—Ç–æ—á–µ–∫** —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º –ø—É–ª—å—Å–∞—Ü–∏–∏
- **–≠—Ñ—Ñ–µ–∫—Ç—ã –Ω–∞–≤–µ–¥–µ–Ω–∏—è** –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫–∏

#### ‚úÖ –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:
- **–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏–∑–º–µ–Ω—è—Ç—å –≤—ã–±–æ—Ä** –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –æ–¥–Ω–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞
- **–°–∏—Å—Ç–µ–º–∞ —Ä–∞–∑—Ä—ã–≤–∞ —Å–≤—è–∑–µ–π** - –∫–ª–∏–∫ –Ω–∞ —Å–≤—è–∑–∞–Ω–Ω—É—é –∫–∞—Ä—Ç–æ—á–∫—É —Ä–∞–∑—Ä—ã–≤–∞–µ—Ç —Å–≤—è–∑—å
- **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è —Å—á–µ—Ç–∞** –ø—Ä–∏ —Ä–∞–∑—Ä—ã–≤–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö —Å–≤—è–∑–µ–π
- **–ü–ª–∞–≤–Ω—ã–µ –ø–µ—Ä–µ—Ö–æ–¥—ã** –º–µ–∂–¥—É —Å–æ—Å—Ç–æ—è–Ω–∏—è–º–∏ –∫–∞—Ä—Ç–æ—á–µ–∫

#### ‚úÖ –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å —Ç–∞–π–º–µ—Ä–∞/—Å–µ–∫—É–Ω–¥–æ–º–µ—Ä–∞:
- **–¢–∞–π–º–µ—Ä** —Å –æ–±—Ä–∞—Ç–Ω—ã–º –æ—Ç—Å—á–µ—Ç–æ–º –∏ —Ü–≤–µ—Ç–æ–≤–æ–π –∏–Ω–¥–∏–∫–∞—Ü–∏–µ–π (–∑–µ–ª–µ–Ω—ã–π ‚Üí –∂–µ–ª—Ç—ã–π ‚Üí –∫—Ä–∞—Å–Ω—ã–π)
- **–°–µ–∫—É–Ω–¥–æ–º–µ—Ä** —Å –ø—Ä—è–º—ã–º –æ—Ç—Å—á–µ—Ç–æ–º –≤ —Ñ–æ—Ä–º–∞—Ç–µ MM:SS
- **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ** –∏–≥—Ä—ã –ø—Ä–∏ –∏—Å—Ç–µ—á–µ–Ω–∏–∏ –≤—Ä–µ–º–µ–Ω–∏
- **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤—Ä–µ–º–µ–Ω–∏** –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞—Ö –∏–≥—Ä—ã

#### ‚úÖ –°–∏—Å—Ç–µ–º–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:
- **–î–µ—Ç–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞**: –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø–∞—Ä—ã, —Ç–æ—á–Ω–æ—Å—Ç—å, –≤—Ä–µ–º—è –∏–≥—Ä—ã
- **–ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ** —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
- **–ö–æ–Ω—Ñ–µ—Ç—Ç–∏** –ø—Ä–∏ –∏–¥–µ–∞–ª—å–Ω–æ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ (–≤—Å–µ –ø–∞—Ä—ã –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ)
- **–ö–Ω–æ–ø–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π**: –∏–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞, –∏–∑–º–µ–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏, –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–π –º–æ–¥—É–ª—å

### 3. –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π JavaScript (game_word_match.js)

#### ‚úÖ –£–ª—É—á—à–µ–Ω–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞:
- **–ú–æ–¥—É–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞** —Å —á–µ—Ç–∫–∏–º —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ–º —Ñ—É–Ω–∫—Ü–∏–π
- **–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º** –∏–≥—Ä—ã
- **–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏–π** –¥–ª—è –≤—Å–µ—Ö –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
- **–°–∏—Å—Ç–µ–º–∞ —Å–≤—è–∑–µ–π** —Å —Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –≤ –º–∞—Å—Å–∏–≤–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è

#### ‚úÖ –ê–ª–≥–æ—Ä–∏—Ç–º—ã:
- **Fisher-Yates shuffle** –¥–ª—è –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è –∫–∞—Ä—Ç–æ—á–µ–∫
- **–†–∞—Å—á–µ—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç** –¥–ª—è SVG —Å–≤—è–∑–µ–π
- **–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∫–æ–ª–ª–∏–∑–∏–π** –¥–ª—è —Ä–∞–∑—Ä—ã–≤–∞ —Å–≤—è–∑–µ–π
- **–°—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è** (—Ç–æ—á–Ω–æ—Å—Ç—å, –≤—Ä–µ–º—è –∏–≥—Ä—ã)

#### ‚úÖ –ê–Ω–∏–º–∞—Ü–∏–∏ –∏ —ç—Ñ—Ñ–µ–∫—Ç—ã:
- **–ü–ª–∞–≤–Ω–æ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ** –∫–∞—Ä—Ç–æ—á–µ–∫ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
- **–ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–≤—è–∑–∏** —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è
- **–ü—É–ª—å—Å–∞—Ü–∏—è** –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
- **–ö–æ–Ω—Ñ–µ—Ç—Ç–∏** –¥–ª—è –ø—Ä–∞–∑–¥–Ω–æ–≤–∞–Ω–∏—è –ø–æ–±–µ–¥—ã

### 4. –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ (game_word_match_demo.html)

#### ‚úÖ –ü–æ–ª–Ω–æ—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è:
- **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è** —Å–æ–∑–¥–∞–Ω–∏—è —Å–≤—è–∑–µ–π –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
- **–¢–µ–º–Ω–∞—è —Ç–µ–º–∞** —Å –Ω–µ–æ–Ω–æ–≤—ã–º–∏ –∞–∫—Ü–µ–Ω—Ç–∞–º–∏
- **–°—Ç–µ–∫–ª—è–Ω–Ω—ã–π –º–æ—Ä—Ñ–∏–∑–º** –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
- **–ü–æ–ª–Ω–∞—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å** –≤—Å–µ—Ö —Ñ—É–Ω–∫—Ü–∏–π

## –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¥–µ—Ç–∞–ª–∏

### CSS —É–ª—É—á—à–µ–Ω–∏—è:
- CSS –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ —Ü–≤–µ—Ç–æ–≤
- Flexbox –∏ Grid –¥–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–π –≤–µ—Ä—Å—Ç–∫–∏
- CSS –∞–Ω–∏–º–∞—Ü–∏–∏ –∏ –ø–µ—Ä–µ—Ö–æ–¥—ã
- Backdrop-filter –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ —Ä–∞–∑–º—ã—Ç–∏—è
- –ì—Ä–∞–¥–∏–µ–Ω—Ç—ã –∏ —Ç–µ–Ω–∏ –¥–ª—è –≥–ª—É–±–∏–Ω—ã

### JavaScript —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å:
- ES6+ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å
- –ú–æ–¥—É–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞
- –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç—å—é (–æ—á–∏—Å—Ç–∫–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤, —É–¥–∞–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤)
- –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã

### –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å:
- –ú–æ–±–∏–ª—å–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
- –ì–∏–±–∫–∞—è —Å–µ—Ç–∫–∞
- –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
- Touch-friendly –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å

## –†–µ–∑—É–ª—å—Ç–∞—Ç

–ò–≥—Ä–∞ "–°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –°–ª–æ–≤" —Ç–µ–ø–µ—Ä—å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–µ, –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ –∏ –≤–∏–∑—É–∞–ª—å–Ω–æ –ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å:

1. **–ì–∏–±–∫–∏–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏** –≤—ã–±–æ—Ä–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
2. **–ö—Ä–∞—Å–∏–≤—ã–º–∏ –≤–∏–∑—É–∞–ª—å–Ω—ã–º–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞–º–∏** 
3. **–ò–Ω—Ç—É–∏—Ç–∏–≤–Ω—ã–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º**
4. **–ü–æ–¥—Ä–æ–±–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π**
5. **–ê–¥–∞–ø—Ç–∏–≤–Ω—ã–º –¥–∏–∑–∞–π–Ω–æ–º**
6. **–ü–ª–∞–≤–Ω—ã–º–∏ –∞–Ω–∏–º–∞—Ü–∏—è–º–∏**

–í—Å–µ –∏–¥–µ–∏ –∏–∑ —Ñ–∞–π–ª–∞ `ideas` –±—ã–ª–∏ —É—Å–ø–µ—à–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã –∏ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∫–æ–¥–æ–≤—É—é –±–∞–∑—É.

ideas (/home/amir/Documents/Info/Duckly/ideas):
{% extends "base.html" %}

{% block title %}–ò–≥—Ä–∞ "–í–∏—Å–µ–ª–∏—Ü–∞"{% endblock %}

{% block content %}
<div class="container-fluid hangman-game">
    <div class="game-header">
        <div class="game-info">
            <h1 class="game-title">
                <i class="fas fa-skull-crossbones"></i>
                –í–∏—Å–µ–ª–∏—Ü–∞
            </h1>
            <div class="game-subtitle">
                –£–≥–∞–¥–∞–π—Ç–µ –∞–Ω–≥–ª–∏–π—Å–∫–æ–µ —Å–ª–æ–≤–æ –ø–æ –±—É–∫–≤–∞–º!
            </div>
        </div>
        
        <div class="game-stats">
            <div class="stat-item">
                <div class="stat-label">–°–ª–æ–≤–æ</div>
                <div class="stat-value">
                    <span id="current-word">1</span> / <span id="total-words">{{ num_words }}</span>
                </div>
            </div>
            <div class="stat-item">
                <div class="stat-label">–ü—Ä–∞–≤–∏–ª—å–Ω–æ</div>
                <div class="stat-value" id="correct-words">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">–û—à–∏–±–∫–∏</div>
                <div class="stat-value" id="wrong-guesses">0</div>
            </div>
            {% if timer_duration > 0 or enable_stopwatch %}
            <div class="stat-item">
                <div class="stat-label">
                    {% if timer_duration > 0 %}–í—Ä–µ–º—è{% else %}–°–µ–∫—É–Ω–¥–æ–º–µ—Ä{% endif %}
                </div>
                <div class="stat-value" id="timer-display">
                    {% if timer_duration > 0 %}{{ timer_duration }}—Å{% else %}00:00{% endif %}
                </div>
            </div>
            {% endif %}
        </div>
    </div>

    <div class="game-content">
        <!-- Hangman Drawing -->
        <div class="hangman-container">
            <svg class="hangman-svg" viewBox="0 0 200 250">
                <!-- Gallows with improved design -->
                <!-- Base -->
                <ellipse cx="30" cy="235" rx="25" ry="8" fill="#654321" stroke="#5D4037" stroke-width="2"/>
                <!-- Main post -->
                <rect x="25" y="20" width="10" height="215" fill="#8B4513" stroke="#5D4037" stroke-width="2" rx="2"/>
                <!-- Top beam -->
                <rect x="30" y="15" width="95" height="10" fill="#8B4513" stroke="#5D4037" stroke-width="2" rx="2"/>
                <!-- Noose support -->
                <rect x="115" y="20" width="10" height="35" fill="#8B4513" stroke="#5D4037" stroke-width="2" rx="2"/>
                <!-- Support beam -->
                <line x1="35" y1="40" x2="50" y2="25" stroke="#8B4513" stroke-width="3"/>
                <!-- Rope -->
                <line x1="120" y1="50" x2="120" y2="48" stroke="#D2691E" stroke-width="3"/>
                <!-- Wood grain effect -->
                <line x1="27" y1="30" x2="27" y2="220" stroke="#A0522D" stroke-width="1" opacity="0.5"/>
                <line x1="33" y1="35" x2="33" y2="225" stroke="#A0522D" stroke-width="1" opacity="0.5"/>
                <line x1="32" y1="17" x2="120" y2="17" stroke="#A0522D" stroke-width="1" opacity="0.5"/>
                <line x1="32" y1="23" x2="120" y2="23" stroke="#A0522D" stroke-width="1" opacity="0.5"/>
                
                <!-- Body parts (initially hidden) -->
                <g id="hangman-body" class="hangman-body">
                    <!-- Head with improved face -->
                    <g id="head" class="hangman-part">
                        <circle cx="120" cy="60" r="12" stroke="#2C3E50" stroke-width="3" fill="#F4D1AE"/>
                        <!-- Eyes -->
                        <circle cx="115" cy="57" r="1.5" fill="#2C3E50"/>
                        <circle cx="125" cy="57" r="1.5" fill="#2C3E50"/>
                        <!-- Eyebrows -->
                        <path d="M 112 53 Q 115 50 118 53" stroke="#2C3E50" stroke-width="1" fill="none" id="leftBrow"/>
                        <path d="M 122 53 Q 125 50 128 53" stroke="#2C3E50" stroke-width="1" fill="none" id="rightBrow"/>
                        <!-- Smiling mouth -->
                        <path d="M 115 63 Q 120 66 125 63" stroke="#2C3E50" stroke-width="1" fill="none" id="mouth"/>
                        <!-- Hair -->
                        <path d="M 108 52 Q 120 48 132 52" stroke="#8B4513" stroke-width="2" fill="none"/>
                    </g>
                    
                    <!-- Improved body proportions -->
                    <g id="body" class="hangman-part">
                        <ellipse cx="120" cy="110" rx="15" ry="40" stroke="#2C3E50" stroke-width="3" fill="#3498DB"/>
                        <!-- Shirt details -->
                        <line x1="105" y1="85" x2="135" y2="85" stroke="#2980B9" stroke-width="2"/>
                        <circle cx="115" cy="95" r="2" fill="#2980B9"/>
                        <circle cx="125" cy="95" r="2" fill="#2980B9"/>
                        <circle cx="120" cy="105" r="2" fill="#2980B9"/>
                    </g>
                    
                    <!-- Left Arm with physics -->
                    <g id="leftArm" class="hangman-part">
                        <line x1="105" y1="90" x2="85" y2="115" stroke="#F4D1AE" stroke-width="4" id="leftArmLine"/>
                        <line x1="105" y1="90" x2="90" y2="105" stroke="#3498DB" stroke-width="3"/>
                        <!-- Hand -->
                        <circle cx="85" cy="115" r="4" fill="#F4D1AE" stroke="#2C3E50" stroke-width="1" id="leftHand"/>
                    </g>
                    
                    <!-- Right Arm with physics -->
                    <g id="rightArm" class="hangman-part">
                        <line x1="135" y1="90" x2="155" y2="115" stroke="#F4D1AE" stroke-width="4" id="rightArmLine"/>
                        <line x1="135" y1="90" x2="150" y2="105" stroke="#3498DB" stroke-width="3"/>
                        <!-- Hand -->
                        <circle cx="155" cy="115" r="4" fill="#F4D1AE" stroke="#2C3E50" stroke-width="1" id="rightHand"/>
                    </g>
                    
                    <!-- Left Leg with physics -->
                    <g id="leftLeg" class="hangman-part">
                        <line x1="110" y1="150" x2="95" y2="185" stroke="#2C3E50" stroke-width="4" id="leftLegLine"/>
                        <!-- Shoe -->
                        <ellipse cx="95" cy="185" rx="8" ry="4" fill="#34495E" id="leftShoe"/>
                    </g>
                    
                    <!-- Right Leg with physics -->
                    <g id="rightLeg" class="hangman-part">
                        <line x1="130" y1="150" x2="145" y2="185" stroke="#2C3E50" stroke-width="4" id="rightLegLine"/>
                        <!-- Shoe -->
                        <ellipse cx="145" cy="185" rx="8" ry="4" fill="#34495E" id="rightShoe"/>
                    </g>
                </g>
            </svg>
        </div>

        <!-- Word Display -->
        <div class="word-container">
            <div class="word-display" id="word-display">
                <!-- Letters will be populated by JavaScript -->
            </div>
            <div class="word-hint" id="word-hint">
                <!-- Translation will be shown here -->
            </div>
        </div>

        <!-- Alphabet -->
        <div class="alphabet-container">
            <div class="alphabet-grid" id="alphabet-grid">
                <!-- Letters A-Z will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Game Feedback -->
    <div id="game-feedback" class="game-feedback"></div>
    
    <!-- Game Over Overlay -->
    <div id="game-over-overlay" class="game-over-overlay"></div>

    <!-- Game Controls -->
    <div class="game-controls">
        <button id="hintBtn" class="btn btn-info">
            <i class="fas fa-lightbulb"></i> –ü–æ–¥—Å–∫–∞–∑–∫–∞
        </button>
        <button id="skipWordBtn" class="btn btn-warning">
            <i class="fas fa-forward"></i> –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å —Å–ª–æ–≤–æ
        </button>
        <button id="resetGameBtn" class="btn btn-danger">
            <i class="fas fa-redo"></i> –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ
        </button>
    </div>

    <!-- Game Result Modal -->
    <div class="game-result" id="gameResult">
        <div class="result-content">
            <h2 id="result-title">–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</h2>
            <div class="result-stats">
                <div class="result-stat">
                    <span class="result-value" id="final-correct">0</span>
                    <span class="result-label">–£–≥–∞–¥–∞–Ω–æ —Å–ª–æ–≤</span>
                </div>
                <div class="result-stat">
                    <span class="result-value" id="final-accuracy">0%</span>
                    <span class="result-label">–¢–æ—á–Ω–æ—Å—Ç—å</span>
                </div>
                {% if timer_duration > 0 or enable_stopwatch %}
                <div class="result-stat">
                    <span class="result-value" id="final-time">0</span>
                    <span class="result-label">
                        {% if timer_duration > 0 %}–í—Ä–µ–º—è (—Å–µ–∫){% else %}–í—Ä–µ–º—è –∏–≥—Ä—ã{% endif %}
                    </span>
                </div>
                {% endif %}
            </div>
            <div class="result-actions">
                <button id="playAgainBtn" class="btn btn-success">
                    <i class="fas fa-play"></i> –ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞
                </button>
                <button id="backToSettingsBtn" class="btn btn-primary">
                    <i class="fas fa-cog"></i> –ò–∑–º–µ–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
                </button>
                <a href="{{ url_for('hangman_select_module') }}" class="btn btn-outline-secondary">
                    <i class="fas fa-arrow-left"></i> –í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–π –º–æ–¥—É–ª—å
                </a>
            </div>
        </div>
    </div>

    <div class="mt-4 text-center">
        <a href="{{ url_for('hangman_select_module') }}" class="btn btn-outline-secondary back-button">
            <i class="fas fa-arrow-left"></i> –í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–π –º–æ–¥—É–ª—å
        </a>
    </div>
</div>

<!-- Game Data -->
<script id="hangmanWords" type="application/json">
    {{ words | tojson | safe }}
</script>
<script id="gameSettings" type="application/json">
    {
        "timerDuration": {{ timer_duration }},
        "enableStopwatch": {{ enable_stopwatch|tojson }},
        "difficulty": "{{ difficulty }}",
        "gameMode": "{{ game_mode }}",
        "totalWords": {{ num_words }}
    }
</script>

<style>
/* ... (–ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å—Ç–∏–ª–∏ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ... */

/* –£–ª—É—á—à–µ–Ω–Ω–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å —Å–µ–∫—É–Ω–¥–æ–º–µ—Ä–∞ */
.stat-value {
    color: #fff !important;
    text-shadow: 0 0 5px rgba(0,0,0,0.8), 0 0 10px rgba(0,0,0,0.5) !important;
    font-weight: 800 !important;
    background: rgba(255, 255, 255, 0.15) !important;
    padding: 8px 12px !important;
    border-radius: 8px !important;
    border: 1px solid rgba(255, 255, 255, 0.3) !important;
    min-height: 40px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
}

.stat-value.danger {
    color: #ffdddd !important;
    background: rgba(255, 68, 68, 0.3) !important;
    border-color: rgba(255, 68, 68, 0.5) !important;
    text-shadow: 0 0 5px rgba(255,0,0,0.8), 0 0 10px rgba(255,0,0,0.5) !important;
}

.stat-value.warning {
    color: #ffffaa !important;
    background: rgba(255, 170, 0, 0.3) !important;
    border-color: rgba(255, 170, 0, 0.5) !important;
    text-shadow: 0 0 5px rgba(255,255,0,0.8), 0 0 10px rgba(255,255,0,0.5) !important;
}

/* –£–ª—É—á—à–µ–Ω–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –¥–ª—è –±—É–∫–≤ */
.letter-slot.revealed {
    color: #fff;
    border-color: #4CAF50;
    background: linear-gradient(45deg, #4CAF50, #81C784, #4CAF50, #66BB6A);
    background-size: 300% 300%;
    animation: 
        letterFlip 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55),
        gradientShift 2s ease-in-out infinite,
        colorPulse 3s infinite alternate;
    box-shadow: 0 0 20px rgba(76, 175, 80, 0.6), inset 0 0 20px rgba(255, 255, 255, 0.2);
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
}

@keyframes letterFlip {
    0% { 
        transform: rotateX(90deg) scale(0.3);
        opacity: 0;
        background: linear-gradient(45deg, #4CAF50, #81C784);
    }
    50% { 
        transform: rotateX(0deg) scale(1.1);
        opacity: 1;
        background: linear-gradient(45deg, #4CAF50, #81C784);
    }
    100% { 
        transform: rotateX(0deg) scale(1);
        background: linear-gradient(45deg, #4CAF50, #81C784, #4CAF50, #66BB6A);
    }
}

@keyframes colorPulse {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

/* –£–ª—É—á—à–µ–Ω–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –ø—Ä–∏ –ø—Ä–æ–∏–≥—Ä—ã—à–µ */
@keyframes physicsSwing {
    0% { transform: rotate(0deg); }
    10% { transform: rotate(8deg); }
    20% { transform: rotate(-6deg); }
    30% { transform: rotate(5deg); }
    40% { transform: rotate(-4deg); }
    50% { transform: rotate(3deg); }
    60% { transform: rotate(-2deg); }
    70% { transform: rotate(1deg); }
    80% { transform: rotate(0deg); }
    100% { transform: rotate(0deg); }
}

@keyframes limbTwitch {
    0%, 100% { transform: rotate(0deg); }
    20% { transform: rotate(10deg); }
    40% { transform: rotate(-8deg); }
    60% { transform: rotate(5deg); }
    80% { transform: rotate(-3deg); }
}

.hangman-body.hanging {
    animation: physicsSwing 3s ease-in-out infinite;
}

.hangman-body.hanging #leftArm,
.hangman-body.hanging #rightArm {
    animation: limbTwitch 1.5s ease-in-out infinite;
}

.hangman-body.hanging #leftLeg,
.hangman-body.hanging #rightLeg {
    animation: limbTwitch 1.8s ease-in-out infinite;
}

/* –ì—Ä—É—Å—Ç–Ω–æ–µ –ª–∏—Ü–æ –ø—Ä–∏ –ø—Ä–æ–∏–≥—Ä—ã—à–µ */
.hangman-body.hanging #leftBrow,
.hangman-body.hanging #rightBrow {
    animation: sadBrows 0.8s ease-in-out forwards;
}

.hangman-body.hanging #mouth {
    animation: sadMouth 0.8s ease-in-out forwards;
}

@keyframes sadBrows {
    0% { d: path("M 112 53 Q 115 50 118 53"); }
    100% { d: path("M 112 55 Q 115 52 118 55"); }
}

@keyframes sadMouth {
    0% { d: path("M 115 63 Q 120 66 125 63"); }
    100% { d: path("M 115 65 Q 120 62 125 65"); }
}

/* –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞—Ç—É—Ö–∞–Ω–∏—è –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ */
@keyframes hangmanFadeOut {
    0% { 
        opacity: 1;
        filter: brightness(1);
    }
    70% { 
        opacity: 0.8;
        filter: brightness(0.7);
    }
    100% { 
        opacity: 0.6;
        filter: brightness(0.5) sepia(1) hue-rotate(0deg);
    }
}

.hangman-container.game-over {
    animation: hangmanFadeOut 2s ease-in-out forwards;
}

/* –î—Ä—É–≥–∏–µ —Å—Ç–∏–ª–∏ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π */
</style>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // ... (–ø—Ä–µ–¥—ã–¥—É—â–∏–π JavaScript –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...

    function guessLetter(letter) {
        console.log('guessLetter called:', letter, 'gameActive:', gameActive, 'already guessed:', guessedLetters.includes(letter));
        
        if (!gameActive || guessedLetters.includes(letter)) return;
        
        const btn = document.querySelector(`[data-letter="${letter}"]`);
        if (!btn || btn.disabled) {
            console.log('Button not found or disabled:', letter, btn);
            return;
        }
        
        guessedLetters.push(letter);
        
        if (currentWord.includes(letter)) {
            // Correct guess
            btn.classList.add('correct');
            btn.disabled = true;
            
            // Reveal letters with animation delay
            const slots = document.querySelectorAll(`[data-letter="${letter}"]`);
            slots.forEach((slot, index) => {
                if (slot.classList.contains('letter-slot')) {
                    setTimeout(() => {
                        slot.textContent = letter;
                        slot.classList.add('revealed');
                    }, index * 150); // Delay each letter slightly for better effect
                    correctGuesses++;
                }
            });
            
            // Check if word is complete
            const uniqueLetters = [...new Set(currentWord.replace(/\s/g, ''))];
            const guessedUniqueLetters = uniqueLetters.filter(l => guessedLetters.includes(l));
            
            if (guessedUniqueLetters.length === uniqueLetters.length) {
                wordCompleted(true);
            }
        } else {
            // Wrong guess
            btn.classList.add('incorrect');
            btn.disabled = true;
            wrongGuesses++;
            totalWrongGuesses++; // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –æ–±—â–∏–π —Å—á–µ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫
            
            // Show hangman part with animation
            if (wrongGuesses <= hangmanParts.length && hangmanParts[wrongGuesses - 1]) {
                setTimeout(() => {
                    hangmanParts[wrongGuesses - 1].classList.add('show');
                    
                    // Add shake effect to the whole hangman container
                    const hangmanContainer = document.querySelector('.hangman-container');
                    hangmanContainer.style.animation = 'shake 0.5s ease-in-out';
                    setTimeout(() => {
                        hangmanContainer.style.animation = '';
                    }, 500);
                }, 200);
            }
            
            // Check if game over
            if (wrongGuesses >= hangmanParts.length) {
                wordCompleted(false);
            }
        }
        
        updateStats();
    }
    
    function wordCompleted(success) {
        totalAttempts++;
        gameActive = false; // –î–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –∏–≥—Ä—É –≤–æ –≤—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
        
        if (success) {
            totalCorrectWords++;
            showFeedback('–û—Ç–ª–∏—á–Ω–æ! –°–ª–æ–≤–æ —É–≥–∞–¥–∞–Ω–æ!', 'success');
            
            // Add bonus points for fewer wrong guesses
            if (wrongGuesses === 0) {
                showFeedback('–ò–¥–µ–∞–ª—å–Ω–æ! –ù–∏ –æ–¥–Ω–æ–π –æ—à–∏–±–∫–∏!', 'success');
            }
            
            // Move to next word after delay
            setTimeout(() => {
                currentWordIndex++;
                startNewWord();
            }, 2000);
        } else {
            // Reveal the word
            document.querySelectorAll('.letter-slot').forEach(slot => {
                if (slot.dataset.letter && slot.dataset.letter !== ' ') {
                    slot.textContent = slot.dataset.letter;
                    slot.classList.add('revealed');
                }
            });
            
            // Start hanging animation
            startHangingAnimation();
            
            // Move to next word after hanging animation
            setTimeout(() => {
                currentWordIndex++;
                startNewWord();
            }, 5000); // 5 seconds for hanging animation
        }
    }

    function startHangingAnimation() {
        const hangmanBody = document.getElementById('hangman-body');
        const hangmanContainer = document.querySelector('.hangman-container');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        
        if (hangmanBody && hangmanContainer) {
            // Add hanging animation to the body
            hangmanBody.classList.add('hanging');
            
            // Show overlay after 1 second
            setTimeout(() => {
                if (gameOverOverlay) {
                    gameOverOverlay.classList.add('show');
                }
                hangmanContainer.classList.add('game-over');
            }, 1000);
            
            // Show dramatic text
            setTimeout(() => {
                const dramaticText = document.createElement('div');
                dramaticText.className = 'dramatic-text';
                dramaticText.innerHTML = 'üíÄ –ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê! üíÄ';
                document.body.appendChild(dramaticText);
                
                // Remove dramatic text after 2 seconds
                setTimeout(() => {
                    dramaticText.remove();
                }, 2000);
            }, 2000);
            
            // Show regular feedback
            setTimeout(() => {
                showFeedback(`–°–ª–æ–≤–æ –±—ã–ª–æ: ${currentWord}`, 'error');
            }, 3500);
            
            // Remove animations after 5 seconds
            setTimeout(() => {
                hangmanBody.classList.remove('hanging');
                hangmanContainer.classList.remove('game-over');
                if (gameOverOverlay) {
                    gameOverOverlay.classList.remove('show');
                }
                // gameActive –±—É–¥–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ true –≤ startNewWord()
            }, 5000);
        }
    }

    // ... (–æ—Å—Ç–∞–ª—å–Ω–æ–π JavaScript –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
});
</script>
{% endblock %}

instance (/home/amir/Documents/Info/Duckly/instance):


migrate_add_test_progress.py (/home/amir/Documents/Info/Duckly/migrate_add_test_progress.py):
#!/usr/bin/env python3
"""
–ú–∏–≥—Ä–∞—Ü–∏—è –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã test_progress
"""

import sqlite3
import os

def migrate_database():
    """–î–æ–±–∞–≤–ª—è–µ—Ç —Ç–∞–±–ª–∏—Ü—É test_progress –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"""
    
    # –ü—É—Ç–∏ –∫ –≤–æ–∑–º–æ–∂–Ω—ã–º –±–∞–∑–∞–º –¥–∞–Ω–Ω—ã—Ö
    db_paths = ['instance/app.db', 'app.db']
    db_path = None
    
    for path in db_paths:
        if os.path.exists(path):
            db_path = path
            break
    
    if not db_path:
        print(f"–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –ø–æ –ø—É—Ç—è–º: {db_paths}")
        return False
    
    print(f"–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö: {db_path}")
    
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ —Ç–∞–±–ª–∏—Ü–∞
        cursor.execute("""
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name='test_progress'
        """)
        
        if cursor.fetchone():
            print("–¢–∞–±–ª–∏—Ü–∞ test_progress —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
            conn.close()
            return True
        
        # –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É test_progress
        cursor.execute("""
            CREATE TABLE test_progress (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                test_result_id INTEGER NOT NULL,
                test_word_id INTEGER NOT NULL,
                user_answer TEXT,
                last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (test_result_id) REFERENCES test_results (id),
                FOREIGN KEY (test_word_id) REFERENCES test_words (id),
                UNIQUE(test_result_id, test_word_id)
            )
        """)
        
        # –°–æ–∑–¥–∞–µ–º –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
        cursor.execute("""
            CREATE INDEX idx_test_progress_result_id ON test_progress(test_result_id)
        """)
        
        cursor.execute("""
            CREATE INDEX idx_test_progress_word_id ON test_progress(test_word_id)
        """)
        
        conn.commit()
        print("–¢–∞–±–ª–∏—Ü–∞ test_progress —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞")
        
        conn.close()
        return True
        
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ç–∞–±–ª–∏—Ü—ã: {e}")
        return False

if __name__ == "__main__":
    print("–ó–∞–ø—É—Å–∫ –º–∏–≥—Ä–∞—Ü–∏–∏ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã test_progress...")
    success = migrate_database()
    if success:
        print("–ú–∏–≥—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!")
    else:
        print("–ú–∏–≥—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –æ—à–∏–±–∫–æ–π!")

models.py (/home/amir/Documents/Info/Duckly/models.py):
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

db = SQLAlchemy()

class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    fio = db.Column(db.String, nullable=False)
    nick = db.Column(db.String, unique=True, nullable=False)
    password = db.Column(db.String, nullable=False) # Will store hashed password
    teacher = db.Column(db.String, nullable=True)
    class_number = db.Column(db.String, nullable=True)  # Added for student class

class Word(db.Model):
    __tablename__ = 'words'
    id = db.Column(db.Integer, primary_key=True)
    word = db.Column(db.String, nullable=False)
    perevod = db.Column(db.String, nullable=False)
    classs = db.Column('class', db.String, nullable=False)
    unit = db.Column(db.String, nullable=False)
    module = db.Column(db.String, nullable=False)

class Test(db.Model):
    __tablename__ = 'tests'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String, nullable=False)
    classs = db.Column('class', db.String, nullable=False)
    unit = db.Column(db.String, nullable=True, default="N/A")
    module = db.Column(db.String, nullable=True, default="N/A")
    type = db.Column(db.String, nullable=False)  # dictation, add_letter, true_false, multiple_choice_single, multiple_choice_multiple, fill_word
    link = db.Column(db.String, unique=True, nullable=False)
    created_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    is_active = db.Column(db.Boolean, default=True)
    time_limit = db.Column(db.Integer, nullable=True)  # Time limit in minutes
    word_order = db.Column(db.String, nullable=False)  # 'random' or 'sequential'
    word_count = db.Column(db.Integer, nullable=True)  # For random order
    test_mode = db.Column(db.String, nullable=True)  # 'random_letters' or 'manual_letters' for add_letter type
    
    # New fields for dictation test options
    dictation_word_source = db.Column(db.String, nullable=True) # e.g., "all_module", "selected_specific", "random_from_module"
    dictation_selected_words = db.Column(db.Text, nullable=True) # JSON list of word IDs for "selected_specific"

    created_at = db.Column(db.DateTime, default=db.func.current_timestamp())
    test_words = db.relationship('TestWord', backref='test', lazy=True)

class TestWord(db.Model):
    __tablename__ = 'test_words'
    id = db.Column(db.Integer, primary_key=True)
    test_id = db.Column(db.Integer, db.ForeignKey('tests.id'), nullable=False)
    word = db.Column(db.String, nullable=False)
    perevod = db.Column(db.String, nullable=False)
    missing_letters = db.Column(db.String, nullable=True)  # For add_letter type tests
    options = db.Column(db.String, nullable=True)  # For multiple choice tests (JSON string)
    correct_answer = db.Column(db.String, nullable=False)
    word_order = db.Column(db.Integer, nullable=False)  # To maintain word order in sequential tests

class TestResult(db.Model):
    __tablename__ = 'test_results'
    id = db.Column(db.Integer, primary_key=True)
    test_id = db.Column(db.Integer, db.ForeignKey('tests.id'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    score = db.Column(db.Integer, nullable=False, default=0)
    correct_answers = db.Column(db.Integer, nullable=False, default=0)
    total_questions = db.Column(db.Integer, nullable=False, default=0)
    time_taken = db.Column(db.Integer, nullable=False, default=0)  # in minutes
    started_at = db.Column(db.DateTime, nullable=False, default=db.func.current_timestamp())
    completed_at = db.Column(db.DateTime, nullable=True)
    current_word_index = db.Column(db.Integer, default=0)  # Track progress
    answers = db.Column(db.String, nullable=True)  # JSON string of answers

    test = db.relationship('Test', backref=db.backref('results', lazy=True))
    user = db.relationship('User', backref=db.backref('test_results', lazy=True))
    test_answers = db.relationship('TestAnswer', backref='test_result', lazy=True, cascade='all, delete-orphan')

class TestAnswer(db.Model):
    __tablename__ = 'test_answers'
    id = db.Column(db.Integer, primary_key=True)
    test_result_id = db.Column(db.Integer, db.ForeignKey('test_results.id'), nullable=False)
    test_word_id = db.Column(db.Integer, db.ForeignKey('test_words.id'), nullable=False)
    user_answer = db.Column(db.String(255), nullable=True)
    is_correct = db.Column(db.Boolean, nullable=False, default=False)
    answered_at = db.Column(db.DateTime, default=db.func.current_timestamp())

    test_word = db.relationship('TestWord', backref=db.backref('answers', lazy=True))

class TestProgress(db.Model):
    __tablename__ = 'test_progress'
    id = db.Column(db.Integer, primary_key=True)
    test_result_id = db.Column(db.Integer, db.ForeignKey('test_results.id'), nullable=False)
    test_word_id = db.Column(db.Integer, db.ForeignKey('test_words.id'), nullable=False)
    user_answer = db.Column(db.Text, nullable=True)  # JSON string for complex answers like dictation
    last_updated = db.Column(db.DateTime, default=db.func.current_timestamp(), onupdate=db.func.current_timestamp())
    
    # Unique constraint to ensure one progress record per test_result and test_word
    __table_args__ = (db.UniqueConstraint('test_result_id', 'test_word_id', name='_test_progress_uc'),)
    
    test_result = db.relationship('TestResult', backref=db.backref('progress_entries', lazy=True, cascade='all, delete-orphan'))
    test_word = db.relationship('TestWord', backref=db.backref('progress_entries', lazy=True))

class UserWordReview(db.Model):
    __tablename__ = 'user_word_reviews'
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    word_id = db.Column(db.Integer, db.ForeignKey('words.id'), nullable=False)
    next_review_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    interval_days = db.Column(db.Integer, default=0) # Current interval in days
    ease_factor = db.Column(db.Float, default=2.5) # Standard SM-2 starting ease
    last_reviewed_at = db.Column(db.DateTime, nullable=True)
    # Add unique constraint for user_id and word_id
    __table_args__ = (db.UniqueConstraint('user_id', 'word_id', name='_user_word_uc'),)

    user = db.relationship('User', backref=db.backref('reviews', lazy='dynamic'))
    word = db.relationship('Word', backref=db.backref('reviews', lazy='dynamic'))

class Sentence(db.Model):
    __tablename__ = 'sentences'
    id = db.Column(db.Integer, primary_key=True)
    text = db.Column(db.String, nullable=False) # The English sentence
    translation = db.Column(db.String, nullable=True) # Russian translation
    classs = db.Column(db.String, nullable=False)
    unit = db.Column(db.String, nullable=False)
    module = db.Column(db.String, nullable=False)
    # Potentially add difficulty level later

output.txt (/home/amir/Documents/Info/Duckly/output.txt):


__pycache__ (/home/amir/Documents/Info/Duckly/__pycache__):


README.md (/home/amir/Documents/Info/Duckly/README.md):
# Duckly Educational Platform

This project is a web-based educational platform, likely designed for language learning, built with Python and Flask. It allows users to register, manage vocabulary (words), create various types of tests, take tests, and view results. The application is designed to be run in a Docker container.

## Features

*   **User Management:**
    *   User registration (students and teachers).
    *   User login and logout.
    *   User profiles.
*   **Vocabulary Management:**
    *   Adding, editing, and deleting words.
    *   Organizing words by class, unit, and module.
*   **Test Management (for Teachers):**
    *   Creating various types of tests:
        *   Dictation
        *   Add Letter (fill in missing letters)
        *   True/False
        *   Multiple Choice (single and multiple correct answers)
        *   Fill Word (fill in the blank)
    *   Setting test parameters like time limits, word order (random/sequential), and word count.
    *   Linking tests to specific classes, units, or modules.
    *   Archiving tests.
*   **Test Taking (for Students):**
    *   Taking available tests via a unique link.
    *   Submitting answers.
*   **Results Tracking:**
    *   Viewing test scores, correct/incorrect answers, and time taken.
*   **Quizlet-like Functionality:**
    *   Viewing words as flashcards for a given module.
*   **API Endpoints:**
    *   JSON endpoints for retrieving words, units, and modules, likely for dynamic frontend updates.

## Project Structure

```
.
‚îú‚îÄ‚îÄ .git/               # Git repository files
‚îú‚îÄ‚îÄ instance/           # Potentially for instance-specific configurations or data (e.g., persistent DB)
‚îú‚îÄ‚îÄ static/             # Static assets (CSS, JavaScript, images)
‚îú‚îÄ‚îÄ templates/          # HTML templates for the web interface
‚îú‚îÄ‚îÄ __pycache__/        # Python bytecode cache
‚îú‚îÄ‚îÄ app.db              # SQLite database file (Note: May be recreated on container start)
‚îú‚îÄ‚îÄ create_db.py        # Script to initialize the database schema
‚îú‚îÄ‚îÄ Dockerfile          # Defines the Docker image for the application
‚îú‚îÄ‚îÄ requirements.txt    # Python package dependencies
‚îú‚îÄ‚îÄ site_1.py           # Main Flask application file containing routes and logic
‚îú‚îÄ‚îÄ start.sh            # Script to build and run the Docker container
‚îî‚îÄ‚îÄ test.py             # Contains application tests
```

## Technical Stack

*   **Backend:** Python, Flask
*   **Database:** SQLite (via Flask-SQLAlchemy)
*   **Templating:** Jinja2
*   **Containerization:** Docker

## Configuration

Before running the application, especially in a production-like environment, you should configure a `SECRET_KEY`. This key is used by Flask for session management and other security-related purposes.

*   **Environment Variable:** `SECRET_KEY`
*   **How to set:**
    *   When running with Docker (recommended), you can set this environment variable using the `-e` flag:
        ```bash
        docker run -e SECRET_KEY='your_very_strong_and_unique_secret_key' ... other_docker_options ... duckly-app
        ```
    *   If running locally without Docker (for development), you can set it in your shell:
        ```bash
        export SECRET_KEY='your_development_secret_key'
        python site_1.py
        ```
*   **Default:** If `SECRET_KEY` is not set, the application will use a default, insecure key suitable only for development. **It is crucial to set a strong, unique secret key for any production deployment.**

## Setup and Installation

The application is designed to be run using Docker.

### Prerequisites

*   Docker installed and running.

### Running the Application

1.  **Clone the repository (if applicable):**
    ```bash
    git clone <repository_url>
    cd <repository_directory>
    ```

2.  **Build and Run with `start.sh`:**
    The provided `start.sh` script automates the build and run process:
    ```bash
    sh start.sh
    ```
    This script will:
    *   Build a Docker image named `duckly-app`.
    *   Remove any existing container named `duckly-container`.
    *   Run a new container named `duckly-container` in detached mode.
    *   Map port 1800 of the host to port 1800 of the container.
    *   Mount the local `./instance` directory to `/app/instance` in the container. (Note: the script currently uses an absolute path `/home/amir/Duckly/instance` for the volume, you might need to adjust this to your local path or `./instance`).

3.  **Access the application:**
    Once the container is running, the application should be accessible at `http://localhost:1800`.

### Database Initialization

The `Dockerfile` is currently configured to remove `app.db` every time the container starts (`CMD ["sh", "-c", "rm -f app.db && python site_1.py"]`). This means data will not persist across container restarts with the default configuration.

To create the database schema, you can use the `create_db.py` script. You might need to run this script *inside* the running container or modify the application/startup process to handle database creation and persistence.

**Option 1: Run `create_db.py` in a running container (after starting with `start.sh`):**
```bash
docker exec -it duckly-container python create_db.py
```

**Option 2: For a persistent database:**
*   Modify `site_1.py` to store `app.db` inside the `/app/instance` directory (e.g., `app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///instance/app.db'`).
*   Ensure the `instance` directory exists locally before running `start.sh`.
*   Remove `rm -f app.db` from the `CMD` in the `Dockerfile` if the database is moved to the `instance` folder.

## Key Files

*   `site_1.py`: The core Flask application logic, including all routes, database models, and view functions.
*   `Dockerfile`: Instructions for building the Docker image.
*   `requirements.txt`: Lists all Python dependencies.
*   `start.sh`: Utility script to simplify building and running the Docker container.
*   `create_db.py`: Script to create the database tables based on the models defined in `site_1.py`.
*   `templates/`: Contains the HTML templates rendered by Flask.
*   `static/`: Contains static files like CSS and JavaScript.

## Potential Improvements / Areas to Note

*   **Database Persistence:** As mentioned, the current `Dockerfile` setup leads to an ephemeral database. This should be addressed for any practical use by ensuring the database file is stored in the mounted `instance` volume and not deleted on container start.
*   **Secret Key:** The `app.secret_key` in `site_1.py` is hardcoded. For production, this should be set via an environment variable or a configuration file.
*   **Volume Path in `start.sh`:** The `start.sh` script uses an absolute path (`/home/amir/Duckly/instance`) for the volume mount. This should be changed to a relative path (e.g., `-v $(pwd)/instance:/app/instance` for Linux/macOS or an equivalent for Windows) or parameterized to make the script more portable.
*   **Error Handling and Input Validation:** While some basic checks are present, robust error handling and comprehensive input validation would enhance the application's stability.
*   **Testing:** The presence of `test.py` suggests tests exist or are planned. Comprehensive test coverage is important.
*   **Security:** Review security aspects, especially around user authentication, authorization (teacher vs. student access), and protection against common web vulnerabilities (XSS, CSRF, SQL Injection - though SQLAlchemy helps mitigate the latter).

## Contributing

(Provide guidelines here if this is an open project, e.g., how to submit issues, feature requests, or pull requests.)

## License

(Specify the license for the project, e.g., MIT, GPL, etc.) 

rebuild_and_run.sh (/home/amir/Documents/Info/Duckly/rebuild_and_run.sh):
#!/bin/bash

echo "–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–ø—É—â–µ–Ω–Ω—ã—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤..."

# –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–ø—É—â–µ–Ω –ª–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
if docker ps | grep -q duckly-container; then
    echo "–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–ø—É—â–µ–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä duckly-container..."
    docker stop duckly-container
    echo "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω."
fi

# –£–¥–∞–ª—è–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä, –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
if docker ps -a | grep -q duckly-container; then
    echo "–£–¥–∞–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä duckly-container..."
    docker rm duckly-container
    echo "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —É–¥–∞–ª–µ–Ω."
fi

# –°–æ–∑–¥–∞—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è —Å–µ—Å—Å–∏–π, –µ—Å–ª–∏ –æ–Ω–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
echo "–°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –¥–ª—è —Å–µ—Å—Å–∏–π..."
mkdir -p flask_session
chmod 777 flask_session
echo "–î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è —Å–µ—Å—Å–∏–π –≥–æ—Ç–æ–≤–∞."

# –ü–µ—Ä–µ—Å–æ–±—Ä–∞—Ç—å –æ–±—Ä–∞–∑
echo "–°–±–æ—Ä–∫–∞ Docker-–æ–±—Ä–∞–∑–∞..."
docker build -t duckly-app .
echo "–û–±—Ä–∞–∑ —Å–æ–±—Ä–∞–Ω —É—Å–ø–µ—à–Ω–æ."

# –ó–∞–ø—É—Å—Ç–∏—Ç—å –Ω–æ–≤—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
echo "–ó–∞–ø—É—Å–∫ –Ω–æ–≤–æ–≥–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞..."
docker run -d \
  --name duckly-container \
  -p 1800:1800 \
  -v $(pwd)/instance:/app/instance \
  -v $(pwd)/flask_session:/app/flask_session \
  -e SECRET_KEY='your-development-secret-key-here' \
  duckly-app

echo "==============================================="
echo "–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–ø—É—â–µ–Ω–æ –Ω–∞ http://localhost:1800"
echo "==============================================="
echo "–õ–æ–≥–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ (Ctrl+C –¥–ª—è –≤—ã—Ö–æ–¥–∞):"
docker logs -f duckly-container

requirements.txt (/home/amir/Documents/Info/Duckly/requirements.txt):
Flask==2.2.5
Flask-SQLAlchemy==3.1.1
Flask-Session==0.5.0
SQLAlchemy==2.0.23
MarkupSafe==2.1.3
Werkzeug==2.2.3
itsdangerous==2.1.2
Jinja2==3.1.3
click==8.1.3

run_docker.sh (/home/amir/Documents/Info/Duckly/run_docker.sh):
#!/bin/bash

echo "–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏ —É–¥–∞–ª–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞..."
docker stop duckly-container 2>/dev/null || true
docker rm duckly-container 2>/dev/null || true

echo "–°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π –¥–ª—è –¥–∞–Ω–Ω—ã—Ö..."
mkdir -p instance
mkdir -p flask_session
chmod 777 instance
chmod 777 flask_session

echo "–°–±–æ—Ä–∫–∞ Docker-–æ–±—Ä–∞–∑–∞..."
docker build -t duckly-app .

echo "–ó–∞–ø—É—Å–∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞..."
docker run -d \
  --name duckly-container \
  -p 1800:1800 \
  -v $(pwd)/instance:/app/instance \
  -v $(pwd)/flask_session:/app/flask_session \
  -e SECRET_KEY='super-secret-key-for-duckly-app' \
  duckly-app

echo "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–ø—É—â–µ–Ω. –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–Ω–æ –ø–æ –∞–¥—Ä–µ—Å—É: http://localhost:1800"
echo "–õ–æ–≥–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞:"
docker logs -f duckly-container

site_1.py (/home/amir/Documents/Info/Duckly/site_1.py):
from markupsafe import escape
from flask import Flask, jsonify, request, render_template, redirect, url_for, flash, make_response, session, abort
from werkzeug.security import generate_password_hash, check_password_hash # Added for password hashing
from flask_session import Session  # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥–¥–µ—Ä–∂–∫—É —Å–µ—Å—Å–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã
import time
import sqlite3
import random
import string
from datetime import datetime, timedelta
import json
import subprocess # Added to run external scripts
import re # Add this at the top with other imports
import os # Added for os.makedirs
import tempfile # –î–ª—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ —Å–µ—Å—Å–∏–∏

# Import models and db
from models import db, User, Word, Test, TestWord, TestResult, TestAnswer, TestProgress, UserWordReview, Sentence

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—á–∏—Å—Ç–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
AUTO_CLEAR_RESULTS_ON_NEW_TEST = True  # –í–∫–ª—é—á–∏—Ç—å/–≤—ã–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –æ—á–∏—Å—Ç–∫—É
CLEAR_ONLY_ACTIVE_TESTS = True  # –û—á–∏—â–∞—Ç—å —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ —Ç–µ—Å—Ç—ã (—Å–æ—Ö—Ä–∞–Ω—è—Ç—å –∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ)

def format_time_taken(minutes):
    """
    –ë–µ–∑–æ–ø–∞—Å–Ω–æ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–µ—Å—Ç–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.
    
    Args:
        minutes: –í—Ä–µ–º—è –≤ –º–∏–Ω—É—Ç–∞—Ö (–º–æ–∂–µ—Ç –±—ã—Ç—å None, 0 –∏–ª–∏ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º)
    
    Returns:
        str: –û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –≤—Ä–µ–º–µ–Ω–∏
    """
    if minutes is None or minutes < 0:
        return "0 –º–∏–Ω"
    
    if minutes == 0:
        return "<1 –º–∏–Ω"
    
    hours = minutes // 60
    remaining_minutes = minutes % 60
    
    if hours == 0:
        return f"{remaining_minutes} –º–∏–Ω"
    elif remaining_minutes == 0:
        return f"{hours} —á"
    else:
        return f"{hours} —á {remaining_minutes} –º–∏–Ω"

def auto_clear_previous_test_results(teacher_user, class_number, new_test_id):
    """
    –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—á–∏—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Ç–µ—Å—Ç–æ–≤ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ —Ç–µ—Å—Ç–∞.
    
    Args:
        teacher_user: –û–±—ä–µ–∫—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è-—É—á–∏—Ç–µ–ª—è
        class_number: –ù–æ–º–µ—Ä –∫–ª–∞—Å—Å–∞
        new_test_id: ID –Ω–æ–≤–æ–≥–æ —Ç–µ—Å—Ç–∞ (–∏—Å–∫–ª—é—á–∞–µ—Ç—Å—è –∏–∑ –æ—á–∏—Å—Ç–∫–∏)
    
    Returns:
        tuple: (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ_–æ—á–∏—â–µ–Ω–Ω—ã—Ö_—Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤, —Å–ø–∏—Å–æ–∫_–∑–∞—Ç—Ä–æ–Ω—É—Ç—ã—Ö_—Ç–µ—Å—Ç–æ–≤)
    """
    if not AUTO_CLEAR_RESULTS_ON_NEW_TEST:
        return 0, []
    
    try:
        # –°—Ç—Ä–æ–∏–º –∑–∞–ø—Ä–æ—Å –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Ç–µ—Å—Ç–æ–≤
        query = Test.query.filter(
            Test.created_by == teacher_user.id,
            Test.classs == class_number,
            Test.id != new_test_id
        )
        
        # –ï—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ –æ—á–∏—â–∞—Ç—å —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ —Ç–µ—Å—Ç—ã
        if CLEAR_ONLY_ACTIVE_TESTS:
            query = query.filter(Test.is_active == True)
        
        previous_tests = query.all()
        
        results_cleared_count = 0
        tests_affected = []
        
        for prev_test in previous_tests:
            # –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è —ç—Ç–æ–≥–æ —Ç–µ—Å—Ç–∞
            results_to_delete = TestResult.query.filter_by(test_id=prev_test.id).all()
            
            if results_to_delete:  # –ï—Å–ª–∏ –µ—Å—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
                tests_affected.append(prev_test.title)
                
                for result in results_to_delete:
                    # –£–¥–∞–ª—è–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã
                    TestAnswer.query.filter_by(test_result_id=result.id).delete(synchronize_session=False)
                    # –£–¥–∞–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                    db.session.delete(result)
                    results_cleared_count += 1
        
        if results_cleared_count > 0:
            db.session.commit()
        
        return results_cleared_count, tests_affected
        
    except Exception as e:
        db.session.rollback()
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—á–∏—Å—Ç–∫–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤: {e}")
        raise e

app = Flask(__name__)
# Create instance folder if it doesn't exist
try:
    os.makedirs(app.instance_path, exist_ok=True)
except OSError as e:
    print(f"Error creating instance directory {app.instance_path}: {e}")

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—É—Ç—å –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–∫—Ä—É–∂–µ–Ω–∏—è
if os.path.exists('/app'):
    # –ó–∞–ø—É—Å–∫ –≤ Docker
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////app/instance/app.db'
else:
    # –õ–æ–∫–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫
    app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{os.path.join(app.instance_path, "app.db")}'

app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.secret_key = os.environ.get('SECRET_KEY', 'a-default-development-secret-key')  # Load secret key from env var

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–µ—Å—Å–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã –≤ Docker
app.config['SESSION_TYPE'] = 'filesystem'
app.config['SESSION_PERMANENT'] = True
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(days=15)
app.config['SESSION_USE_SIGNER'] = True  # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º cookie –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
app.config['SESSION_KEY_PREFIX'] = 'duckly_'  # –ü—Ä–µ—Ñ–∏–∫—Å –¥–ª—è —Ñ–∞–π–ª–æ–≤ —Å–µ—Å—Å–∏–π

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–µ—Å—Å–∏–π
if os.path.exists('/app'):
    # –í Docker –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ—Å—Ç–æ—è–Ω–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
    session_dir = '/app/flask_session'
    if not os.path.exists(session_dir):
        os.makedirs(session_dir, exist_ok=True)
    app.config['SESSION_FILE_DIR'] = session_dir
else:
    # –õ–æ–∫–∞–ª—å–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
    app.config['SESSION_FILE_DIR'] = tempfile.gettempdir()

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ cookie –¥–ª—è —Å–µ—Å—Å–∏–∏
app.config['SESSION_COOKIE_NAME'] = 'duckly_session'
app.config['SESSION_COOKIE_SECURE'] = False  # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ True –≤ production —Å HTTPS
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
app.config['SESSION_COOKIE_PATH'] = '/'

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Å—Å–∏–∏
Session(app)

# Initialize the db with the app
db.init_app(app)

# Import blueprints after app and db initialization to avoid circular imports
from blueprints.auth import auth_bp
from blueprints.words import words_bp

# Register blueprints
app.register_blueprint(auth_bp)
app.register_blueprint(words_bp)

# Models are now imported from models.py


@app.route("/")
def index():
    return redirect('/hello', 302)

@app.route("/user/<name>")
def greet(name):
    return f"Hello, {name}!"

# Auth routes are now in blueprints.auth
# @app.route("/profile") ... (moved)
# @app.route("/edit_profile") ... (moved)
# @app.route("/save_profile", methods=["POST"]) ... (moved)
# @app.route('/login', methods=['POST', 'GET']) ... (moved)
# @app.route("/logout") ... (moved)
# @app.route('/registration', methods=['POST', 'GET']) ... (moved)


@app.route("/add_tests", methods=['POST', 'GET'])
def add_tests():
    if 'user_id' not in session:
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –∫–∞–∫ —É—á–∏—Ç–µ–ª—å.", "warning")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –¢–æ–ª—å–∫–æ —É—á–∏—Ç–µ–ª—è –º–æ–≥—É—Ç –¥–æ–±–∞–≤–ª—è—Ç—å —Ç–µ—Å—Ç—ã.", "warning")
        if not user:
            session.pop('user_id', None)
        return redirect(url_for('auth.login'))
    
    if request.method == "POST":
        test_type = request.form.get('test_type')
        class_number = request.form.get('class_number')
        title = request.form.get('title')
        
        time_limit_str = request.form.get('time_limit')
        time_limit = int(time_limit_str) if time_limit_str and time_limit_str.isdigit() and int(time_limit_str) > 0 else None
        
        word_order_form = request.form.get('word_order', 'sequential') 
        word_count_form_str = request.form.get('word_count')
        word_count_form = int(word_count_form_str) if word_count_form_str and word_count_form_str.isdigit() and int(word_count_form_str) > 0 else None
        test_mode = request.form.get('test_mode', 'random_letters') if test_type == 'add_letter' else None
        
        new_test_params = {
            'title': title,
            'classs': class_number,
            'type': test_type,
            'link': generate_test_link(),
            'created_by': user.id,
            'time_limit': time_limit,
            'word_order': word_order_form,
            'test_mode': test_mode,
            'is_active': True
        }

        words_data_source = []
        word_source_type = request.form.get('word_source_type', 'modules_only')
        selected_module_identifiers = []
        if word_source_type in ['modules_only', 'modules_and_custom']:
            selected_module_identifiers = request.form.getlist('modules[]')

        custom_words_text = []
        custom_translations_text = []
        if word_source_type in ['custom_only', 'modules_and_custom']:
            custom_words_text = request.form.getlist('custom_words[]')
            custom_translations_text = request.form.getlist('custom_translations[]')

        module_words_list = []
        if selected_module_identifiers:
            for module_identifier in selected_module_identifiers:
                try:
                    class_num, unit, module_name = module_identifier.split('|')
                    module_words_db = Word.query.filter_by(classs=class_num, unit=unit, module=module_name).all()
                    for mw in module_words_db:
                        module_words_list.append({'id': mw.id, 'word': mw.word, 'perevod': mw.perevod, 'source': 'module'})
                except ValueError:
                    flash(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –º–æ–¥—É–ª—è: {module_identifier}", "warning")

        if test_type == 'dictation':
            dictation_word_source = request.form.get('dictation_word_source')
            new_test_params['dictation_word_source'] = dictation_word_source
            if dictation_word_source == 'all_module':
                words_data_source.extend(module_words_list)
                new_test_params['word_count'] = word_count_form
            elif dictation_word_source == 'random_from_module':
                dictation_num_random_words_str = request.form.get('dictation_random_word_count')
                dictation_num_random_words = int(dictation_num_random_words_str) if dictation_num_random_words_str and dictation_num_random_words_str.isdigit() and int(dictation_num_random_words_str) > 0 else 0
                new_test_params['word_count'] = dictation_num_random_words if dictation_num_random_words > 0 else None
                if module_words_list and dictation_num_random_words > 0:
                    random.shuffle(module_words_list)
                    words_data_source.extend(module_words_list[:dictation_num_random_words])
            elif dictation_word_source == 'selected_specific':
                specific_word_ids_str = request.form.getlist('dictation_specific_word_ids[]')
                specific_word_ids = [int(id_str) for id_str in specific_word_ids_str if id_str.isdigit()]
                new_test_params['dictation_selected_words'] = json.dumps(specific_word_ids)
                if specific_word_ids:
                    selected_db_words = Word.query.filter(Word.id.in_(specific_word_ids)).all()
                    for sw in selected_db_words:
                        words_data_source.append({'id': sw.id, 'word': sw.word, 'perevod': sw.perevod, 'source': 'module_specific'})
                new_test_params['word_count'] = word_count_form
            for cw_text, ct_text in zip(custom_words_text, custom_translations_text):
                if cw_text and ct_text:
                    words_data_source.append({'word': cw_text, 'perevod': ct_text, 'source': 'custom'})
        else: 
            new_test_params['word_count'] = word_count_form
            words_data_source.extend(module_words_list)
            for cw_text, ct_text in zip(custom_words_text, custom_translations_text):
                if cw_text and ct_text:
                    words_data_source.append({'word': cw_text, 'perevod': ct_text, 'source': 'custom'})
        
        if len(selected_module_identifiers) == 1:
            try:
                _, unit_single, module_single = selected_module_identifiers[0].split('|')
                new_test_params['unit'] = unit_single
                new_test_params['module'] = module_single
            except ValueError:
                new_test_params['unit'] = "N/A"
                new_test_params['module'] = "N/A"
        elif len(selected_module_identifiers) > 1:
            new_test_params['unit'] = "Multiple"
            new_test_params['module'] = "Multiple"
        else: # No modules selected or error
            new_test_params['unit'] = "N/A" # Default if no specific module context
            new_test_params['module'] = "N/A"

        new_test = Test(**new_test_params)
        db.session.add(new_test)
        
        try:
            db.session.commit() # Commit Test object to get its ID

            if new_test.word_order == 'random':
                random.shuffle(words_data_source)
            
            final_word_count_to_use = new_test.word_count
            if final_word_count_to_use is not None and final_word_count_to_use > 0:
                words_data_source = words_data_source[:final_word_count_to_use]
            elif final_word_count_to_use == 0: # Explicitly 0 means no words
                words_data_source = []

            # If no words are sourced, and it's manual_letters, it will show "no words to configure" on the next page.
            # This might be okay, or you could flash a specific warning here and redirect differently.
            # For now, allowing it to proceed.

            for idx, word_entry in enumerate(words_data_source):
                original_word_text = word_entry['word']
                original_translation = word_entry['perevod']
                current_word_for_test_word_model = original_word_text 
                prompt_for_test_word_model = original_translation   
                options_db = None
                missing_letters_positions_db = None
                correct_answer_for_db = original_word_text

                if test_type == 'add_letter':
                    prompt_for_test_word_model = original_translation
                    if test_mode == 'random_letters':
                        if len(original_word_text) > 0:
                            num_letters_to_remove = random.randint(1, min(2, len(original_word_text)))
                            positions_zero_indexed = sorted(random.sample(range(len(original_word_text)), num_letters_to_remove))
                            actual_missing_letters_list = [original_word_text[pos] for pos in positions_zero_indexed]
                            correct_answer_for_db = "".join(actual_missing_letters_list)
                            word_with_gaps_list = list(original_word_text)
                            for pos in positions_zero_indexed: word_with_gaps_list[pos] = '_'
                            current_word_for_test_word_model = "".join(word_with_gaps_list)
                            missing_letters_positions_db = ','.join(str(pos + 1) for pos in positions_zero_indexed)
                        else:
                            current_word_for_test_word_model = ""; correct_answer_for_db = ""; missing_letters_positions_db = ""
                    elif test_mode == 'manual_letters':
                        current_word_for_test_word_model = original_word_text
                        correct_answer_for_db = "" 
                        missing_letters_positions_db = None  
                            
                elif test_type == 'multiple_choice_single':
                    current_word_for_test_word_model = original_translation 
                    prompt_for_test_word_model = "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥:" 
                    correct_answer_for_db = original_word_text
                    all_other_words = [w.word for w in Word.query.filter(Word.classs == class_number, Word.word != original_word_text).limit(20).all()]
                    num_wrong_options = 3
                    wrong_options_list = random.sample(all_other_words, min(num_wrong_options, len(all_other_words)))
                    current_options_list_for_db = wrong_options_list + [original_word_text]
                    random.shuffle(current_options_list_for_db)
                    options_db = '|'.join(current_options_list_for_db)

                elif test_type == 'dictation':
                    current_word_for_test_word_model = ''.join(['_'] * len(original_word_text))
                    prompt_for_test_word_model = original_translation 
                    correct_answer_for_db = original_word_text

                elif test_type == 'true_false':
                    if word_entry['source'] == 'custom':
                        current_word_for_test_word_model = original_word_text
                        correct_answer_for_db = original_translation if original_translation.lower() in ['true', 'false'] else "True"
                    else:
                        current_word_for_test_word_model = f"{original_word_text} - {original_translation}"
                        correct_answer_for_db = "True"
                    prompt_for_test_word_model = "–í–µ—Ä–Ω–æ –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω–æ?"
                    options_db = "True|False"
                    
                elif test_type == 'fill_word':
                    current_word_for_test_word_model = original_translation
                    prompt_for_test_word_model = "–í–ø–∏—à–∏—Ç–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–µ —Å–ª–æ–≤–æ (–æ—Ä–∏–≥–∏–Ω–∞–ª):"
                    correct_answer_for_db = original_word_text

                elif test_type == 'multiple_choice_multiple':
                    current_word_for_test_word_model = original_translation
                    prompt_for_test_word_model = "–í—ã–±–µ—Ä–∏—Ç–µ –≤—Å–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã:"
                    correct_answer_for_db = original_word_text 
                    all_other_words = [w.word for w in Word.query.filter(Word.classs == class_number, Word.word != original_word_text).limit(20).all()]
                    num_options_total = 4
                    num_wrong_options_needed = num_options_total - 1
                    wrong_options_list = random.sample(all_other_words, min(num_wrong_options_needed, len(all_other_words)))
                    current_options_list_for_db = wrong_options_list + [original_word_text]
                    while len(current_options_list_for_db) < num_options_total:
                        current_options_list_for_db.append(f"–í–∞—Ä–∏–∞–Ω—Ç {len(current_options_list_for_db)+1}")
                    random.shuffle(current_options_list_for_db)
                    options_db = '|'.join(current_options_list_for_db[:num_options_total])

                test_word_entry = TestWord(
                    test_id=new_test.id,
                    word=current_word_for_test_word_model,
                    perevod=prompt_for_test_word_model,
                    correct_answer=correct_answer_for_db,
                    options=options_db,
                    missing_letters=missing_letters_positions_db,
                    word_order=idx
                )
                db.session.add(test_word_entry)
            
            db.session.commit() # Commit TestWord objects

            if new_test.type == 'add_letter' and new_test.test_mode == 'manual_letters':
                flash("–¢–µ—Å—Ç —Å–æ–∑–¥–∞–Ω. –¢–µ–ø–µ—Ä—å —É–∫–∞–∂–∏—Ç–µ, –∫–∞–∫–∏–µ –±—É–∫–≤—ã –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –≤ —Å–ª–æ–≤–∞—Ö.", "info")
                return redirect(url_for('configure_test_words', test_id=new_test.id))
            else:
                flash("–¢–µ—Å—Ç —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω!", "success")
                return redirect(url_for('tests')) # Or consider redirecting to test_details

        except Exception as e:
            db.session.rollback()
            # If new_test.id exists, it means the Test object might have been committed
            # before the exception during TestWord creation or the second commit.
            # So, we explicitly delete the Test object to avoid an orphaned Test.
            if new_test.id:
                test_to_delete = Test.query.get(new_test.id)
                if test_to_delete:
                    db.session.delete(test_to_delete)
                    db.session.commit() # Commit the deletion of the orphaned Test
            
            flash(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ç–µ—Å—Ç–∞ –∏–ª–∏ –µ–≥–æ —Å–ª–æ–≤: {str(e)}", "error")
            classes_get = [str(i) for i in range(1, 12)]
            # Pass back form data to repopulate the form
            return render_template("add_tests.html", classes=classes_get, error_message=str(e), **request.form)

    else: # GET request
        classes = [str(i) for i in range(1, 12)]
        # Pass any form data back if it was a failed POST that rendered GET
        form_data = request.form if request.form else {}
        return render_template("add_tests.html", classes=classes, **form_data)

@app.route("/tests")
def tests():
    if 'user_id' not in session:
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user:
        session.pop('user_id', None)
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))

    show_archived = request.args.get('show_archived', 'false') == 'true'
    
    tests_data = []
    if user.teacher == 'yes':
        # Teachers see all tests they created
        tests_query = Test.query.filter_by(created_by=user.id, is_active=not show_archived).order_by(Test.created_at.desc()).all()
        for test_item in tests_query:
            students_in_class = User.query.filter_by(class_number=test_item.classs, teacher='no').count()
            
            # Corrected logic for completed_results: count only student completions
            completed_count = db.session.query(TestResult.id).join(User, TestResult.user_id == User.id).filter(
                TestResult.test_id == test_item.id,
                TestResult.completed_at.isnot(None),
                User.teacher == 'no',  # Ensure only student results are counted
                TestResult.started_at >= test_item.created_at # New condition
            ).count()

            progress = 0
            if students_in_class > 0:
                progress = round((completed_count / students_in_class) * 100)
            
            tests_data.append({
                'test': test_item,
                'students_in_class': students_in_class,
                'completed_count': completed_count,
                'progress': progress
            })
    else:
        # Students see only tests for their class
        tests_query = Test.query.filter_by(classs=user.class_number, is_active=not show_archived).order_by(Test.created_at.desc()).all()
        # For students, we need to check if they completed the test to link to results, especially for archived.
        for test_item in tests_query:
            student_result = TestResult.query.filter_by(
                test_id=test_item.id,
                user_id=user.id,
            ).filter(TestResult.completed_at.isnot(None)).first()

            tests_data.append({
                'test': test_item,
                'students_in_class': 0, # Not relevant for student's direct view here
                'completed_count': 0, # Not relevant
                'progress': 0, # Not relevant
                'student_completed_result_id': student_result.id if student_result else None
            })


    return render_template('tests.html', tests_data=tests_data, show_archived=show_archived, is_teacher=user.teacher == 'yes')

@app.route("/api/tests_progress")
def api_tests_progress():
    if 'user_id' not in session:
        return jsonify({"error": "Unauthorized"}), 401

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        return jsonify({"error": "Forbidden"}), 403

    # We only care about active tests for live progress updates on the main /tests page
    tests_query = Test.query.filter_by(created_by=user.id, is_active=True).order_by(Test.created_at.desc()).all()
    
    progress_data = []
    for test_item in tests_query:
        students_in_class = User.query.filter_by(class_number=test_item.classs, teacher='no').count()
        
        completed_count = db.session.query(TestResult.id).join(User, TestResult.user_id == User.id).filter(
            TestResult.test_id == test_item.id,
            TestResult.completed_at.isnot(None),
            User.teacher == 'no',
            TestResult.started_at >= test_item.created_at # New condition
        ).count()

        progress_data.append({
            'id': test_item.id,
            'title': test_item.title, # Optional: for debugging or richer display
            'students_in_class': students_in_class,
            'completed_count': completed_count
        })
        
    return jsonify(progress_data)

@app.route("/words/json")
def get_words_json():
    words = Word.query.all()
    data = {}
    for w in words:
        if w.classs not in data:
            data[w.classs] = {}
        if w.unit not in data[w.classs]:
            data[w.classs][w.unit] = []
        data[w.classs][w.unit].append([w.word, w.perevod])
    return jsonify(data)

@app.route("/get_words_for_module_selection")
def get_words_for_module_selection():
    module_identifiers_str = request.args.get('modules', '')
    if not module_identifiers_str:
        return jsonify({"words": [], "error": "No modules provided"})

    module_identifiers = module_identifiers_str.split(',')
    words_list = []
    seen_word_ids = set()

    for module_identifier in module_identifiers:
        parts = module_identifier.split('|')
        if len(parts) == 3:
            class_num, unit_name, module_name = parts
            try:
                module_words_db = Word.query.filter_by(
                    classs=class_num,
                    unit=unit_name,
                    module=module_name
                ).order_by(Word.word).all()
                
                for mw in module_words_db:
                    if mw.id not in seen_word_ids:
                        words_list.append({
                            "id": mw.id,
                            "text": f"{mw.word} - {mw.perevod}" # Format for display
                        })
                        seen_word_ids.add(mw.id)
            except Exception as e:
                # Log error or handle it as needed
                print(f"Error fetching words for module {module_identifier}: {e}") # Basic logging
                # Optionally, you could add an error message to the response for this module
                pass # Continue to next module identifier
        else:
            # Log invalid module identifier
            print(f"Invalid module identifier format: {module_identifier}")
            pass # Continue to next module identifier
            
    return jsonify({"words": words_list})

@app.route('/api/test/<int:test_db_id>/dictation_words', methods=['GET'])
def api_test_dictation_words(test_db_id):
    if 'user_id' not in session:
        return jsonify({'error': 'Authentication required'}), 401

    user = User.query.get(session['user_id'])
    if not user:
        return jsonify({'error': 'User not found'}), 403 # Or 401

    test = Test.query.get(test_db_id)
    if not test:
        abort(404)

    if test.type != 'dictation':
        return jsonify({'error': 'Invalid test type for this endpoint'}), 400

    # Teacher preview or student taking test for their class
    if user.teacher != 'yes':
        if test.classs != user.class_number:
            return jsonify({'error': 'Access denied: Test is for a different class'}), 403
        if not test.is_active:
             return jsonify({'error': 'Access denied: Test is not active'}), 403


    test_words_query = TestWord.query.filter_by(test_id=test.id)

    if test.word_order == 'random':
        # –î–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º seed –Ω–∞ –æ—Å–Ω–æ–≤–µ user_id –∏ test_id
        # —á—Ç–æ–±—ã –ø–æ—Ä—è–¥–æ–∫ –±—ã–ª –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º –¥–ª—è –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —Ç–µ—Å—Ç–∞
        test_word_objects = list(test_words_query.all()) # Convert to list to shuffle
        
        # –°–æ–∑–¥–∞–µ–º –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π seed –Ω–∞ –æ—Å–Ω–æ–≤–µ user_id –∏ test_id
        seed_value = hash(f"{user.id}_{test.id}") % (2**32)
        random.seed(seed_value)
        random.shuffle(test_word_objects)
        random.seed()  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º seed –¥–ª—è –¥—Ä—É–≥–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
    else: # 'sequential' or any other case defaults to ordered
        test_word_objects = test_words_query.order_by(TestWord.word_order).all()

    words_data = []
    for tw in test_word_objects:
        words_data.append({
            'id': tw.id,
            'word_placeholder': tw.word,  # This is the gapped/empty string for dictation display
            'prompt': tw.perevod,         # The translation/hint given to the student
            'correct_answer': tw.correct_answer # The actual word the student needs to type
            # 'options': tw.options, # Not typically used for dictation
            # 'missing_letters': tw.missing_letters # Not typically used for dictation
        })

    return jsonify({'words': words_data, 'test_title': test.title})

# Helper function for fetching test words for various types
def _get_test_words_api_data(test_db_id, expected_test_type_slug):
    if 'user_id' not in session:
        return jsonify({'error': 'Authentication required'}), 401

    user = User.query.get(session['user_id'])
    if not user:
        return jsonify({'error': 'User not found'}), 403

    test = Test.query.get_or_404(test_db_id)

    # Teacher preview or student taking test for their class
    if user.teacher != 'yes':
        if test.classs != user.class_number:
            return jsonify({'error': 'Access denied: Test is for a different class'}), 403
        if not test.is_active:
            return jsonify({'error': 'Access denied: Test is not active'}), 403

    # Validate test type if slug implies a specific type (e.g. multiple_choice for multiple_choice_single)
    db_test_type = test.type
    if expected_test_type_slug == 'multiple_choice_single_words' and db_test_type != 'multiple_choice':
        return jsonify({'error': f'Invalid test type for this endpoint. Expected multiple_choice, got {db_test_type}'}), 400
    elif expected_test_type_slug != 'multiple_choice_single_words' and db_test_type != expected_test_type_slug.replace('_words', ''):
         return jsonify({'error': f'Invalid test type for this endpoint. Expected {expected_test_type_slug.replace("_words", "")}, got {db_test_type}'}), 400


    test_words_query = TestWord.query.filter_by(test_id=test.id)

    if test.word_order == 'random':
        # –î–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º seed –Ω–∞ –æ—Å–Ω–æ–≤–µ user_id –∏ test_id
        # —á—Ç–æ–±—ã –ø–æ—Ä—è–¥–æ–∫ –±—ã–ª –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º –¥–ª—è –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —Ç–µ—Å—Ç–∞
        test_word_objects = list(test_words_query.all()) # Convert to list to shuffle
        
        # –°–æ–∑–¥–∞–µ–º –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π seed –Ω–∞ –æ—Å–Ω–æ–≤–µ user_id –∏ test_id
        seed_value = hash(f"{user.id}_{test.id}") % (2**32)
        random.seed(seed_value)
        random.shuffle(test_word_objects)
        random.seed()  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º seed –¥–ª—è –¥—Ä—É–≥–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
    else: # 'sequential' or any other case defaults to ordered
        test_word_objects = test_words_query.order_by(TestWord.word_order).all()

    return test, test_word_objects, user


@app.route('/api/test/<int:test_db_id>/add_letter_words', methods=['GET'])
def api_test_add_letter_words(test_db_id):
    result = _get_test_words_api_data(test_db_id, 'add_letter_words')
    if not isinstance(result, tuple): # Error response from helper
        return result
    test, test_word_objects, user = result

    words_data = []
    for tw in test_word_objects:
        words_data.append({
            'id': tw.id,
            'word_gapped': tw.word, # The word with underscores
            'prompt': tw.perevod,   # Translation or hint
            'num_inputs': len(tw.correct_answer) if tw.correct_answer else 0,
            'correct_answer_letters': tw.correct_answer # The actual letters to be filled
        })
    return jsonify({'words': words_data, 'test_title': test.title, 'test_type': test.type, 'test_mode': test.test_mode})

@app.route('/api/test/<int:test_db_id>/true_false_words', methods=['GET'])
def api_test_true_false_words(test_db_id):
    result = _get_test_words_api_data(test_db_id, 'true_false_words')
    if not isinstance(result, tuple):
        return result
    test, test_word_objects, user = result

    words_data = []
    for tw in test_word_objects:
        words_data.append({
            'id': tw.id,
            'statement': tw.word, # The statement to be judged
            'prompt': tw.perevod,  # Usually "–í–µ—Ä–Ω–æ –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω–æ?" or a hint
            'options': tw.options.split('|') if tw.options else ["True", "False"], # Should be ["True", "False"]
            'correct_answer': tw.correct_answer # "True" or "False"
        })
    return jsonify({'words': words_data, 'test_title': test.title, 'test_type': test.type})

@app.route('/api/test/<int:test_db_id>/multiple_choice_single_words', methods=['GET'])
def api_test_multiple_choice_single_words(test_db_id):
    # Note: DB test.type is 'multiple_choice' for this
    result = _get_test_words_api_data(test_db_id, 'multiple_choice_single_words')
    if not isinstance(result, tuple):
        return result
    test, test_word_objects, user = result

    words_data = []
    for tw in test_word_objects:
        words_data.append({
            'id': tw.id,
            'question': tw.word, # The question text (e.g., word to translate, or definition)
            'prompt': tw.perevod, # Supporting prompt like "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥:"
            'options': tw.options.split('|') if tw.options else [],
            'correct_answer': tw.correct_answer
        })
    return jsonify({'words': words_data, 'test_title': test.title, 'test_type': test.type})


@app.route('/api/test/<int:test_db_id>/fill_word_words', methods=['GET'])
def api_test_fill_word_words(test_db_id):
    result = _get_test_words_api_data(test_db_id, 'fill_word_words')
    if not isinstance(result, tuple):
        return result
    test, test_word_objects, user = result

    words_data = []
    for tw in test_word_objects:
        words_data.append({
            'id': tw.id,
            'question_prompt': tw.word, # The prompt, e.g., a sentence with a blank or a definition
            'instruction': tw.perevod, # Specific instruction like "–í–ø–∏—à–∏—Ç–µ —Å–ª–æ–≤–æ"
            'correct_answer': tw.correct_answer
        })
    return jsonify({'words': words_data, 'test_title': test.title, 'test_type': test.type})

@app.route('/api/test/<int:test_db_id>/multiple_choice_multiple_words', methods=['GET'])
def api_test_multiple_choice_multiple_words(test_db_id):
    result = _get_test_words_api_data(test_db_id, 'multiple_choice_multiple_words')
    if not isinstance(result, tuple):
        return result
    test, test_word_objects, user = result

    words_data = []
    for tw in test_word_objects:
        words_data.append({
            'id': tw.id,
            'question': tw.word, # The question or statement
            'prompt': tw.perevod, # Supporting prompt like "–í—ã–±–µ—Ä–∏—Ç–µ –≤—Å–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã:"
            'options': tw.options.split('|') if tw.options else [],
            'correct_answers_pipe_separated': tw.correct_answer # Correct answers, e.g. "ans1|ans3"
        })
    return jsonify({'words': words_data, 'test_title': test.title, 'test_type': test.type})

@app.route("/test/<id>", methods=['GET', 'POST'])
def test_id(id):
    if 'user_id' not in session:
        flash("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –≤ —Å–∏—Å—Ç–µ–º—É, —á—Ç–æ–±—ã –ø—Ä–æ–π—Ç–∏ —Ç–µ—Å—Ç.", "error")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user:
        session.pop('user_id', None)
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))
        
    # –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–µ—Å—Å–∏–∏ –∏ cookies
    print(f"DEBUG: test_id route - session data: {dict(session)}")
    print(f"DEBUG: Current user: {user.nick}, ID: {user.id}")
    print(f"DEBUG: Cookies: {request.cookies}")
    
    if 'active_test_result_id' in session:
        print(f"DEBUG: active_test_result_id from session: {session['active_test_result_id']}")
    else:
        print("DEBUG: No active_test_result_id in session")
        
    if 'active_test_result_id' in request.cookies:
        print(f"DEBUG: active_test_result_id from cookie: {request.cookies.get('active_test_result_id')}")

    test = Test.query.filter_by(link=id).first()
    if not test:
        abort(404)

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ —Ä–µ–∂–∏–º–æ–º –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –¥–ª—è —É—á–∏—Ç–µ–ª—è
    is_teacher_preview_mode = False
    if user.teacher == 'yes' and (session.get('is_teacher_preview', False) or session.get('test_link') == id):
        is_teacher_preview_mode = True
        print("DEBUG: Teacher preview mode detected")
    
    # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π —Ç–µ—Å—Ç –∏–∑ —Å–µ—Å—Å–∏–∏ –∏–ª–∏ cookie –¥–ª—è —Å—Ç—É–¥–µ–Ω—Ç–∞
    test_result = None
    
    # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ —Å–µ—Å—Å–∏–∏
    if 'active_test_result_id' in session:
        test_result_id = session['active_test_result_id']
        test_result = TestResult.query.get(test_result_id)
        print(f"DEBUG: Found test_result from session: {test_result}")
    
    # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ —Å–µ—Å—Å–∏–∏, –ø—Ä–æ–±—É–µ–º –∏–∑ cookie
    if not test_result and 'active_test_result_id' in request.cookies:
        try:
            test_result_id = int(request.cookies.get('active_test_result_id'))
            test_result = TestResult.query.get(test_result_id)
            if test_result:
                # –ï—Å–ª–∏ –Ω–∞—à–ª–∏ –≤ cookie, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Å–µ—Å—Å–∏—é –¥–ª—è –±—É–¥—É—â–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
                session['active_test_result_id'] = test_result_id
                session['test_link'] = id
                session.modified = True
                print(f"DEBUG: Found test_result from cookie and saved to session: {test_result}")
        except (ValueError, TypeError):
            print("DEBUG: Invalid test_result_id in cookie")
    
    # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ —É—á–∏—Ç–µ–ª—å –∏ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞ –Ω–∏ –≤ —Å–µ—Å—Å–∏–∏, –Ω–∏ –≤ cookie,
    # –ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–π —Ç–µ—Å—Ç –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —ç—Ç–æ–≥–æ —Ç–µ—Å—Ç–∞
    if user.teacher == 'no' and not test_result:
        incomplete_result = TestResult.query.filter_by(
            test_id=test.id,
            user_id=user.id,
            completed_at=None
        ).first()
        
        if incomplete_result:
            test_result = incomplete_result
            session['active_test_result_id'] = incomplete_result.id
            session['test_link'] = id
            session.modified = True
            print(f"DEBUG: Found incomplete test result from database: {test_result}")
        else:
            print("DEBUG: Student without active test result, redirecting to take_test")
            flash("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ —Ç–µ—Å—Ç —Å –Ω–∞—á–∞–ª—å–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã.", "warning")
            return redirect(url_for('take_test', test_link=id))

    # Handle POST requests (submitting answers)
    if request.method == 'POST':
        if user.teacher == 'yes':
            # Teachers in preview mode do not save results
            flash("–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —Ç–µ—Å—Ç–∞. –û—Ç–≤–µ—Ç—ã –Ω–µ –±—ã–ª–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã.", "info")
            return redirect(url_for('test_details', test_id=test.id))
        
        # --- STUDENT SUBMISSION LOGIC (remains largely the same) ---
        if not test_result: # Should not happen if student started test correctly
            # This indicates a potential issue or direct POST without GET,
            # or test_result was not initiated properly.
            # For robustness, try to get or create one.
            test_result = TestResult.query.filter_by(
                test_id=test.id,
                user_id=user.id,
                completed_at=None
            ).first()
            if not test_result: # If still not found, student likely hasn't started.
                                # This situation ideally is caught by GET request flow.
                flash("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∞–∫—Ç–∏–≤–Ω—ã–π —Å–µ–∞–Ω—Å —Ç–µ—Å—Ç–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ —Ç–µ—Å—Ç —Å–Ω–∞—á–∞–ª–∞.", "warning")
                return redirect(url_for('take_test', test_link=test.link)) # Redirect to start

        # Process answers
        answers_dict_for_json = {} # To store in TestResult.answers (JSON)
        score = 0
        processed_answers_for_db = [] # To store TestAnswer objects

        for word in test.test_words:
            user_input_answer = request.form.get(f'answer{word.id}', '').strip()
            # Storing raw user input for TestAnswer, lowercasing for comparison
            user_answer_for_comparison = user_input_answer.lower()
            
            answers_dict_for_json[str(word.id)] = user_input_answer # Store original case for JSON

            is_this_answer_correct = False
            actual_correct_answer_for_comparison = word.correct_answer.lower()

            if test.type == 'add_letter':
                # For add_letter, word.correct_answer already holds the combined missing letters
                if user_answer_for_comparison == actual_correct_answer_for_comparison:
                    is_this_answer_correct = True
            elif test.type == 'multiple_choice_single' or test.type == 'multiple_choice_multiple':
                # For MC, word.correct_answer holds the correct option text
                if user_answer_for_comparison == actual_correct_answer_for_comparison:
                    is_this_answer_correct = True
            elif test.type == 'dictation':
                if user_answer_for_comparison == actual_correct_answer_for_comparison:
                    is_this_answer_correct = True
            elif test.type == 'true_false':
                # For true_false, correct_answer is 'True' or 'False'
                if user_input_answer.capitalize() == word.correct_answer: # Comparison is case-insensitive for T/F but store as True/False
                    is_this_answer_correct = True
            elif test.type == 'fill_word':
                if user_answer_for_comparison == actual_correct_answer_for_comparison:
                    is_this_answer_correct = True
            else: # Fallback for any other types or if logic is missing
                if user_answer_for_comparison == actual_correct_answer_for_comparison:
                    is_this_answer_correct = True
            
            if is_this_answer_correct:
                score += 1
            
            processed_answers_for_db.append({
                'test_word_id': word.id,
                'user_answer': user_input_answer, # Store raw input
                'is_correct': is_this_answer_correct
            })

        # Update test result
        test_result.score = int((score / len(test.test_words)) * 100) if len(test.test_words) > 0 else 0
        test_result.correct_answers = score
        completion_time = datetime.utcnow()
        test_result.completed_at = completion_time
        
        # Calculate time taken in minutes (safe calculation)
        if test_result.started_at:
            time_diff = completion_time - test_result.started_at
            test_result.time_taken = max(0, int(time_diff.total_seconds() / 60))  # Convert to minutes, ensure non-negative
        else:
            test_result.time_taken = 0  # Fallback if started_at is missing
            
        test_result.answers = json.dumps(answers_dict_for_json) # Keep the JSON dump as it might be used elsewhere or for quick view
        
        # Add TestAnswer instances
        for ans_data in processed_answers_for_db:
            test_answer_entry = TestAnswer(
                test_result_id=test_result.id,
                test_word_id=ans_data['test_word_id'],
                user_answer=ans_data['user_answer'],
                is_correct=ans_data['is_correct']
            )
            db.session.add(test_answer_entry)

        db.session.commit()

        return redirect(url_for('test_results', test_id=test.id, result_id=test_result.id))

    # --- HANDLE GET REQUESTS ---

    # Teacher Preview Logic for GET
    if user.teacher == 'yes':
        # Teachers can preview their own tests or any active test.
        # If archived, only creator can preview.
        if not test.is_active and test.created_by != user.id:
            flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç –∑–∞–∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω, –∏ –≤—ã –Ω–µ —è–≤–ª—è–µ—Ç–µ—Å—å –µ–≥–æ —Å–æ–∑–¥–∞—Ç–µ–ª–µ–º. –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω.", "warning")
            return redirect(url_for('tests'))
        
        is_teacher_preview_mode = True
        # For teachers, no TestResult is needed for preview.
        # Time is unlimited for preview.
        remaining_time_seconds = -1 # Indicator for unlimited time
        test_result = None # Explicitly set to None for teacher preview context
    
    # Student Test-Taking Logic for GET
    else: # user.teacher == 'no'
        # Check if student has access to this test (class matches)
        print(f"DEBUG: test.classs={test.classs}, user.class_number={user.class_number}")
        if test.classs != user.class_number:
            flash(f"–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω: —Ç–µ—Å—Ç –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –∫–ª–∞—Å—Å–∞ {test.classs}, –∞ –≤—ã –≤ –∫–ª–∞—Å—Å–µ {user.class_number}.", "error")
            return redirect(url_for('tests'))

        # Check if test is active (students cannot take archived tests)
        if not test.is_active:
            flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç –±–æ–ª—å—à–µ –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω.", "error")
            return redirect(url_for('tests'))

        # Get or create test result for students
        test_result = TestResult.query.filter_by(
            test_id=test.id,
            user_id=user.id,
            completed_at=None
        ).first()

        if test_result: # An incomplete test was found
            if not test_result.started_at: # Ensure it has a start time if resuming
                test_result.started_at = datetime.utcnow()
                db.session.commit()
        else: # No incomplete test_result was found
            completed_test_run = TestResult.query.filter_by(
                test_id=test.id,
                user_id=user.id
            ).filter(TestResult.completed_at.isnot(None)).order_by(TestResult.completed_at.desc()).first()

            if completed_test_run:
                flash("–í—ã —É–∂–µ –∑–∞–≤–µ—Ä—à–∏–ª–∏ —ç—Ç–æ—Ç —Ç–µ—Å—Ç. –ü—Ä–æ—Å–º–æ—Ç—Ä –≤–∞—à–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.", "info")
                return redirect(url_for('test_results', test_id=test.id, result_id=completed_test_run.id))
            else:
                # Student is starting for the first time
                test_result = TestResult(
                    test_id=test.id,
                    user_id=user.id,
                    total_questions=len(test.test_words) if test.test_words else 0,
                    started_at=datetime.utcnow()
                )
                db.session.add(test_result)
                db.session.commit()
        
        # Calculate remaining time for students
        remaining_time_seconds = -1 # Default for unlimited time
        time_is_up_on_server = False
        if test.time_limit and test.time_limit > 0 and test_result and test_result.started_at:
            elapsed_seconds = (datetime.utcnow() - test_result.started_at).total_seconds()
            total_duration_seconds = test.time_limit * 60
            remaining_time_seconds = max(0, int(total_duration_seconds - elapsed_seconds))
            if remaining_time_seconds == 0:
                time_is_up_on_server = True
                if not test_result.completed_at: # Auto-submit if time is up on server
                    flash("–í—Ä–µ–º—è –Ω–∞ —Ç–µ—Å—Ç –≤—ã—à–ª–æ. –¢–µ—Å—Ç –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.", "warning")
                    # Simplified auto-submit: mark as completed. Client should ideally handle submission.
                    # For a more robust auto-submit, answers would need to be saved progressively.
                    # Consider if answers submitted via form post-timeout should be accepted or rejected.
                    # The POST handler has its own time check.
                    pass # Let client-side timer trigger submission for now.


    # Common rendering logic for both teachers (preview) and students (taking test)
    # The specific template and words_list will depend on test.type

    if test.type == 'add_letter':
        if not is_teacher_preview_mode: # Student specific checks
            if test.test_mode == 'manual_letters':
                if test.test_words and any(tw.missing_letters is None for tw in test.test_words):
                    flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç (–≤—Å—Ç–∞–≤–∏—Ç—å –±—É–∫–≤—ã) –µ—â–µ –Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–∞—Å—Ç—Ä–æ–µ–Ω —É—á–∏—Ç–µ–ª–µ–º –∏ –ø–æ–∫–∞ –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è.", "warning")
                    return redirect(url_for('tests'))

        # words_list = []
        # for word in test.test_words:
            # Debug prints can be removed in production
            # print(f"--- Word Details for Test '{test.title}' (Link: {test.link}) ---")
            # print(f"  TestWord ID: {word.id}")
            # print(f"  Gapped Word (to display): '{word.word}'")
            # print(f"  Translation/Hint: '{word.perevod}'")
            # print(f"  Correct letters (to be inserted by student): '{word.correct_answer}'")
            # if word.missing_letters:
            #     print(f"  Missing letter positions (1-indexed in original word): '{word.missing_letters}'")
            # print(f"  Number of letters to input: {len(word.correct_answer) if word.correct_answer else 0}")
            # print("-" * 40)
            # words_list.append({
            #     'id': word.id,
            #     'word': word.word,
            #     'perevod': word.perevod,
            #     'num_inputs': len(word.correct_answer) if word.correct_answer else 0
            # })
        return render_template('test_add_letter.html', 
                             # words=words_list,
                             test_id=id, # link
                             test_result=test_result, # Will be None for teacher preview
                             time_limit=test.time_limit,
                             remaining_time_seconds=remaining_time_seconds,
                             test_title=test.title, 
                             test_db_id=test.id, # numerical ID
                             is_teacher_preview=is_teacher_preview_mode) # Pass the preview flag
    elif test.type == 'dictation':
        # This block was modified in the previous step, ensuring it remains correct.
        # Debug prints can be removed
        # print(f"DEBUG: Accessing dictation test with link: {id}")
        # print(f"DEBUG: Test object: {test}")
        # print(f"DEBUG: Test.test_words count: {len(test.test_words) if test.test_words else 0}")
        # if test.test_words:
        #     for i, tw in enumerate(test.test_words):
        #         print(f"DEBUG: TestWord {i}: id={tw.id}, word='{tw.word}', perevod='{tw.perevod}', correct_answer='{tw.correct_answer}'")
        
        # words_list = [(word.word, word.perevod, word.correct_answer, word.id) for word in test.test_words]
        
        current_test_result_for_template = test_result # Use the one determined by student/teacher logic
        if is_teacher_preview_mode:
            current_test_result_for_template = None # Ensure no result object for teacher preview

        return render_template('test_dictation.html', 
                             test_title=test.title,
                             # words_data=words_list, # Removed as per requirement
                             test_link_id=id,
                             current_test_result=current_test_result_for_template, # Pass the correct result object
                             time_limit_seconds=test.time_limit * 60 if test.time_limit else 0,
                             remaining_time_seconds=remaining_time_seconds,
                             test_db_id=test.id,
                             is_teacher_preview=is_teacher_preview_mode) # Pass the preview flag
    elif test.type == 'true_false':
        # words_list = [(word.word, word.perevod, word.id) for word in test.test_words] # Added word.id
        return render_template('test_true_false.html',
                             # words=words_list,
                             test_id=id, # link
                             test_result=test_result, # Will be None for teacher preview
                             time_limit=test.time_limit,
                             remaining_time_seconds=remaining_time_seconds,
                             test_title=test.title,
                             test_db_id=test.id,
                             is_teacher_preview=is_teacher_preview_mode)
    elif test.type == 'multiple_choice':
        # words_list = []
        # for word in test.test_words:
            # options = word.options.split('|') if word.options else []
            # words_list.append({
                # 'id': word.id,
                # 'word': word.word, # This is the question (e.g., translation)
                # 'perevod': word.perevod, # This is the prompt (e.g., "Choose the correct word")
                # 'options': options
            # })
        return render_template('test_multiple_choice.html', 
                             # words=words_list,
                             test_id=id, # link
                             test_result=test_result, # Will be None for teacher preview
                             time_limit=test.time_limit,
                             remaining_time_seconds=remaining_time_seconds,
                             test_title=test.title,
                             test_db_id=test.id,
                             is_teacher_preview=is_teacher_preview_mode)
    elif test.type == 'fill_word':
        # words_list = []
        # for word in test.test_words:
            # words_list.append({
                # 'id': word.id,
                # 'word': word.word, # This is the question (e.g., translation)
                # 'perevod': word.perevod # This is the prompt (e.g., "Fill in the original word")
            # })
        return render_template('test_fill_word.html',
                             # words=words_list,
                             test_id=id, # link
                             test_result=test_result, # Will be None for teacher preview
                             time_limit=test.time_limit,
                             remaining_time_seconds=remaining_time_seconds,
                             test_title=test.title,
                             test_db_id=test.id,
                             is_teacher_preview=is_teacher_preview_mode)
    elif test.type == 'multiple_choice_multiple':
        # words_list = []
        # for word in test.test_words:
            # options = word.options.split('|') if word.options else []
            # words_list.append({
                # 'id': word.id,
                # 'word': word.word,       # Question (e.g., translation/definition)
                # 'perevod': word.perevod, # Prompt (e.g., "Select all correct options")
                # 'options': options
            # })
        return render_template('test_multiple_choice_multiple.html',
                             # words=words_list,
                             test_id=id, # link
                             test_result=test_result, # Will be None for teacher preview
                             time_limit=test.time_limit,
                             remaining_time_seconds=remaining_time_seconds,
                             test_title=test.title,
                             test_db_id=test.id,
                             is_teacher_preview=is_teacher_preview_mode)
    else:
        # Fallback for unknown test types
        flash(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Ç–µ—Å—Ç–∞: {test.type}", "error")
        return redirect(url_for('tests'))

@app.route("/edit_profile")
def edit_profile():
    if 'user_id' not in session:
        return redirect(url_for('auth.login'))
    
    user = User.query.get(session['user_id'])
    if not user:
        session.pop('user_id', None)
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))
        
    return render_template('edit_profile.html', nick=user.nick, fio=user.fio)

@app.route("/save_profile", methods=["POST"])
def save_profile():
    fio = request.form.get("fio")
    nick = request.form.get("nick")

    user = User.query.filter_by(nick=nick).first()
    if user:
        user.fio = fio
        db.session.commit()

    return redirect("/profile")

# @app.route("/add_words", methods=['POST', 'GET']) # This route is now handled by words_bp
# def add_words():
#     ... (implementation removed) ...

@app.route("/get_units_for_class")
def get_units_for_class():
    class_name = request.args.get('class_name')
    if not class_name:
        return jsonify([])
    
    # Get unique units for the selected class
    units = db.session.query(Word.unit).filter(
        Word.classs == class_name
    ).distinct().all()
    
    return jsonify([unit[0] for unit in units])

@app.route("/get_modules_for_unit")
def get_modules_for_unit():
    class_name = request.args.get('class_name')
    unit_name = request.args.get('unit_name')
    
    if not class_name or not unit_name:
        return jsonify([])
    
    # Get unique modules for the selected class and unit
    modules = db.session.query(Word.module).filter(
        Word.classs == class_name,
        Word.unit == unit_name
    ).distinct().all()
    
    return jsonify([module[0] for module in modules])

@app.route('/get_word_count')
def get_word_count():
    class_name = request.args.get('class_name')
    unit_name = request.args.get('unit_name')
    module_name = request.args.get('module_name')
    units = request.args.getlist('units')
    modules = request.args.getlist('modules')
    
    if not class_name:
        return jsonify({'count': 0})
    
    query = Word.query.filter_by(classs=class_name)
    
    if units:
        # Multiple units
        query = query.filter(Word.unit.in_(units))
    elif unit_name:
        query = query.filter_by(unit=unit_name)
        
        if modules:
            # Multiple modules within a unit
            query = query.filter(Word.module.in_(modules))
        elif module_name:
            # Specific module
            query = query.filter_by(module=module_name)
    
    count = query.count()
    return jsonify({'count': count})

@app.route("/get_modules_for_sentence_game")
def get_modules_for_sentence_game():
    class_name = request.args.get('class_name')
    unit_name = request.args.get('unit_name')
    
    if not class_name or not unit_name:
        return jsonify([])
    
    # Get unique modules for the selected class and unit that have sentences
    modules = db.session.query(Sentence.module).filter(
        Sentence.classs == class_name,
        Sentence.unit == unit_name
    ).distinct().order_by(Sentence.module).all()
    
    return jsonify([module[0] for module in modules if module[0]])

# Words routes are now in blueprints.words
# @app.route('/words/json') ... (moved)
# @app.route("/get_units_for_class") ... (moved)
# @app.route("/get_modules_for_unit") ... (moved)
# @app.route('/words') ... (moved)
# @app.route("/add_words", methods=['POST', 'GET']) ... (moved)
# @app.route('/edit_word/<int:word_id>', methods=['GET', 'POST']) ... (moved)
# @app.route('/delete_word/<int:word_id>', methods=['POST']) ... (moved)
# @app.route('/class/<class_name>/<unit_name>/<module_name>') ... (moved)
# @app.route('/quizlet/<class_name>/<unit_name>/<module_name>') ... (moved)
# Note: Obsolete /edit_word and /update_word routes were already removed or not part of this list.
# Note: Granular add routes like /add_unit_to_class were already removed or not part of this list.


@app.route("/hello")
def hello():
    if 'user_id' not in session:
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user:
        session.pop('user_id', None) # Clean up invalid session
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))

    fio_parts = user.fio.split(' ')
    try:
        letters = fio_parts[0][:1] + fio_parts[1][:1]
    except:
        letters = user.fio[0] + user.fio[1]

    return render_template('hello.html', username=user.nick, letters=letters)

@app.route("/about")
def about():
    return render_template("about.html")

# Old delete_word route removed in favor of the new route with more precise word identification

# @app.route("/edit_word") # This route is now handled by words_bp.edit_word
# def edit_word_form():
#  ... (implementation removed) ...

# @app.route("/update_word", methods=["POST"]) # This functionality is now part of words_bp.edit_word (POST)
# def update_word():
#  ... (implementation removed) ...

@app.route("/add_unit_to_class")
def add_unit_to_class_form():
    class_name = request.args.get("class")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å —é–Ω–∏—Ç –≤ {class_name}</h2>
    <form action="/save_unit" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="text" name="unit" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ —é–Ω–∏—Ç–∞" required />
        <button type="submit">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
    </form>
    """
@app.route("/add_module_to_unit")
def add_module_to_unit_form():
    class_name = request.args.get("class")
    unit_name = request.args.get("unit")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å –º–æ–¥—É–ª—å –≤ {unit_name} ({class_name})</h2>
    <form action="/save_module" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="hidden" name="unit" value="{unit_name}" />
        <input type="text" name="module" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ –º–æ–¥—É–ª—è" required />
        <button type="submit">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
    </form>
    """

@app.route("/save_module", methods=["POST"])
def save_module():
    class_name = request.form.get("class")
    unit_name = request.form.get("unit")
    module_name = request.form.get("module")

    dummy_word = Word(word="dummy", perevod="–∑–∞–≥–ª—É—à–∫–∞", classs=class_name, unit=unit_name, module=module_name)
    db.session.add(dummy_word)
    db.session.commit()

    return redirect(url_for('words.words'))

@app.route("/add_word_to_module")
def add_word_to_module_form():
    class_name = request.args.get("class")
    unit_name = request.args.get("unit")
    module_name = request.args.get("module")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–æ –≤ –º–æ–¥—É–ª—å: {module_name} ({unit_name}, {class_name})</h2>
    <form action="/add_word" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="hidden" name="unit" value="{unit_name}" />
        <input type="hidden" name="module" value="{module_name}" />
        <label>–°–ª–æ–≤–æ:</label><br/>
        <input type="text" name="word" required /><br/>
        <label>–ü–µ—Ä–µ–≤–æ–¥:</label><br/>
        <input type="text" name="perevod" required /><br/>
        <button type="submit">–î–æ–±–∞–≤–∏—Ç—å</button>
    </form>
    """

@app.route("/save_unit", methods=["POST"])
def save_unit():
    class_name = request.form.get("class")
    unit_name = request.form.get("unit")

    # –ü—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º –ª—é–±–æ–µ —Å–ª–æ–≤–æ, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å —Å–≤—è–∑—å –∫–ª–∞—Å—Å–∞ –∏ –º–æ–¥—É–ª—è
    dummy_word = Word(word="dummy", perevod="–∑–∞–≥–ª—É—à–∫–∞", classs=class_name, unit=unit_name)
    db.session.add(dummy_word)
    db.session.commit()

    return redirect(url_for('words.words'))

@app.route("/add_word_to_unit")
def add_word_to_unit_form():
    class_name = request.args.get("class")
    unit_name = request.args.get("unit")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–æ –≤ {unit_name} ({class_name})</h2>
    <form action="/add_word" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="hidden" name="unit" value="{unit_name}" />
        <label>–°–ª–æ–≤–æ:</label><br/>
        <input type="text" name="word" required /><br/>
        <label>–ü–µ—Ä–µ–≤–æ–¥:</label><br/>
        <input type="text" name="perevod" required /><br/>
        <button type="submit">–î–æ–±–∞–≤–∏—Ç—å</button>
    </form>
    """

@app.route("/add_word", methods=["POST"])
def add_word():
    class_name = request.form.get("class")
    unit_name = request.form.get("unit")
    module_name = request.form.get("module")
    word = request.form.get("word")
    perevod = request.form.get("perevod")

    # Validate that all required fields are filled out
    if not class_name or not unit_name or not module_name:
        flash("–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–æ: –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–∞–ø–æ–ª–Ω–∏—Ç—å –∫–ª–∞—Å—Å, —é–Ω–∏—Ç –∏ –º–æ–¥—É–ª—å", "error")
        return redirect(url_for('words.words'))

    new_word = Word(word=word, perevod=perevod, classs=class_name, unit=unit_name, module=module_name)
    db.session.add(new_word)
    db.session.commit()

    return redirect(url_for('words.words'))



@app.route('/class/<class_name>/<unit_name>/<module_name>')
def module_words(class_name, unit_name, module_name):
    words = Word.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()
    return render_template('module_words.html', 
                         words=words,
                         class_name=class_name,
                         unit_name=unit_name,
                         module_name=module_name)

@app.route('/quizlet/<class_name>/<unit_name>/<module_name>')
def quizlet_cards(class_name, unit_name, module_name):
    word_objects = Word.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()
    # Convert Word objects to dictionaries for JSON serialization
    words = [{'id': word.id, 'word': word.word, 'perevod': word.perevod, 
              'classs': word.classs, 'unit': word.unit, 'module': word.module} 
             for word in word_objects]
    return render_template('quizlet_cards.html',
                         words=words,
                         class_name=class_name,
                         unit_name=unit_name,
                         module_name=module_name)

def generate_test_link():
    """Generate a random unique link for a test"""
    while True:
        link = ''.join(random.choices(string.ascii_letters + string.digits, k=10))
        if not Test.query.filter_by(link=link).first():
            return link

@app.route("/create_test", methods=['GET', 'POST'])
def create_test():
    if 'user_id' not in session:
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –∫–∞–∫ —É—á–∏—Ç–µ–ª—å.", "warning")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –¢–æ–ª—å–∫–æ —É—á–∏—Ç–µ–ª—è –º–æ–≥—É—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å —Ç–µ—Å—Ç—ã.", "warning")
        if not user: # If user is None (e.g. ID in session is invalid), pop session and redirect
            session.pop('user_id', None)
        return redirect(url_for('auth.login'))
    
    if request.method == 'POST':
        test_type = request.form.get('test_type')
        class_number = request.form.get('class_number')
        title = request.form.get('title')
        
        time_limit_str = request.form.get('time_limit')
        # Time limit: 0 or empty means None (unlimited)
        time_limit = int(time_limit_str) if time_limit_str and time_limit_str.isdigit() and int(time_limit_str) > 0 else None
        
        # General word order for the final list of test words
        word_order_form = request.form.get('word_order', 'sequential') 
        
        # General word count to limit the final number of words (can be None)
        word_count_form_str = request.form.get('word_count')
        word_count_form = int(word_count_form_str) if word_count_form_str and word_count_form_str.isdigit() and int(word_count_form_str) > 0 else None

        test_mode = request.form.get('test_mode', 'random_letters') if test_type == 'add_letter' else None
        
        new_test_params = {
            'title': title,
            'classs': class_number,
            'type': test_type,
            'link': generate_test_link(),
            'created_by': user.id,
            'time_limit': time_limit,
            'word_order': word_order_form, # This is the overall order
            'test_mode': test_mode,
            # unit and module will default to "N/A" if not provided by selected modules
        }

        words_data_source = [] # Holds {'word': ..., 'perevod': ..., 'source': ...}

        if test_type == 'dictation':
            dictation_word_source = request.form.get('dictation_word_source')
            new_test_params['dictation_word_source'] = dictation_word_source

            selected_modules = request.form.getlist('modules[]')
            module_words_list = []
            if selected_modules: # Fetch module words if any modules are selected
                for module_identifier in selected_modules:
                    class_num, unit, module_name = module_identifier.split('|')
                    module_words_db = Word.query.filter_by(
                        classs=class_num,
                        unit=unit,
                        module=module_name
                    ).all()
                    for mw in module_words_db:
                        module_words_list.append({'word': mw.word, 'perevod': mw.perevod, 'source': 'module'})
            
            if dictation_word_source == 'all_module':
                words_data_source.extend(module_words_list)
                # General word_count_form applies as a limiter
                new_test_params['word_count'] = word_count_form 

            elif dictation_word_source == 'random_from_module':
                dictation_num_random_words_str = request.form.get('dictation_random_word_count')
                dictation_num_random_words = int(dictation_num_random_words_str) if dictation_num_random_words_str and dictation_num_random_words_str.isdigit() else 0
                
                new_test_params['word_count'] = dictation_num_random_words if dictation_num_random_words > 0 else None # Store the count of random words
                
                if module_words_list and dictation_num_random_words > 0:
                    random.shuffle(module_words_list)
                    words_data_source.extend(module_words_list[:dictation_num_random_words])

            elif dictation_word_source == 'selected_specific':
                specific_word_ids_str = request.form.getlist('dictation_specific_word_ids[]')
                specific_word_ids = [int(id_str) for id_str in specific_word_ids_str if id_str.isdigit()]
                new_test_params['dictation_selected_words'] = json.dumps(specific_word_ids)
                
                if specific_word_ids:
                    selected_db_words = Word.query.filter(Word.id.in_(specific_word_ids)).all()
                    for sw in selected_db_words:
                        words_data_source.append({'word': sw.word, 'perevod': sw.perevod, 'source': 'module_specific'})
                # General word_count_form can optionally limit these selected words
                new_test_params['word_count'] = word_count_form

            # Add custom words for dictation - these are always included
            custom_words_text = request.form.getlist('custom_words[]')
            custom_translations_text = request.form.getlist('custom_translations[]')
            for cw_text, ct_text in zip(custom_words_text, custom_translations_text):
                if cw_text and ct_text:
                    words_data_source.append({'word': cw_text, 'perevod': ct_text, 'source': 'custom'})
        
        else: # For other test types (non-dictation)
            new_test_params['word_count'] = word_count_form # General word count applies

            selected_modules = request.form.getlist('modules[]')
            if selected_modules:
                for module_identifier in selected_modules:
                    class_num, unit, module_name = module_identifier.split('|')
                    module_words_db = Word.query.filter_by(
                        classs=class_num,
                        unit=unit,
                        module=module_name
                    ).all()
                    for mw in module_words_db:
                        words_data_source.append({'word': mw.word, 'perevod': mw.perevod, 'source': 'module'})

            custom_words_text = request.form.getlist('custom_words[]')
            custom_translations_text = request.form.getlist('custom_translations[]')
            for cw_text, ct_text in zip(custom_words_text, custom_translations_text):
                if cw_text and ct_text:
                    words_data_source.append({'word': cw_text, 'perevod': ct_text, 'source': 'custom'})
        
        # Create Test object
        new_test = Test(**new_test_params)
        db.session.add(new_test)
        db.session.commit() # Commit to get new_test.id so TestWord entries can be linked
        
        # –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ê–Ø –û–ß–ò–°–¢–ö–ê –†–ï–ó–£–õ–¨–¢–ê–¢–û–í –ü–†–ï–î–´–î–£–©–ò–• –¢–ï–°–¢–û–í
        try:
            results_cleared_count, tests_affected = auto_clear_previous_test_results(
                teacher_user=user,
                class_number=class_number,
                new_test_id=new_test.id
            )
            
            if results_cleared_count > 0:
                affected_tests_str = ", ".join(tests_affected[:3])  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 3 —Ç–µ—Å—Ç–∞
                if len(tests_affected) > 3:
                    affected_tests_str += f" –∏ –µ—â–µ {len(tests_affected) - 3}"
                
                test_type_str = "–∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤" if CLEAR_ONLY_ACTIVE_TESTS else "—Ç–µ—Å—Ç–æ–≤"
                flash(f"–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—á–∏—â–µ–Ω–æ {results_cleared_count} —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏–∑ {test_type_str} –¥–ª—è –∫–ª–∞—Å—Å–∞ {class_number} ({affected_tests_str}).", "info")
            
        except Exception as e:
            # –ï—Å–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ, –Ω–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–∞
            # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –Ω–æ–≤–æ–≥–æ —Ç–µ—Å—Ç–∞
            try:
                db.session.rollback()
                db.session.add(new_test)
                db.session.commit()
            except:
                pass  # –ï—Å–ª–∏ –∏ —ç—Ç–æ –Ω–µ —É–¥–∞–ª–æ—Å—å, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
            
            print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—á–∏—Å—Ç–∫–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤: {e}")
            flash("–¢–µ—Å—Ç —Å–æ–∑–¥–∞–Ω, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—á–∏—Å—Ç–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Ç–µ—Å—Ç–æ–≤.", "warning")

        # Final processing of words_data_source based on general word_order and word_count
        # (This was previously somewhat mixed with initial fetching)

        # 1. Shuffle if overall word_order is 'random'
        if new_test.word_order == 'random':
            random.shuffle(words_data_source)
        
        # 2. Apply general word_count as a final limiter, 
        #    but only if it hasn't been specifically set by 'random_from_module' dictation.
        #    For 'all_module' and 'selected_specific' dictation, word_count_form acts as the limiter.
        #    For non-dictation tests, word_count_form acts as the limiter.
        
        final_word_count_to_use = new_test.word_count # This comes from new_test_params

        if final_word_count_to_use is not None and final_word_count_to_use > 0:
            if len(words_data_source) > final_word_count_to_use:
                words_data_source = words_data_source[:final_word_count_to_use]
        elif final_word_count_to_use == 0: # Explicitly 0 means no words (edge case, but good to define)
             words_data_source = []


        # Create test words (The rest of the logic for populating TestWord based on test_type)
        for idx, word_entry in enumerate(words_data_source):
            original_word_text = word_entry['word']
            original_translation = word_entry['perevod']
            
            current_word_for_test_word_model = original_word_text 
            prompt_for_test_word_model = original_translation   
            options_db = None
            missing_letters_positions_db = None
            correct_answer_for_db = original_word_text 

            if test_type == 'add_letter':
                prompt_for_test_word_model = original_translation
                if test_mode == 'random_letters':
                    letter_indices = [i for i, char in enumerate(original_word_text) if char != ' ']
                    num_actual_letters = len(letter_indices)

                    if num_actual_letters > 0:
                        # Determine base number of letters to remove based on actual letter count
                        if num_actual_letters <= 3:
                            val = 1
                        elif num_actual_letters <= 6:
                            val = random.randint(1, 2)
                        elif num_actual_letters <= 9:
                            val = random.randint(2, 3)
                        else: # 10+ actual letters
                            val = random.randint(3, 4)

                        # Adjust num_letters_to_remove
                        if num_actual_letters == 1: # For a single letter word, always remove that one letter
                            num_letters_to_remove = 1
                        else:
                            # For words with more than one letter, remove at most half, but at least 1
                            num_letters_to_remove = min(val, num_actual_letters // 2)
                            num_letters_to_remove = max(1, num_letters_to_remove)

                        positions_zero_indexed = sorted(random.sample(letter_indices, num_letters_to_remove))
                        
                        actual_missing_letters_list = [original_word_text[pos] for pos in positions_zero_indexed]
                        correct_answer_for_db = "".join(actual_missing_letters_list)
                        
                        word_with_gaps_list = list(original_word_text)
                        for pos in positions_zero_indexed:
                            word_with_gaps_list[pos] = '_'
                        current_word_for_test_word_model = "".join(word_with_gaps_list)
                        missing_letters_positions_db = ','.join(str(pos + 1) for pos in positions_zero_indexed) # Store 1-indexed

                    else: # No actual letters in original_word_text (it's empty or all spaces)
                        current_word_for_test_word_model = original_word_text
                        correct_answer_for_db = ""
                        missing_letters_positions_db = ""
                elif test_mode == 'manual_letters':
                    # For manual mode, initially save the original word.
                    # Configuration will happen in a separate step via configure_test_words.
                    current_word_for_test_word_model = original_word_text
                    # prompt_for_test_word_model is already set
                    correct_answer_for_db = ""  # Intentionally blank, to be filled in config step
                    missing_letters_positions_db = None  # To be filled in config step
                    # Removed logic that tried to get 'manual_missing_indices_for_words' here.
                    # Removed flash messages regarding missing manual indices here.
                        
            elif test_type == 'multiple_choice_single':
                current_word_for_test_word_model = original_translation # This is the question: "What is the word for X?"
                prompt_for_test_word_model = "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥:" 
                correct_answer_for_db = original_word_text
                
                all_other_words_in_class = [w.word for w in Word.query.filter(Word.classs == class_number, Word.word != original_word_text).all()]
                num_wrong_options = 3
                
                wrong_options_list = []
                if len(all_other_words_in_class) >= num_wrong_options:
                    wrong_options_list = random.sample(all_other_words_in_class, num_wrong_options)
                else: 
                    wrong_options_list = all_other_words_in_class
                
                current_options_list_for_db = wrong_options_list + [original_word_text]
                random.shuffle(current_options_list_for_db)
                options_db = '|'.join(current_options_list_for_db)

            elif test_type == 'dictation':
                # Student hears/sees translation (prompt) and types the word (correct_answer).
                # `word` field can be empty or show underscores matching word length as a visual cue.
                current_word_for_test_word_model = ''.join(['_'] * len(original_word_text)) # Visual cue for length
                prompt_for_test_word_model = original_translation 
                correct_answer_for_db = original_word_text

            elif test_type == 'true_false':
                # The 'word' field will store the statement. Teacher needs UI to define statement & if T/F.
                # Placeholder: Assume statement is "Word - Translation" and it's True.
                # For custom words, teacher would input the statement and T/F.
                # This part requires significant teacher input for meaningful questions.
                if word_entry['source'] == 'custom': # Assume custom word text *is* the statement
                    current_word_for_test_word_model = original_word_text
                    # And custom translation *is* the True/False value
                    correct_answer_for_db = original_translation if original_translation.lower() in ['true', 'false'] else "True"
                else: # From module
                    # Determine if the statement should be true or false
                    if random.choice([True, False]):
                        # Make a true statement
                        current_word_for_test_word_model = f"{original_word_text} - {original_translation}"
                        correct_answer_for_db = "True"
                    else:
                        # Try to make a false statement
                        # Need to get current class and unit for the original_word_text to find distractors
                        # This assumes word_entry might have class/unit/module if it's from a module.
                        # If not, this part needs refinement on how to get context for distractors.
                        # For now, using the overall test's class_number.
                        # And assuming unit/module context might be in new_test_params if available,
                        # otherwise, this might be too broad or too narrow.

                        # Attempt to find a distractor translation from the same class.
                        # More specific (unit/module) would be better if that context is reliably available here.
                        distractor_words = Word.query.filter(
                            Word.classs == new_test_params.get('classs'),
                            Word.word != original_word_text # Exclude the original word itself
                        ).all()

                        if distractor_words:
                            distractor_word_obj = random.choice(distractor_words)
                            distractor_translation = distractor_word_obj.perevod

                            # Ensure the distractor translation isn't the same as the original,
                            # which could happen if different words have the same translation.
                            if distractor_translation != original_translation:
                                current_word_for_test_word_model = f"{original_word_text} - {distractor_translation}"
                                correct_answer_for_db = "False"
                            else:
                                # Fallback: if distractor is same as original, make it a true statement
                                current_word_for_test_word_model = f"{original_word_text} - {original_translation}"
                                correct_answer_for_db = "True"
                        else:
                            # Fallback: if no distractors found, make it a true statement
                            current_word_for_test_word_model = f"{original_word_text} - {original_translation}"
                            correct_answer_for_db = "True"
                
                prompt_for_test_word_model = "–í–µ—Ä–Ω–æ –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω–æ?" 
                options_db = "True|False"
                
            elif test_type == 'fill_word':
                # Student sees translation (word field) and needs to write the original word (correct_answer).
                current_word_for_test_word_model = original_translation # This is shown to the student as the question/prompt
                prompt_for_test_word_model = "–í–ø–∏—à–∏—Ç–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–µ —Å–ª–æ–≤–æ (–æ—Ä–∏–≥–∏–Ω–∞–ª):"
                correct_answer_for_db = original_word_text

            elif test_type == 'multiple_choice_multiple':
                # Question is the translation/prompt. Options are words. Multiple can be correct.
                # Teacher needs UI to select multiple correct answers. This is a complex setup.
                # Placeholder: Treat like single choice for now, teacher defines one correct answer.
                current_word_for_test_word_model = original_translation # Question: "Select all words that mean X"
                prompt_for_test_word_model = "–í—ã–±–µ—Ä–∏—Ç–µ –≤—Å–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã:"
                correct_answer_for_db = original_word_text # Placeholder: single correct answer.
                                                    # Real implementation: "ans1|ans2"
                
                all_other_words_in_class = [w.word for w in Word.query.filter(Word.classs == class_number, Word.word != original_word_text).all()]
                num_options_total = 4 
                
                # This logic is simplified; creating diverse and multiple correct options needs more.
                # For now, generate options similar to single choice.
                num_wrong_options_needed = num_options_total - 1 # Assuming 1 correct for now
                
                wrong_options_list = []
                if len(all_other_words_in_class) >= num_wrong_options_needed:
                    wrong_options_list = random.sample(all_other_words_in_class, num_wrong_options_needed)
                else:
                    wrong_options_list = all_other_words_in_class
                
                current_options_list_for_db = wrong_options_list + [original_word_text]
                # Fill with placeholders if not enough unique words
                while len(current_options_list_for_db) < num_options_total:
                    current_options_list_for_db.append(f"–í–∞—Ä–∏–∞–Ω—Ç {len(current_options_list_for_db)+1}")

                random.shuffle(current_options_list_for_db)
                options_db = '|'.join(current_options_list_for_db[:num_options_total])


            test_word_entry = TestWord(
                test_id=new_test.id,
                word=current_word_for_test_word_model,    # What the student sees as the question/task item
                perevod=prompt_for_test_word_model,       # Supporting info, like translation or detailed prompt
                correct_answer=correct_answer_for_db,
                options=options_db,
                missing_letters=missing_letters_positions_db,
                word_order=idx
            )
            db.session.add(test_word_entry)

        db.session.commit() # Commit TestWord entries. Test object (new_test) was committed earlier.

        # Use new_test.type and new_test.test_mode for the redirect condition
        if new_test.type == 'add_letter' and new_test.test_mode == 'manual_letters':
            flash("–¢–µ—Å—Ç —Å–æ–∑–¥–∞–Ω. –¢–µ–ø–µ—Ä—å —É–∫–∞–∂–∏—Ç–µ, –∫–∞–∫–∏–µ –±—É–∫–≤—ã –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –≤ —Å–ª–æ–≤–∞—Ö.", "info")
            return redirect(url_for('configure_test_words', test_id=new_test.id))
        else:
            flash("–¢–µ—Å—Ç —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω!", "success")
            return redirect(url_for('test_details', test_id=new_test.id))

    # GET request:
    user = User.query.get(session['user_id']) # Ensure user is fetched for GET request as well
    # Fetch available modules to populate the form (example, adjust as per actual logic)
    available_modules = {} # Replace with actual module fetching logic if needed for the GET request
    classes_get = [str(i) for i in range(1, 12)]
    
    # Pass any other necessary context for the template
    return render_template("create_test.html", user=user, classes=classes_get, available_modules=available_modules)

@app.route('/configure_test_words/<int:test_id>', methods=['GET', 'POST'])
def configure_test_words(test_id):
    if 'user_id' not in session:
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ.", "warning")
        return redirect(url_for('auth.login'))
    
    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –¢–æ–ª—å–∫–æ —É—á–∏—Ç–µ–ª—è –º–æ–≥—É—Ç –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞—Ç—å —Ç–µ—Å—Ç—ã.", "warning")
        return redirect(url_for('tests'))

    test = Test.query.get_or_404(test_id)
    
    if test.created_by != user.id:
        flash("–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —ç—Ç–æ—Ç —Ç–µ—Å—Ç, —Ç–∞–∫ –∫–∞–∫ –Ω–µ —è–≤–ª—è–µ—Ç–µ—Å—å –µ–≥–æ —Å–æ–∑–¥–∞—Ç–µ–ª–µ–º.", "danger")
        return redirect(url_for('tests'))

    if not (test.type == 'add_letter' and test.test_mode == 'manual_letters'):
        flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç –Ω–µ —Ç—Ä–µ–±—É–µ—Ç —Ä—É—á–Ω–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –±—É–∫–≤.", "info")
        return redirect(url_for('test_details', test_id=test.id))

    test_words_for_config = TestWord.query.filter_by(test_id=test.id).order_by(TestWord.word_order).all()

    if request.method == 'POST':
        try:
            for word_obj in test_words_for_config:
                # In the create_test step, word_obj.word stored the original_word_text
                original_word_text = word_obj.word 
                submitted_indices_str = request.form.get(f'word_{word_obj.id}_indices')

                if submitted_indices_str:
                    positions_zero_indexed = sorted(list(set(
                        [int(p.strip()) for p in submitted_indices_str.split(',') if p.strip().isdigit()]
                    )))
                    
                    valid_positions = [p for p in positions_zero_indexed if 0 <= p < len(original_word_text)]

                    if valid_positions:
                        actual_missing_letters_list = [original_word_text[pos] for pos in valid_positions]
                        word_obj.correct_answer = "".join(actual_missing_letters_list)
                        
                        word_with_gaps_list = list(original_word_text)
                        for pos in valid_positions:
                            word_with_gaps_list[pos] = '_'
                        # Update word_obj.word to store the word with gaps for student view
                        word_obj.word = "".join(word_with_gaps_list) 
                        word_obj.missing_letters = ','.join(str(pos + 1) for pos in valid_positions) # Store 1-indexed
                    else:
                        # No valid indices submitted (e.g., empty string or out-of-bound numbers)
                        word_obj.word = original_word_text # Keep original word (no gaps)
                        word_obj.correct_answer = ""       # No letters are missing
                        word_obj.missing_letters = None
                        if submitted_indices_str: # If teacher submitted something but it was invalid/empty after parsing
                             flash(f"–î–ª—è —Å–ª–æ–≤–∞ '{original_word_text}' –Ω–µ –±—ã–ª–∏ —É–∫–∞–∑–∞–Ω—ã –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –±—É–∫–≤ –∏–ª–∏ –æ–Ω–∏ –±—ã–ª–∏ –≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞. –ü—Ä–æ–ø—É—Å–∫–∏ –Ω–µ —Å–æ–∑–¥–∞–Ω—ã.", "warning")
                else:
                    # No indices submitted for this word at all, treat as "no letters hidden"
                    word_obj.word = original_word_text
                    word_obj.correct_answer = ""
                    word_obj.missing_letters = None
                    # Optional: flash message if you want to inform that a word was skipped
                    # flash(f"–î–ª—è —Å–ª–æ–≤–∞ '{original_word_text}' –Ω–µ —É–∫–∞–∑–∞–Ω—ã –±—É–∫–≤—ã –¥–ª—è –ø—Ä–æ–ø—É—Å–∫–∞. –°–ª–æ–≤–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π.", "info")
            
            db.session.commit()
            flash("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –±—É–∫–≤ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!", "success")
            return redirect(url_for('test_details', test_id=test.id))
        
        except ValueError as ve:
            db.session.rollback()
            flash(f"–û—à–∏–±–∫–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–æ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä–∞ –±—É–∫–≤ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é (–Ω–∞–ø—Ä–∏–º–µ—Ä, 0,2). {str(ve)}", "danger")
        except Exception as e:
            db.session.rollback()
            flash(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫: {str(e)}", "error")
            
    # GET request: fetch words and render the configuration template
    # Pre-calculate 0-indexed display strings for missing letter indices.
    for word_obj_from_db in test_words_for_config:
        display_indices_value = ""
        if word_obj_from_db.missing_letters:
            try:
                # missing_letters is 1-indexed from DB, e.g., "1,3,5"
                one_indexed_indices = [int(x.strip()) for x in word_obj_from_db.missing_letters.split(',') if x.strip().isdigit()]
                # Convert to 0-indexed for form display, e.g., "0,2,4"
                zero_indexed_indices = [str(idx - 1) for idx in one_indexed_indices if idx > 0] # ensure idx-1 is non-negative
                display_indices_value = ','.join(zero_indexed_indices)
            except ValueError:
                # If parsing fails (e.g., non-integer data), pass empty string.
                # Consider logging this case.
                display_indices_value = "" 
        
        # Dynamically add the pre-calculated string as an attribute to the object for easy template access
        setattr(word_obj_from_db, 'display_indices_for_form', display_indices_value)

    # Pass the (now modified with .display_indices_for_form) test_words_for_config to the template.
    return render_template('configure_test_words.html', test=test, test_words=test_words_for_config, user=user)

@app.route("/test/<int:test_id>")
def test_details(test_id):
    if 'user_id' not in session:
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user:
        session.pop('user_id', None)
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))

    test = Test.query.get_or_404(test_id)
    
    if user.teacher == 'yes':
        # Teacher's view: Gather student progress and render details page
        students_in_class = User.query.filter_by(class_number=test.classs, teacher='no').all()
        total_students_in_class = len(students_in_class)
        all_results_for_test = TestResult.query.filter(
            TestResult.test_id == test.id,
            TestResult.started_at >= test.created_at
        ).all()

        completed_students_details = []
        in_progress_students_details = []
        not_started_student_ids = {s.id for s in students_in_class}

        for result in all_results_for_test:
            student_user = User.query.get(result.user_id)
            if not student_user or student_user.teacher == 'yes': # Skip non-students or if user somehow deleted
                if student_user and result.user_id in not_started_student_ids:
                    not_started_student_ids.remove(result.user_id)
                continue

            if result.user_id in not_started_student_ids:
                not_started_student_ids.remove(result.user_id)
            
            if result.completed_at:
                completed_students_details.append({'user': student_user, 'result': result})
            else:
                item_data_for_template = {
                    'user': student_user,
                    'result': result,
                    'remaining_time_display': "–ë–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π",
                    'has_time_limit': False,
                    'end_time_utc_iso': None
                }
                if test.time_limit and test.time_limit > 0:
                    end_time_utc = result.started_at + timedelta(minutes=test.time_limit)
                    now_utc = datetime.utcnow()
                    item_data_for_template['has_time_limit'] = True
                    item_data_for_template['end_time_utc_iso'] = end_time_utc.isoformat() + "Z"
                    if now_utc < end_time_utc:
                        remaining_delta = end_time_utc - now_utc
                        hours, remainder = divmod(remaining_delta.total_seconds(), 3600)
                        minutes, seconds_float = divmod(remainder, 60)
                        seconds = int(seconds_float)
                        if hours > 0:
                            item_data_for_template['remaining_time_display'] = f"{int(hours)}h {int(minutes)}m {seconds}s left"
                        else:
                            item_data_for_template['remaining_time_display'] = f"{int(minutes)}m {seconds}s left"
                    else:
                        item_data_for_template['remaining_time_display'] = "–í—Ä–µ–º—è –≤—ã—à–ª–æ"
                in_progress_students_details.append(item_data_for_template)

        not_started_students = [User.query.get(uid) for uid in not_started_student_ids]
        not_started_students = [s for s in not_started_students if s] 
        
        completed_count = len(completed_students_details)
        progress_percentage = (completed_count / total_students_in_class * 100) if total_students_in_class > 0 else 0

        return render_template('test_details.html',
                             test=test,
                             total_students_in_class=total_students_in_class,
                             completed_students_details=completed_students_details,
                             in_progress_students_details=in_progress_students_details,
                             not_started_students=not_started_students,
                             progress_percentage=progress_percentage,
                             is_teacher=True) # Ensure is_teacher is passed
    
    # --- STUDENT PATH --- (if user.teacher == 'no')
    else:
        student_completed_result = TestResult.query.filter_by(
            test_id=test.id,
            user_id=user.id
        ).filter(TestResult.completed_at.isnot(None)).order_by(TestResult.completed_at.desc()).first()

        if not test.is_active: # Test is ARCHIVED
            if student_completed_result:
                flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –∞—Ä—Ö–∏–≤–µ. –ü—Ä–æ—Å–º–æ—Ç—Ä –≤–∞—à–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.", "info")
                return redirect(url_for('test_results', test_id=test.id, result_id=student_completed_result.id))
            else:
                flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –∞—Ä—Ö–∏–≤–µ, –∏ –≤—ã –µ–≥–æ –Ω–µ –ø—Ä–æ—Ö–æ–¥–∏–ª–∏.", "warning")
                return redirect(url_for('tests'))
        else: # Test is ACTIVE
            if student_completed_result:
                flash("–í—ã —É–∂–µ –∑–∞–≤–µ—Ä—à–∏–ª–∏ —ç—Ç–æ—Ç —Ç–µ—Å—Ç. –ü—Ä–æ—Å–º–æ—Ç—Ä –≤–∞—à–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.", "info")
                return redirect(url_for('test_results', test_id=test.id, result_id=student_completed_result.id))
            else:
                # If active and not completed (or no result at all), student should be able to take it.
                return redirect(url_for('take_test', test_link=test.link))
    
    # Fallback for any unhandled student cases, though the logic above should cover students.
    # This line should ideally not be reached if student logic is complete.
    flash("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å –¥–µ—Ç–∞–ª–∏ —Ç–µ—Å—Ç–∞ –¥–ª—è –≤–∞—à–µ–≥–æ —Å—Ç–∞—Ç—É—Å–∞.", "warning")
    return redirect(url_for('tests'))

@app.route("/test/<int:test_id>/archive", methods=['POST'])
def archive_test(test_id):
    if 'user_id' not in session:
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –∫–∞–∫ —É—á–∏—Ç–µ–ª—å.", "warning")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        flash("–¢–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–µ—Å—Ç–∞ –º–æ–∂–µ—Ç –µ–≥–æ –∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞—Ç—å.", "warning")
        if not user: session.pop('user_id', None)
        return redirect(url_for('tests')) # Or back to test_details

    test = Test.query.get_or_404(test_id)
    if test.created_by != user.id:
        return redirect('/tests', 302)

    test.is_active = False
    db.session.commit()
    return redirect(url_for('test_details', test_id=test_id))

@app.route("/test/<int:test_id>/unarchive", methods=['POST'])
def unarchive_test(test_id):
    if 'user_id' not in session:
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –∫–∞–∫ —É—á–∏—Ç–µ–ª—å.", "warning")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        flash("–¢–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–µ—Å—Ç–∞ –º–æ–∂–µ—Ç –µ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏–∑ –∞—Ä—Ö–∏–≤–∞.", "warning")
        if not user: session.pop('user_id', None)
        return redirect(url_for('tests'))

    test = Test.query.get_or_404(test_id)
    if test.created_by != user.id:
        flash("–¢–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–µ—Å—Ç–∞ –º–æ–∂–µ—Ç –µ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å.", "warning")
        return redirect(url_for('test_details', test_id=test_id))

    test.is_active = True
    db.session.commit()
    flash(f"–¢–µ—Å—Ç '{test.title}' —É—Å–ø–µ—à–Ω–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–∑ –∞—Ä—Ö–∏–≤–∞.", "success")
    return redirect(url_for('test_details', test_id=test_id))

@app.route("/test/<int:test_id>/clear_results", methods=['POST'])
def clear_test_results(test_id):
    if 'user_id' not in session:
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –∫–∞–∫ —É—á–∏—Ç–µ–ª—å.", "warning")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        flash("–¢–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–µ—Å—Ç–∞ –º–æ–∂–µ—Ç –æ—á–∏—Å—Ç–∏—Ç—å –µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã.", "warning")
        if not user: session.pop('user_id', None)
        return redirect(url_for('tests')) # Or back to test_details

    test = Test.query.get_or_404(test_id)
    if test.created_by != user.id:
        flash("–¢–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–µ—Å—Ç–∞ –º–æ–∂–µ—Ç –æ—á–∏—Å—Ç–∏—Ç—å –µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã.", "warning")
        return redirect(url_for('test_details', test_id=test_id))

    results_to_delete = TestResult.query.filter_by(test_id=test.id).all()
    
    if not results_to_delete:
        flash(f"–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –¥–ª—è —Ç–µ—Å—Ç–∞ '{test.title}'.", "info")
        return redirect(url_for('test_details', test_id=test_id))

    try:
        for result in results_to_delete:
            # Explicitly delete TestAnswer objects associated with this result
            TestAnswer.query.filter_by(test_result_id=result.id).delete(synchronize_session=False)
            # Now delete the TestResult object
            db.session.delete(result)
        
        db.session.commit()
        flash(f"–í—Å–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è —Ç–µ—Å—Ç–∞ '{test.title}' –±—ã–ª–∏ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω—ã.", "success")
    except Exception as e:
        db.session.rollback()
        flash(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ç–µ—Å—Ç–∞: {str(e)}", "error")
        # app.logger.error(f"Error clearing test results for test_id {test_id}: {e}") # Requires app.logger to be configured
        print(f"Error clearing test results for test_id {test_id}: {e}") # simple print for now

    return redirect(url_for('test_details', test_id=test_id))

@app.route("/test/<int:test_id>/delete", methods=['POST'])
def delete_test_completely(test_id):
    if 'user_id' not in session:
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –∫–∞–∫ —É—á–∏—Ç–µ–ª—å.", "warning")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        flash("–¢–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–µ—Å—Ç–∞ –º–æ–∂–µ—Ç –µ–≥–æ —É–¥–∞–ª–∏—Ç—å.", "warning")
        if not user: session.pop('user_id', None)
        return redirect(url_for('tests'))

    test_to_delete = Test.query.get_or_404(test_id)
    if test_to_delete.created_by != user.id:
        flash("–¢–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–µ—Å—Ç–∞ –º–æ–∂–µ—Ç –µ–≥–æ —É–¥–∞–ª–∏—Ç—å.", "warning")
        return redirect(url_for('test_details', test_id=test_id))

    try:
        # Delete associated TestAnswer entries
        TestAnswer.query.filter(TestAnswer.test_result_id.in_(db.session.query(TestResult.id).filter_by(test_id=test_id))).delete(synchronize_session=False)
        # Delete associated TestResult entries
        TestResult.query.filter_by(test_id=test_id).delete(synchronize_session=False)
        # Delete associated TestWord entries
        TestWord.query.filter_by(test_id=test_id).delete(synchronize_session=False)
        
        db.session.delete(test_to_delete)
        db.session.commit()
        flash(f"–¢–µ—Å—Ç '{test_to_delete.title}' –∏ –≤—Å–µ —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å –Ω–∏–º –¥–∞–Ω–Ω—ã–µ –±—ã–ª–∏ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω—ã.", "success")
        return redirect(url_for('tests'))
    except Exception as e:
        db.session.rollback()
        flash(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ç–µ—Å—Ç–∞: {str(e)}", "error")
        return redirect(url_for('test_details', test_id=test_id))

@app.route('/take_test/<test_link>', methods=['GET', 'POST'])
def take_test(test_link):
    if 'user_id' not in session:
        flash("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –≤ —Å–∏—Å—Ç–µ–º—É, —á—Ç–æ–±—ã –ø—Ä–æ–π—Ç–∏ —Ç–µ—Å—Ç.", "error")
        return redirect(url_for('auth.login'))

    current_user = User.query.get(session['user_id'])
    if not current_user:
        session.pop('user_id', None)
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))
    
    test = Test.query.filter_by(link=test_link).first_or_404()

    # –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–µ—Å—Å–∏–∏
    print(f"DEBUG: Session data at take_test start: {dict(session)}")
    print(f"DEBUG: Current user: {current_user.nick}, ID: {current_user.id}")
    print(f"DEBUG: Test ID: {test.id}, Test Link: {test.link}")

    # Check if student belongs to the correct class for the test
    if current_user.teacher == 'no' and test.classs != current_user.class_number:
        flash("–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –ø—Ä–æ–π—Ç–∏ —ç—Ç–æ—Ç —Ç–µ—Å—Ç, —Ç–∞–∫ –∫–∞–∫ –æ–Ω –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –¥—Ä—É–≥–æ–≥–æ –∫–ª–∞—Å—Å–∞.", "error")
        return redirect(url_for('tests'))

    # Check if the test is active (students cannot take archived tests)
    # Teachers can preview archived tests they created (handled in test_id route)
    if current_user.teacher == 'no' and not test.is_active:
        flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç –±–æ–ª—å—à–µ –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω –∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–æ–π–¥–µ–Ω.", "error")
        return redirect(url_for('tests'))

    # POST request: Starting the test
    if request.method == 'POST':
        if current_user.teacher == 'yes':
            # Teachers starting a test go directly to preview mode via test_id route
            # No TestResult is created for them.
            flash("–ù–∞—á–∞—Ç –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —Ç–µ—Å—Ç–∞.", "info")
            # –Ø–≤–Ω–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–µ—Å—Å–∏—é –¥–ª—è —É—á–∏—Ç–µ–ª—è
            session['is_teacher_preview'] = True
            session['test_link'] = test.link
            session.modified = True
            print(f"DEBUG: Teacher preview mode activated, session: {dict(session)}")
            return jsonify({'success': True, 'redirect_url': '/test/' + test.link})

        # --- STUDENT LOGIC FOR POST (starting a test) ---
        if test.classs != current_user.class_number:
            flash("–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –Ω–∞—á–∞—Ç—å —ç—Ç–æ—Ç —Ç–µ—Å—Ç, —Ç–∞–∫ –∫–∞–∫ –æ–Ω –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –¥—Ä—É–≥–æ–≥–æ –∫–ª–∞—Å—Å–∞.", "error")
            return jsonify({'success': False, 'error': '–ö–ª–∞—Å—Å –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç', 'redirect_url': url_for('tests')}), 403
        if not test.is_active:
            flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç –±–æ–ª—å—à–µ –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω –∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–∞—á–∞—Ç.", "error")
            return jsonify({'success': False, 'error': '–¢–µ—Å—Ç –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω', 'redirect_url': url_for('tests')}), 403

        # Check for existing incomplete result for student
        existing_incomplete_result = TestResult.query.filter_by(
            test_id=test.id,
            user_id=current_user.id,
            completed_at=None
        ).first()

        if existing_incomplete_result:
            # If student already has an incomplete test, use that one
            session['active_test_result_id'] = existing_incomplete_result.id
            session['test_link'] = test.link
            # –Ø–≤–Ω–æ –ø–æ–º–µ—á–∞–µ–º —Å–µ—Å—Å–∏—é –∫–∞–∫ –∏–∑–º–µ–Ω–µ–Ω–Ω—É—é
            session.modified = True
            print(f"DEBUG: Using existing test result, ID: {existing_incomplete_result.id}, session: {dict(session)}")
            
            # –í–º–µ—Å—Ç–æ JSON-–æ—Ç–≤–µ—Ç–∞ –¥–µ–ª–∞–µ–º –ø—Ä—è–º–æ–π —Ä–µ–¥–∏—Ä–µ–∫—Ç
            resp = make_response(redirect('/test/' + test.link))
            resp.set_cookie('active_test_result_id', str(existing_incomplete_result.id))
            resp.set_cookie('test_link', test.link)
            return resp
        else:
            # If no incomplete test, check if they completed it before.
            # Depending on policy, you might prevent retakes or allow new attempts.
            # For now, let's allow a new attempt if previous was completed or none exists.
            
            # Create a new TestResult for the student
            new_test_result = TestResult(
                test_id=test.id,
                user_id=current_user.id,
                total_questions=len(test.test_words) if test.test_words else 0,
                started_at=datetime.utcnow()
            )
            db.session.add(new_test_result)
            db.session.commit()
            
            session['active_test_result_id'] = new_test_result.id
            session['test_link'] = test.link
            # –Ø–≤–Ω–æ –ø–æ–º–µ—á–∞–µ–º —Å–µ—Å—Å–∏—é –∫–∞–∫ –∏–∑–º–µ–Ω–µ–Ω–Ω—É—é
            session.modified = True
            print(f"DEBUG: Created new test result, ID: {new_test_result.id}, session: {dict(session)}")
            
            # –í–º–µ—Å—Ç–æ JSON-–æ—Ç–≤–µ—Ç–∞ –¥–µ–ª–∞–µ–º –ø—Ä—è–º–æ–π —Ä–µ–¥–∏—Ä–µ–∫—Ç
            resp = make_response(redirect('/test/' + test.link))
            resp.set_cookie('active_test_result_id', str(new_test_result.id))
            resp.set_cookie('test_link', test.link)
            return resp

    # GET request logic:
    if current_user.teacher == 'yes':
        # Teachers see the start page, clicking "Start" will POST and then redirect to preview
        return render_template('test_start.html', test=test, user=current_user)
        
    # --- STUDENT LOGIC FOR GET ---
    # If there's an existing incomplete test result, student should resume it.
    incomplete_result = TestResult.query.filter_by(
        test_id=test.id,
        user_id=current_user.id,
        completed_at=None
    ).first()

    if incomplete_result:
        # If student has an incomplete test, take them directly to it to resume
        session['active_test_result_id'] = incomplete_result.id
        session['test_link'] = test.link
        # –Ø–≤–Ω–æ –ø–æ–º–µ—á–∞–µ–º —Å–µ—Å—Å–∏—é –∫–∞–∫ –∏–∑–º–µ–Ω–µ–Ω–Ω—É—é
        session.modified = True
        print(f"DEBUG: Resuming incomplete test, ID: {incomplete_result.id}, session: {dict(session)}")
        # Redirect to the test interface itself (test_id handles rendering based on type)
        resp = make_response(redirect('/test/' + test.link))
        resp.set_cookie('active_test_result_id', str(incomplete_result.id))
        resp.set_cookie('test_link', test.link)
        return resp

    # If test is completed, show link to results or message
    completed_result = TestResult.query.filter(
        TestResult.test_id == test.id,
        TestResult.user_id == current_user.id,
        TestResult.completed_at.isnot(None)
    ).order_by(TestResult.completed_at.desc()).first()

    if completed_result:
        flash("–í—ã —É–∂–µ –∑–∞–≤–µ—Ä—à–∏–ª–∏ —ç—Ç–æ—Ç —Ç–µ—Å—Ç. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ —Å–≤–æ–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã.", "info")
        return redirect(url_for('test_results', test_id=test.id, result_id=completed_result.id))

    # Otherwise, show the test start page (if it's a GET request and no active/completed test for this user)
    return render_template('test_start.html', test=test, user=current_user)

@app.route('/submit_test/<int:test_id>', methods=['POST'])
def submit_test(test_id):
    if 'user_id' not in session:
        # For form submissions, redirect is more appropriate than JSON error
        flash("–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –Ω–µ –ø—Ä–æ–π–¥–µ–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user:
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))

    test = Test.query.get_or_404(test_id)
    active_test_result = TestResult.query.filter_by(
        test_id=test.id,
        user_id=user.id,
        completed_at=None
    ).first()

    if not active_test_result:
        # This might happen if user tries to submit to a test they haven't started
        # or if they refresh the submit page after already submitting.
        # Check if a completed result exists to redirect to results page.
        completed_result = TestResult.query.filter_by(
            test_id=test.id,
            user_id=user.id
        ).filter(TestResult.completed_at.isnot(None)).order_by(TestResult.completed_at.desc()).first()
        if completed_result:
            flash("–í—ã —É–∂–µ –∑–∞–≤–µ—Ä—à–∏–ª–∏ —ç—Ç–æ—Ç —Ç–µ—Å—Ç.", "info")
            return redirect(url_for('test_results', test_id=test.id, result_id=completed_result.id))
        else:
            flash("–ù–µ –Ω–∞–π–¥–µ–Ω–æ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è —Ç–µ—Å—Ç–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ —Ç–µ—Å—Ç.", "warning")
            return redirect(url_for('take_test', test_link=test.link)) # Or to tests list

    # Server-side time limit check before processing answers
    if test.time_limit and test.time_limit > 0 and active_test_result.started_at:
        allowed_duration = timedelta(minutes=test.time_limit)
        # Add a small grace period (e.g., 5-10 seconds) to account for submission latency
        grace_period = timedelta(seconds=10)
        actual_time_limit_on_server = active_test_result.started_at + allowed_duration + grace_period
        
        if datetime.utcnow() > actual_time_limit_on_server:
            # Time is definitively up on the server
            flash("–í—Ä–µ–º—è –Ω–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–µ—Å—Ç–∞ –∏—Å—Ç–µ–∫–ª–æ. –û—Ç–≤–µ—Ç—ã, –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –ø–æ—Å–ª–µ –∏—Å—Ç–µ—á–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏, –Ω–µ –∑–∞—Å—á–∏—Ç–∞–Ω—ã.", "error")
            
            if not active_test_result.completed_at: # Ensure we only complete it once
                active_test_result.completed_at = active_test_result.started_at + allowed_duration # Mark completion at the exact intended end time
                # Calculate time taken for timeout case (should be exactly the time limit)
                if active_test_result.started_at:
                    active_test_result.time_taken = test.time_limit  # Time limit in minutes
                else:
                    active_test_result.time_taken = 0
                # Optionally, set score to 0 if no answers are accepted post-deadline
                # This depends on whether partial/in-time answers were already saved progressively.
                # For the current setup, it implies answers submitted with this request are too late.
                # If you want to be very strict and not rely on progressively saved state (which isn't fully there for add_letter):
                # active_test_result.score = 0
                # active_test_result.correct_answers = 0
                # active_test_result.answers = json.dumps({}) # Clear any answers if submission is void
                # However, if the client *did* submit something just before this server check, 
                # but the check still determines it's too late, those answers won't be processed by the code below.
                # The most straightforward for now is to ensure it's marked completed and then redirect.
                # The scoring logic below will not run if we redirect here.
                
            db.session.commit()
            return redirect(url_for('test_results', test_id=test.id, result_id=active_test_result.id))

    # data = request.get_json() # Changed to use request.form for standard HTML form submission
    submitted_answers_map = {}
    if test.type == 'add_letter':
        # For add_letter, reconstruct answers from individual input boxes
        # Inputs are named like: answer_{test_word.id}_{input_index_in_word}
        for key, value in request.form.items():
            if key.startswith('answer_'):
                parts = key.split('_')
                if len(parts) == 3:
                    try:
                        word_id = int(parts[1])
                        input_idx = int(parts[2])
                        if word_id not in submitted_answers_map:
                            submitted_answers_map[word_id] = {}
                        submitted_answers_map[word_id][input_idx] = value.strip()
                    except ValueError:
                        # Handle cases where parsing fails, though names should be controlled
                        print(f"Warning: Could not parse form key {key}")
                        pass # Or log an error
    # else: # For other test types, if they were using AJAX and data.get('answers', [])
        # This part would need to be adapted if other test types also switch to form submission
        # For now, let's assume other test types might still send answers differently or need updates
        # If they also submit via form with a simple list-like structure for answers (e.g. answer_0, answer_1):
        # pass # Or retrieve their answers based on their specific form field naming
        # If other tests also submit via form, they might name fields like `answer_{test_word.id}` directly.
        # For now, this path is not fully handled for non-add_letter types if they stop using JSON.
        pass

    # Calculate score based on test type
    current_score_count = 0
    detailed_results_for_db = [] # To store TestAnswer objects
    total_questions = len(test.test_words)
    answers_json_for_db = {} # To store in TestResult.answers (JSON)

    # Ensure test words are ordered by their defined word_order for consistent processing
    ordered_test_words = sorted(test.test_words, key=lambda tw: tw.word_order)

    for test_word in ordered_test_words:
        user_submitted_answer_string = ""
        is_correct = False

        if test.type == 'add_letter':
            if test_word.id in submitted_answers_map:
                # Reconstruct the answer from sorted input characters
                answer_chars = []
                sorted_inputs = sorted(submitted_answers_map[test_word.id].items())
                for _, char_val in sorted_inputs:
                    answer_chars.append(char_val)
                user_submitted_answer_string = "".join(answer_chars)
            # For add_letter, TestWord.correct_answer stores the combined missing letters
            is_correct = user_submitted_answer_string.lower() == test_word.correct_answer.lower()
        
        elif test.type == 'multiple_choice_multiple':
            user_selected_options = sorted(request.form.getlist(f'answer_{test_word.id}'))
            user_submitted_answer_string = "|".join(user_selected_options)

            correct_options_list = sorted(test_word.correct_answer.split('|'))
            actual_correct_string_for_comparison = "|".join(correct_options_list)

            is_correct = user_submitted_answer_string.lower() == actual_correct_string_for_comparison.lower()

        elif test.type == 'multiple_choice_single':
            user_submitted_answer_string = request.form.get(f'answer_{test_word.id}', '').strip()
            is_correct = user_submitted_answer_string.lower() == test_word.correct_answer.lower()
        elif test.type == 'dictation':
            current_word_chars_map = {}
            # Collect all characters for this specific test_word.id
            # Key format: dictation_answer_{test_word.id}_{char_index}
            prefix = f'dictation_answer_{test_word.id}_'
            for key, value in request.form.items():
                if key.startswith(prefix):
                    try:
                        char_idx_str = key[len(prefix):] # Get the part after the prefix
                        char_idx = int(char_idx_str)
                        
                        # Ensure value is a single character, take the first if multiple submitted
                        # maxlength=1 on client side should prevent multiple.
                        char_value = value.strip()
                        if len(char_value) > 1:
                            char_value = char_value[0]
                        # If char_value is empty, it represents an empty box for that position.
                        
                        current_word_chars_map[char_idx] = char_value
                    except ValueError:
                        # Log or handle malformed key if char_idx_str is not an int
                        print(f"Warning: Could not parse char index from key {key} for dictation word {test_word.id}")
                        pass # Ignore malformed keys
            
            answer_chars = []
            if current_word_chars_map:
                # Reconstruct the word by sorting characters by their index.
                # Iterate from 0 up to the maximum index found for this word.
                max_idx_found = -1
                if current_word_chars_map: # Ensure not empty before calling max
                    max_idx_found = max(current_word_chars_map.keys())
                
                for i in range(max_idx_found + 1):
                    answer_chars.append(current_word_chars_map.get(i, "")) # Append char or empty string if index is missing
            
            user_submitted_answer_string = "".join(answer_chars)
            
            # Normalize answers for comparison in dictation
            normalized_user_answer = re.sub(r'[\s\.,!?-]', '', user_submitted_answer_string).lower()
            normalized_correct_answer = re.sub(r'[\s\.,!?-]', '', test_word.correct_answer).lower()
            is_correct = normalized_user_answer == normalized_correct_answer
        elif test.type == 'true_false': # Example
            user_submitted_answer_string = request.form.get(f'answer_{test_word.id}', '').strip()
            is_correct = user_submitted_answer_string.capitalize() == test_word.correct_answer # True/False comparison
        else: # Fallback for other types or if logic is missing
            user_submitted_answer_string = request.form.get(f'answer_{test_word.id}', '').strip()
            is_correct = user_submitted_answer_string.lower() == test_word.correct_answer.lower()
        
        if is_correct:
            current_score_count += 1
        
        answers_json_for_db[str(test_word.id)] = user_submitted_answer_string
        detailed_results_for_db.append({
            'test_word_id': test_word.id,
            'user_answer': user_submitted_answer_string,
            'is_correct': is_correct
        })

    # Update active_test_result
    active_test_result.score = int((current_score_count / total_questions) * 100) if total_questions > 0 else 0
    active_test_result.correct_answers = current_score_count
    active_test_result.total_questions = total_questions # Should already be set at start, but good to confirm
    completion_time = datetime.utcnow()
    active_test_result.completed_at = completion_time
    
    # Calculate time taken in minutes (safe calculation)
    if active_test_result.started_at:
        time_diff = completion_time - active_test_result.started_at
        active_test_result.time_taken = max(0, int(time_diff.total_seconds() / 60))  # Convert to minutes, ensure non-negative
    else:
        active_test_result.time_taken = 0  # Fallback if started_at is missing
        
    active_test_result.answers = json.dumps(answers_json_for_db)
    
    # Add TestAnswer instances
    for ans_data in detailed_results_for_db:
        test_answer_entry = TestAnswer(
            test_result_id=active_test_result.id,
            test_word_id=ans_data['test_word_id'],
            user_answer=ans_data['user_answer'],
            is_correct=ans_data['is_correct']
        )
        db.session.add(test_answer_entry)

    try:
        db.session.commit()
        flash("–¢–µ—Å—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω!", "success")
        return redirect(url_for('test_results', test_id=test.id, result_id=active_test_result.id))
    except Exception as e:
        db.session.rollback()
        flash(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ç–µ—Å—Ç–∞: {str(e)}", "error")
        # Redirect back to the test page, or a general error page
        return redirect(url_for('take_test', test_link=test.link))

@app.route('/test_results/<int:test_id>/<int:result_id>')
def test_results(test_id, result_id):
    if 'user_id' not in session:
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user:
        session.pop('user_id', None)
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))

    test = Test.query.get_or_404(test_id)
    result = TestResult.query.get_or_404(result_id)

    # Verify access to results
    can_view_results = False
    if result.user_id == user.id: # Student viewing their own results
        can_view_results = True
    elif user.teacher == 'yes' and test.created_by == user.id: # Teacher viewing results of a test they created
        can_view_results = True

    if not can_view_results:
        flash("–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —ç—Ç–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.", "warning")
        return redirect(url_for('tests'))

    # Determine if detailed results should be shown
    show_detailed_results = False  # Default to False
    if user.teacher == 'yes' and test.created_by == user.id:
        # Teacher can always see detailed results for tests they created
        show_detailed_results = True
    elif result.user_id == user.id:  # It's a student viewing their own results
        if not test.is_active:  # Student can see details ONLY if the test is archived
            show_detailed_results = True
        # If the test is active, show_detailed_results remains False for the student

    # Get detailed results if allowed
    detailed_answers = [] 
    if show_detailed_results: # Only fetch if we are going to show them
        for answer_obj in result.test_answers: # answer_obj is a TestAnswer instance
            test_word_instance = answer_obj.test_word # This is the TestWord instance
            
            detailed_answers_item = {
                'user_answer': answer_obj.user_answer,
                'actual_correct_answer': test_word_instance.correct_answer,
                'is_correct': answer_obj.is_correct,
                'options': test_word_instance.options,
                # Initialize parts for add_letter, will be populated below
                'student_reconstructed_parts': None,
                'correct_reconstructed_parts': None
            }

            if test.type == 'add_letter':
                detailed_answers_item['question_presented'] = test_word_instance.word 
                detailed_answers_item['prompt_or_support'] = test_word_instance.perevod

                # Reconstruct student's attempt
                student_parts = []
                gapped_template = test_word_instance.word
                student_letters = list(answer_obj.user_answer)
                s_idx = 0
                correct_letters_iter_for_student = iter(test_word_instance.correct_answer)
                for char_template in gapped_template:
                    part_info = {'char': char_template, 'is_student_input': False, 'is_correct_char': None}
                    if char_template == '_':
                        if s_idx < len(student_letters):
                            part_info['char'] = student_letters[s_idx]
                            part_info['is_student_input'] = True
                            try:
                                correct_char_for_gap = next(correct_letters_iter_for_student)
                                if student_letters[s_idx].lower() == correct_char_for_gap.lower():
                                    part_info['is_correct_char'] = True
                                else:
                                    part_info['is_correct_char'] = False
                            except StopIteration: # More student letters than correct gaps implies mismatch
                                part_info['is_correct_char'] = False
                            s_idx += 1
                        else: # Not enough student letters for this gap
                            part_info['char'] = '_' 
                            part_info['is_student_input'] = True # It was a gap student should have filled
                            part_info['is_correct_char'] = False # Mark as incorrect as it's unfilled
                    student_parts.append(part_info)
                detailed_answers_item['student_reconstructed_parts'] = student_parts

                # Reconstruct correct word display
                correct_parts = []
                correct_letters = list(test_word_instance.correct_answer)
                c_idx = 0
                for char_template in gapped_template:
                    part_info = {'char': char_template, 'is_student_input': False}
                    if char_template == '_':
                        if c_idx < len(correct_letters):
                            part_info['char'] = correct_letters[c_idx]
                            part_info['is_student_input'] = True # It's a filled gap
                            c_idx += 1
                        else:
                            part_info['char'] = '_' # Should not happen if data is consistent
                    correct_parts.append(part_info)
                detailed_answers_item['correct_reconstructed_parts'] = correct_parts
            
            elif test.type == 'multiple_choice_single' or test.type == 'multiple_choice_multiple':
                detailed_answers_item['question_presented'] = test_word_instance.perevod
                detailed_answers_item['prompt_or_support'] = test_word_instance.word
            elif test.type == 'fill_word':
                detailed_answers_item['question_presented'] = test_word_instance.word
                detailed_answers_item['prompt_or_support'] = test_word_instance.perevod
            elif test.type == 'true_false':
                detailed_answers_item['question_presented'] = test_word_instance.word
                detailed_answers_item['prompt_or_support'] = test_word_instance.perevod
            else: # Default for dictation etc.
                detailed_answers_item['question_presented'] = test_word_instance.word 
                detailed_answers_item['prompt_or_support'] = test_word_instance.perevod

            detailed_answers.append(detailed_answers_item)

    # Format time taken for display
    time_taken_display = format_time_taken(result.time_taken)
    
    return render_template('test_results.html',
        test=test,
        score=result.score,
        correct_answers=result.correct_answers,
        total_questions=result.total_questions,
        time_taken=time_taken_display,
        time_taken_raw=result.time_taken,  # Raw minutes for any calculations
        incorrect_answers=result.total_questions - result.correct_answers,
        results_summary=detailed_answers, # Changed variable name passed to template
        show_detailed_results=show_detailed_results
    )

@app.route("/games")
def games():
    if 'user_id' not in session:
        return redirect(url_for('auth.login'))
    
    user = User.query.get(session['user_id'])
    if not user:
        session.pop('user_id', None)
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))
        
    return render_template('games.html', is_teacher=user.teacher == 'yes')

# flashcards_select_module and flashcards_game will be moved to games_bp

@app.route('/games/flashcards/select', methods=['GET'])
def flashcards_select_module():
    if 'user_id' not in session:
        return redirect(url_for('auth.login')) # Corrected url_for
    # Fetch all unique classes for the first dropdown
    classes = db.session.query(Word.classs).distinct().order_by(Word.classs).all()
    classes = [c[0] for c in classes if c[0]] # Ensure not None or empty
    return render_template('game_flashcards_select_improved.html', classes=classes)

@app.route('/games/flashcards/<class_name>/<unit_name>/<module_name>')
@app.route('/games/flashcards/<class_name>/<unit_name>')
@app.route('/games/flashcards/<class_name>')
def flashcards_game(class_name, unit_name=None, module_name=None):
    if 'user_id' not in session:
        flash("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –≤ —Å–∏—Å—Ç–µ–º—É –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ–ª—ç—à-–∫–∞—Ä—Ç–æ—á–∫–∞–º.", "warning")
        return redirect(url_for('auth.login'))

    user_id = session['user_id']
    
    # –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–≥—Ä—ã –∏–∑ URL
    mode = request.args.get('mode', 'specific')
    cards_count = int(request.args.get('cards', 0))  # 0 –æ–∑–Ω–∞—á–∞–µ—Ç –≤—Å–µ –∫–∞—Ä—Ç–æ—á–∫–∏
    selected_modules = request.args.get('modules', '').split(',') if request.args.get('modules') else []
    selected_units = request.args.get('units', '').split(',') if request.args.get('units') else []
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞–∫–∏–µ —Å–ª–æ–≤–∞ –∑–∞–≥—Ä—É–∂–∞—Ç—å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞
    words_in_module = []
    
    if mode == 'specific' and unit_name and module_name:
        # –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –º–æ–¥—É–ª—å
        words_in_module = Word.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name}, –ú–æ–¥—É–ª—å: {module_name}"
    elif mode == 'unit' and unit_name:
        # –í–µ—Å—å —é–Ω–∏—Ç
        words_in_module = Word.query.filter_by(classs=class_name, unit=unit_name).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name} (–≤—Å–µ –º–æ–¥—É–ª–∏)"
    elif mode == 'class':
        # –í–µ—Å—å –∫–ª–∞—Å—Å
        words_in_module = Word.query.filter_by(classs=class_name).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name} (–≤—Å–µ —é–Ω–∏—Ç—ã –∏ –º–æ–¥—É–ª–∏)"
    elif mode == 'multiple-modules' and unit_name and selected_modules:
        # –ù–µ—Å–∫–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –º–æ–¥—É–ª–µ–π
        words_in_module = Word.query.filter(
            Word.classs == class_name,
            Word.unit == unit_name,
            Word.module.in_(selected_modules)
        ).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name}, –ú–æ–¥—É–ª–∏: {', '.join(selected_modules)}"
    elif mode == 'multiple-units' and selected_units:
        # –ù–µ—Å–∫–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —é–Ω–∏—Ç–æ–≤
        words_in_module = Word.query.filter(
            Word.classs == class_name,
            Word.unit.in_(selected_units)
        ).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç—ã: {', '.join(selected_units)}"
    else:
        # Fallback –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –º–æ–¥—É–ª—é
        if unit_name and module_name:
            words_in_module = Word.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()
            display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name}, –ú–æ–¥—É–ª—å: {module_name}"
        else:
            flash("–ù–µ–≤–µ—Ä–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–≥—Ä—ã.", "warning")
            return redirect(url_for('flashcards_select_module'))

    if not words_in_module:
        flash(f"–î–ª—è –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ —Å–ª–æ–≤.", "warning")
        return redirect(url_for('flashcards_select_module'))

    augmented_words_list = []
    now = datetime.utcnow()

    for word_obj in words_in_module:
        review_data = UserWordReview.query.filter_by(user_id=user_id, word_id=word_obj.id).first()

        is_new = review_data is None
        next_review_at_iso = None
        interval = None

        if review_data:
            next_review_at_iso = review_data.next_review_at.isoformat()
            interval = review_data.interval_days
            is_due = review_data.next_review_at <= now
        else: # New word, always due
            is_due = True
            # next_review_at_iso remains None for new cards, they will be sorted first.

        augmented_words_list.append({
            'id': word_obj.id,
            'word': word_obj.word,
            'perevod': word_obj.perevod,
            'classs': word_obj.classs,
            'unit': word_obj.unit,
            'module': word_obj.module,
            'next_review_at': next_review_at_iso,
            'interval_days': interval,
            'is_new': is_new,
            'is_due': is_due # Helper for sorting
        })

    # Sort words:
    # 1. Due words (next_review_at <= now or is_new) first.
    # 2. Among due words, sort new ones before reviewed ones.
    # 3. Among reviewed due words, sort by earliest next_review_at.
    # 4. Among not-due words, sort by earliest next_review_at.
    # 5. As a final tie-breaker, shuffle or use word ID. For now, word ID for stability.

    augmented_words_list.sort(key=lambda x: (
        not x['is_due'],  # False (due) comes before True (not due)
        x['next_review_at'] is None, # New words (None) come before reviewed due words
        x['next_review_at'] if x['next_review_at'] else now.isoformat(), # Actual review date, use now for None to group them
        x['id'] # Stable sort by ID as a final tie-breaker
    ))


    # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞—Ä—Ç–æ—á–µ–∫ –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–æ
    if cards_count > 0 and len(augmented_words_list) > cards_count:
        augmented_words_list = augmented_words_list[:cards_count]

    if not augmented_words_list: # Should be caught by words_in_module check, but as a safeguard
        flash(f"–î–ª—è –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ —Å–ª–æ–≤.", "warning")
        return redirect(url_for('flashcards_select_module'))

    return render_template('game_flashcards_improved.html',
                           words=augmented_words_list,
                           class_name=class_name,
                           unit_name=unit_name or "–í—Å–µ —é–Ω–∏—Ç—ã",
                           module_name=module_name or "–í—Å–µ –º–æ–¥—É–ª–∏",
                           display_info=display_info,
                           total_cards=len(augmented_words_list),
                           game_mode=mode)

# word_match_select_module and word_match_game will be moved to games_bp

@app.route('/games/word_match/select', methods=['GET'])
def word_match_select_module():
    if 'user_id' not in session:
        return redirect(url_for('auth.login')) # Corrected url_for
    classes = db.session.query(Word.classs).distinct().order_by(Word.classs).all()
    classes = [c[0] for c in classes if c[0]]
    return render_template('game_word_match_select_improved.html', classes=classes)

@app.route('/games/word_match/<class_name>/<unit_name>/<module_name>')
@app.route('/games/word_match/<class_name>/<unit_name>')
@app.route('/games/word_match/<class_name>')
def word_match_game(class_name, unit_name=None, module_name=None):
    if 'user_id' not in session:
        flash("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –≤ —Å–∏—Å—Ç–µ–º—É.", "warning")
        return redirect(url_for('auth.login'))

    # –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–≥—Ä—ã –∏–∑ URL
    mode = request.args.get('mode', 'specific')
    cards_count = int(request.args.get('cards', 8))  # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∞—Ä —Å–ª–æ–≤
    timer_duration = int(request.args.get('timer', 0))
    enable_stopwatch = request.args.get('stopwatch') == 'true'
    selected_modules = request.args.get('modules', '').split(',') if request.args.get('modules') else []
    selected_units = request.args.get('units', '').split(',') if request.args.get('units') else []

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞–∫–∏–µ —Å–ª–æ–≤–∞ –∑–∞–≥—Ä—É–∂–∞—Ç—å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞
    all_words = []
    
    if mode == 'specific' and unit_name and module_name:
        # –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –º–æ–¥—É–ª—å
        all_words = Word.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name}, –ú–æ–¥—É–ª—å: {module_name}"
    elif mode == 'unit' and unit_name:
        # –í–µ—Å—å —é–Ω–∏—Ç
        all_words = Word.query.filter_by(classs=class_name, unit=unit_name).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name} (–≤—Å–µ –º–æ–¥—É–ª–∏)"
    elif mode == 'class':
        # –í–µ—Å—å –∫–ª–∞—Å—Å
        all_words = Word.query.filter_by(classs=class_name).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name} (–≤—Å–µ —é–Ω–∏—Ç—ã –∏ –º–æ–¥—É–ª–∏)"
    elif mode == 'multiple-modules' and unit_name and selected_modules:
        # –ù–µ—Å–∫–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –º–æ–¥—É–ª–µ–π
        all_words = Word.query.filter(
            Word.classs == class_name,
            Word.unit == unit_name,
            Word.module.in_(selected_modules)
        ).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name}, –ú–æ–¥—É–ª–∏: {', '.join(selected_modules)}"
    elif mode == 'multiple-units' and selected_units:
        # –ù–µ—Å–∫–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —é–Ω–∏—Ç–æ–≤
        all_words = Word.query.filter(
            Word.classs == class_name,
            Word.unit.in_(selected_units)
        ).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç—ã: {', '.join(selected_units)}"
    else:
        # Fallback –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –º–æ–¥—É–ª—é
        if unit_name and module_name:
            all_words = Word.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()
            display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name}, –ú–æ–¥—É–ª—å: {module_name}"
        else:
            flash("–ù–µ–≤–µ—Ä–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–≥—Ä—ã.", "warning")
            return redirect(url_for('word_match_select_module'))

    if not all_words:
        flash(f"–î–ª—è –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ —Å–ª–æ–≤.", "warning")
        return redirect(url_for('word_match_select_module'))

    # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∞—Ä –¥–æ—Å—Ç—É–ø–Ω—ã–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Å–ª–æ–≤
    max_pairs = len(all_words)
    num_pairs = min(cards_count, max_pairs)

    if num_pairs < 2:
        flash(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å–ª–æ–≤ –¥–ª—è –∏–≥—Ä—ã (–Ω—É–∂–Ω–æ —Ö–æ—Ç—è –±—ã 2, –Ω–∞–π–¥–µ–Ω–æ {max_pairs}).", "warning")
        return redirect(url_for('word_match_select_module'))

    # –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ —Å–ª–æ–≤–∞
    selected_word_objects = random.sample(all_words, num_pairs)

    original_words_for_js = []
    jumbled_words_list = []
    jumbled_translations_list = []

    for word_obj in selected_word_objects:
        original_words_for_js.append({'id': word_obj.id, 'word': word_obj.word, 'translation': word_obj.perevod})
        jumbled_words_list.append({'id': word_obj.id, 'text': word_obj.word})
        jumbled_translations_list.append({'id': word_obj.id, 'text': word_obj.perevod})

    random.shuffle(jumbled_words_list)
    random.shuffle(jumbled_translations_list)

    return render_template('game_word_match.html',
                           original_words=original_words_for_js,
                           jumbled_words_list=jumbled_words_list,
                           jumbled_translations_list=jumbled_translations_list,
                           class_name=class_name,
                           unit_name=unit_name or "–í—Å–µ —é–Ω–∏—Ç—ã",
                           module_name=module_name or "–í—Å–µ –º–æ–¥—É–ª–∏",
                           display_info=display_info,
                           num_pairs=num_pairs,
                           timer_duration=timer_duration,
                           enable_stopwatch=enable_stopwatch,
                           game_mode=mode)

# sentence_scramble_select_module and sentence_scramble_game will be moved to games_bp

@app.route('/games/sentence_scramble/select', methods=['GET'])
def sentence_scramble_select_module():
    if 'user_id' not in session:
        return redirect(url_for('auth.login')) # Corrected url_for
    # Fetch all unique classes that have sentences
    classes = db.session.query(Sentence.classs).distinct().order_by(Sentence.classs).all()
    classes = [c[0] for c in classes if c[0]]
    return render_template('game_sentence_scramble_select.html', classes=classes)

@app.route('/games/sentence_scramble/<class_name>/<unit_name>/<module_name>')
def sentence_scramble_game(class_name, unit_name, module_name):
    if 'user_id' not in session:
        flash("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –≤ —Å–∏—Å—Ç–µ–º—É.", "warning")
        return redirect(url_for('auth.login')) # Corrected url_for

    sentences_query = Sentence.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()

    if not sentences_query:
        flash(f"–î–ª—è –º–æ–¥—É–ª—è '{module_name}' (—é–Ω–∏—Ç '{unit_name}', –∫–ª–∞—Å—Å '{class_name}') –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π.", "warning")
        return redirect(url_for('sentence_scramble_select_module'))

    sentences_for_js = []
    for sentence_obj in sentences_query:
        sentences_for_js.append({
            'id': sentence_obj.id,
            'text': sentence_obj.text,
            'translation': sentence_obj.translation
            # Add other fields like classs, unit, module if needed by JS, but likely not for the game itself
        })

    # Shuffle the list of sentences for the game
    random.shuffle(sentences_for_js)

    return render_template('game_sentence_scramble.html',
                           sentences=sentences_for_js, # Pass the list of sentence dicts
                           class_name=class_name,
                           unit_name=unit_name,
                           module_name=module_name)

# hangman_select_module and hangman_game will be moved to games_bp

@app.route('/games/hangman/select', methods=['GET'])
def hangman_select_module():
    if 'user_id' not in session:
        return redirect(url_for('auth.login'))
    # Fetch all unique classes for the first dropdown
    classes = db.session.query(Word.classs).distinct().order_by(Word.classs).all()
    classes = [c[0] for c in classes if c[0]] # Ensure not None or empty
    return render_template('game_hangman_select_improved.html', classes=classes)

@app.route('/games/hangman/<class_name>/<unit_name>/<module_name>')
def hangman_game(class_name, unit_name, module_name):
    if 'user_id' not in session:
        flash("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –≤ —Å–∏—Å—Ç–µ–º—É.", "warning")
        return redirect(url_for('auth.login'))

    # Get game settings from URL parameters
    num_words = int(request.args.get('words', 10))  # Default 10 words
    timer_duration = int(request.args.get('timer', 0))  # Default no timer
    enable_stopwatch = request.args.get('stopwatch', 'false').lower() == 'true'
    difficulty = request.args.get('difficulty', 'medium')  # easy, medium, hard
    game_mode = request.args.get('mode', 'specific')  # specific, unit, class, multiple

    # Handle different game modes
    if game_mode == 'unit':
        words_query = Word.query.filter_by(classs=class_name, unit=unit_name).all()
    elif game_mode == 'class':
        words_query = Word.query.filter_by(classs=class_name).all()
    elif game_mode == 'multiple':
        modules = request.args.get('modules', '').split(',')
        if not modules or modules == ['']:
            flash("–ù–µ –≤—ã–±—Ä–∞–Ω—ã –º–æ–¥—É–ª–∏ –¥–ª—è –∏–≥—Ä—ã.", "warning")
            return redirect(url_for('hangman_select_module'))
        words_query = Word.query.filter(
            Word.classs == class_name,
            Word.unit == unit_name,
            Word.module.in_(modules)
        ).all()
    else:  # specific module
        words_query = Word.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()

    if not words_query:
        flash(f"–î–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –º–æ–¥—É–ª—è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ —Å–ª–æ–≤.", "warning")
        return redirect(url_for('hangman_select_module'))

    # Filter words by difficulty if specified
    if difficulty == 'easy':
        # Easy: words 3-5 letters
        words_query = [w for w in words_query if 3 <= len(w.word) <= 5]
    elif difficulty == 'medium':
        # Medium: words 4-8 letters
        words_query = [w for w in words_query if 4 <= len(w.word) <= 8]
    elif difficulty == 'hard':
        # Hard: words 6+ letters
        words_query = [w for w in words_query if len(w.word) >= 6]

    if not words_query:
        flash(f"–î–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Å–ª–æ–≤.", "warning")
        return redirect(url_for('hangman_select_module'))

    # Limit number of words and shuffle
    if len(words_query) > num_words:
        words_query = random.sample(words_query, num_words)
    else:
        random.shuffle(words_query)

    # Prepare words for the game
    game_words = []
    for word_obj in words_query:
        game_words.append({
            'id': word_obj.id,
            'word': word_obj.word.upper(),  # Uppercase for hangman
            'translation': word_obj.perevod,
            'definition': getattr(word_obj, 'definition', ''),
            'example': getattr(word_obj, 'example', '')
        })

    return render_template('game_hangman_improved.html',
                           words_data=game_words,
                           class_name=class_name,
                           unit_name=unit_name,
                           module_name=module_name,
                           timer_duration=timer_duration,
                           enable_stopwatch=enable_stopwatch,
                           difficulty=difficulty,
                           game_mode=game_mode,
                           num_words=len(game_words))


@app.route('/test_details_data/<int:test_id>')
def test_details_data(test_id):
    if 'user_id' not in session:
        return jsonify({'error': 'Authentication required'}), 401

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes': # Only teachers should access this live data endpoint
        return jsonify({'error': 'Forbidden for non-teachers'}), 403

    test = Test.query.get_or_404(test_id)
    if test.created_by != user.id:
        return jsonify({'error': 'Forbidden, not test creator'}), 403

    students_in_class = User.query.filter_by(class_number=test.classs, teacher='no').all()
    total_students_in_class = len(students_in_class)
    all_results_for_test = TestResult.query.filter(
        TestResult.test_id == test.id,
        TestResult.started_at >= test.created_at
    ).all()

    completed_students_details_json = []
    in_progress_students_details_json = []
    not_started_student_ids = {s.id for s in students_in_class}

    for result in all_results_for_test:
        student_user = User.query.get(result.user_id)
        if not student_user or student_user.teacher == 'yes':
            if student_user and result.user_id in not_started_student_ids:
                not_started_student_ids.remove(result.user_id)
            continue

        if result.user_id in not_started_student_ids:
            not_started_student_ids.remove(result.user_id)
        
        student_data = {
            'id': student_user.id,
            'fio': student_user.fio,
            'nick': student_user.nick,
            'result_id': result.id
        }

        if result.completed_at:
            student_data.update({
                'completed_at_iso': result.completed_at.isoformat() + "Z" if result.completed_at else None,
                'score': result.score,
                'correct_answers': result.correct_answers,
                'total_questions': result.total_questions,
                'time_taken_display': format_time_taken(result.time_taken),
                'time_taken_minutes': result.time_taken
            })
            completed_students_details_json.append(student_data)
        else: # In progress
            item_data_for_template = {
                'remaining_time_display': "–ë–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π",
                'has_time_limit': False,
                'end_time_utc_iso': None,
                'started_at_iso': result.started_at.isoformat() + "Z" if result.started_at else None
            }
            if test.time_limit and test.time_limit > 0 and result.started_at:
                end_time_utc = result.started_at + timedelta(minutes=test.time_limit)
                now_utc = datetime.utcnow()
                item_data_for_template['has_time_limit'] = True
                item_data_for_template['end_time_utc_iso'] = end_time_utc.isoformat() + "Z"
                if now_utc < end_time_utc:
                    remaining_delta = end_time_utc - now_utc
                    hours, remainder = divmod(remaining_delta.total_seconds(), 3600)
                    minutes, seconds_float = divmod(remainder, 60)
                    seconds = int(seconds_float)
                    if hours > 0:
                        item_data_for_template['remaining_time_display'] = f"{int(hours)}h {int(minutes)}m {seconds}s left"
                    else:
                        item_data_for_template['remaining_time_display'] = f"{int(minutes)}m {seconds}s left"
                else:
                    item_data_for_template['remaining_time_display'] = "–í—Ä–µ–º—è –≤—ã—à–ª–æ"
            student_data.update(item_data_for_template)
            in_progress_students_details_json.append(student_data)

    not_started_students_json = []
    for uid in not_started_student_ids:
        s_user = User.query.get(uid)
        if s_user:
            not_started_students_json.append({'id': s_user.id, 'fio': s_user.fio, 'nick': s_user.nick})
    
    completed_count = len(completed_students_details_json)
    progress_percentage = (completed_count / total_students_in_class * 100) if total_students_in_class > 0 else 0

    data_to_return = {
        'test_id': test.id,
        'test_title': test.title,
        'is_active': test.is_active,
        'total_students_in_class': total_students_in_class,
        'completed_students_count': completed_count,
        'in_progress_students_count': len(in_progress_students_details_json),
        'not_started_students_count': len(not_started_students_json),
        'progress_percentage': round(progress_percentage, 2),
        'completed_students': completed_students_details_json,
        'in_progress_students': in_progress_students_details_json,
        'not_started_students': not_started_students_json,
        'urls': { # For constructing links in JS if needed
            'test_results_base': url_for('test_results', test_id=test.id, result_id=0)[:-1] # remove trailing 0
        }
    }
    return jsonify(data_to_return)

@app.route('/games/flashcards/update_review', methods=['POST'])
def update_flashcard_review():
    if 'user_id' not in session:
        return jsonify({'error': 'Unauthorized', 'success': False}), 401

    data = request.get_json()
    word_id = data.get('word_id')
    quality = data.get('quality') # 0: Again, 1: Hard, 2: Good, 3: Easy

    if word_id is None or quality is None:
        return jsonify({'error': 'Missing word_id or quality', 'success': False}), 400

    try:
        quality = int(quality)
        word_id = int(word_id)
    except ValueError:
        return jsonify({'error': 'Invalid word_id or quality format', 'success': False}), 400

    user_id = session['user_id']
    review_item = UserWordReview.query.filter_by(user_id=user_id, word_id=word_id).first()

    if not review_item:
        review_item = UserWordReview(user_id=user_id, word_id=word_id)
        db.session.add(review_item)
        # For a new card, initial interval is often 1 day for "Good", or more for "Easy"
        # If "Again" or "Hard" on a new card, it might stay at 0 or 1 day.
        # Let's initialize with values that will be updated by the logic below.

    # Simplified SM-2 like logic
    # q (quality): 0-Again, 1-Hard, 2-Good, 3-Easy
    # EF (ease factor): Default 2.5. Min 1.3.
    # I(n) (interval after nth repetition):
    # I(1) = 1 day
    # I(2) = 6 days
    # For n > 2, I(n) = I(n-1) * EF

    if quality < 2: # Again (0) or Hard (1)
        review_item.interval_days = 1 # Reset or set to a short interval
        # For "Again", some might reset EF, but simplified SM-2 often just resets interval
        if quality == 0: # Strong "Again" - might penalize EF slightly
             review_item.ease_factor = max(1.3, review_item.ease_factor - 0.2)
        elif quality == 1: # "Hard" - penalize EF less
             review_item.ease_factor = max(1.3, review_item.ease_factor - 0.15)

    elif quality == 2: # Good
        if review_item.interval_days == 0: # First time seeing or after reset
            review_item.interval_days = 1
        elif review_item.interval_days == 1:
             review_item.interval_days = 6
        else:
            review_item.interval_days = round(review_item.interval_days * review_item.ease_factor)
        # EF is not changed for "Good" in basic SM-2 after initial setting
        # review_item.ease_factor remains same or small adjustment: ef = ef - 0.0 + 0.1 ....
        # No change to EF on "Good" after initial setting is common.

    elif quality == 3: # Easy
        if review_item.interval_days == 0:
            review_item.interval_days = 4 # Start with a longer interval for "Easy" new cards
        elif review_item.interval_days == 1:
             review_item.interval_days = 10 # Jump if it was a short interval
        else:
            review_item.interval_days = round(review_item.interval_days * review_item.ease_factor * 1.3) # Boost for easy
        review_item.ease_factor = min(3.0, review_item.ease_factor + 0.15) # Increase EF for "Easy"

    # Cap interval to avoid excessively long periods (e.g., 1 year)
    review_item.interval_days = min(review_item.interval_days, 365)


    review_item.next_review_at = datetime.utcnow() + timedelta(days=review_item.interval_days)
    review_item.last_reviewed_at = datetime.utcnow()

    try:
        db.session.commit()
        return jsonify({
            'success': True,
            'next_review_in_days': review_item.interval_days,
            'next_review_date': review_item.next_review_at.isoformat(),
            'ease_factor': review_item.ease_factor
        })
    except Exception as e:
        db.session.rollback()
        # Log the error e
        return jsonify({'error': 'Database commit failed', 'details': str(e), 'success': False}), 500

# API –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ç–µ—Å—Ç–∞
@app.route('/api/test/<int:test_id>/save_progress', methods=['POST'])
def save_test_progress(test_id):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤–æ –≤—Ä–µ–º—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è —Ç–µ—Å—Ç–∞"""
    if 'user_id' not in session:
        return jsonify({'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
    
    user = User.query.get(session['user_id'])
    if not user:
        return jsonify({'error': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 401
    
    # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π —Ç–µ—Å—Ç-—Ä–µ–∑—É–ª—å—Ç–∞—Ç
    test_result = TestResult.query.filter_by(
        test_id=test_id,
        user_id=user.id,
        completed_at=None
    ).first()
    
    if not test_result:
        return jsonify({'error': '–ê–∫—Ç–∏–≤–Ω—ã–π —Ç–µ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    try:
        data = request.get_json()
        if not data or 'answers' not in data:
            return jsonify({'error': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö'}), 400
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
        for answer_data in data['answers']:
            test_word_id = answer_data.get('test_word_id')
            user_answer = answer_data.get('user_answer', '')
            
            if not test_word_id:
                continue
                
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ test_word –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç —ç—Ç–æ–º—É —Ç–µ—Å—Ç—É
            test_word = TestWord.query.filter_by(id=test_word_id, test_id=test_id).first()
            if not test_word:
                continue
            
            # –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∑–∞–ø–∏—Å—å –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
            progress = TestProgress.query.filter_by(
                test_result_id=test_result.id,
                test_word_id=test_word_id
            ).first()
            
            if progress:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∑–∞–ø–∏—Å—å
                progress.user_answer = json.dumps(user_answer) if isinstance(user_answer, (dict, list)) else str(user_answer)
                progress.last_updated = datetime.utcnow()
            else:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å
                progress = TestProgress(
                    test_result_id=test_result.id,
                    test_word_id=test_word_id,
                    user_answer=json.dumps(user_answer) if isinstance(user_answer, (dict, list)) else str(user_answer)
                )
                db.session.add(progress)
        
        db.session.commit()
        return jsonify({'success': True, 'message': '–ü—Ä–æ–≥—Ä–µ—Å—Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': f'–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {str(e)}'}), 500

@app.route('/api/test/<int:test_id>/load_progress', methods=['GET'])
def load_test_progress(test_id):
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    if 'user_id' not in session:
        return jsonify({'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
    
    user = User.query.get(session['user_id'])
    if not user:
        return jsonify({'error': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 401
    
    # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π —Ç–µ—Å—Ç-—Ä–µ–∑—É–ª—å—Ç–∞—Ç
    test_result = TestResult.query.filter_by(
        test_id=test_id,
        user_id=user.id,
        completed_at=None
    ).first()
    
    if not test_result:
        return jsonify({'progress': {}})
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã
        progress_entries = TestProgress.query.filter_by(
            test_result_id=test_result.id
        ).all()
        
        progress_data = {}
        for entry in progress_entries:
            try:
                # –ü—ã—Ç–∞–µ–º—Å—è —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å JSON, –µ—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç—Å—è - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–∫ —Å—Ç—Ä–æ–∫—É
                user_answer = json.loads(entry.user_answer) if entry.user_answer else ''
            except (json.JSONDecodeError, TypeError):
                user_answer = entry.user_answer or ''
            
            progress_data[str(entry.test_word_id)] = user_answer
        
        return jsonify({'progress': progress_data})
        
    except Exception as e:
        return jsonify({'error': f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {str(e)}'}), 500

# Blueprints are already registered at the top of the file
# app.register_blueprint(tests_bp, url_prefix='/tests') # Example for future
# app.register_blueprint(games_bp, url_prefix='/games') # Example for future

@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404

if __name__ == "__main__":
    with app.app_context():
        db.create_all()
        # Add sample sentences if none exist
        if Sentence.query.count() == 0:
            sample_sentences = [
                Sentence(text="This is a simple sentence.", translation="–≠—Ç–æ –ø—Ä–æ—Å—Ç–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.", classs="5", unit="1", module="Greetings"),
                Sentence(text="The cat sleeps on the mat.", translation="–ö–æ—à–∫–∞ —Å–ø–∏—Ç –Ω–∞ –∫–æ–≤—Ä–∏–∫–µ.", classs="5", unit="1", module="Greetings"),
                Sentence(text="I like to learn English.", translation="–ú–Ω–µ –Ω—Ä–∞–≤–∏—Ç—Å—è —É—á–∏—Ç—å –∞–Ω–≥–ª–∏–π—Å–∫–∏–π.", classs="5", unit="1", module="School"),
                Sentence(text="She reads a book every day.", translation="–û–Ω–∞ —á–∏—Ç–∞–µ—Ç –∫–Ω–∏–≥—É –∫–∞–∂–¥—ã–π –¥–µ–Ω—å.", classs="6", unit="2", module="Hobbies"),
                Sentence(text="They play football in the park.", translation="–û–Ω–∏ –∏–≥—Ä–∞—é—Ç –≤ —Ñ—É—Ç–±–æ–ª –≤ –ø–∞—Ä–∫–µ.", classs="6", unit="2", module="Hobbies")
            ]
            db.session.bulk_save_objects(sample_sentences)
            db.session.commit()
            print("Added sample sentences.")
        print("Database tables created (or already exist). Running test.py...") # Optional: for logging
        try:
            subprocess.run(["python", "test.py"], check=True, capture_output=True, text=True)
            print("test.py executed successfully.") # Optional: for logging
        except subprocess.CalledProcessError as e:
            print(f"Error running test.py: {e}") # Optional: for logging
            print(f"stdout: {e.stdout}")
            print(f"stderr: {e.stderr}")
            # Decide if you want to exit or continue if test.py fails
            # For now, it will continue to app.run()
    app.run("0.0.0.0", debug=True, port=1800)


site_1 ‚Äî –∫–æ–ø–∏—è.txt (/home/amir/Documents/Info/Duckly/site_1 ‚Äî –∫–æ–ø–∏—è.txt):
from markupsafe import escape
from flask import Flask, jsonify, request, render_template, redirect, url_for, flash, make_response
from flask_sqlalchemy import SQLAlchemy
import base64 as bs64
import time
import sqlite3



app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.secret_key = 'your-super-secret-key-12345'  # Added secret key for session management
db = SQLAlchemy(app)

class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    fio = db.Column(db.String, nullable=False)
    nick = db.Column(db.String, unique=True, nullable=False)
    password = db.Column(db.String, nullable=False)
    secret_key = db.Column(db.String, nullable=False)
    teacher = db.Column(db.String, nullable=True)

class Word(db.Model):
    __tablename__ = 'words'
    id = db.Column(db.Integer, primary_key=True)
    word = db.Column(db.String, nullable=False)
    perevod = db.Column(db.String, nullable=False)
    classs = db.Column('class', db.String, nullable=False)
    unit = db.Column(db.String, nullable=False)
    module = db.Column(db.String, nullable=False)

class Test(db.Model):
    __tablename__ = 'tests'
    classs = db.Column('class', db.String, primary_key=True)
    unit = db.Column(db.String, primary_key=True)
    type = db.Column(db.String, nullable=False)
    link = db.Column(db.String, unique=True, nullable=False)



@app.route("/")
def index():
    return redirect('/hello', 302)

@app.route("/user/<name>")
def greet(name):
    return f"Hello, {name}!"

@app.route("/profile")
def profile():
    reqinnone = 0
    user = None
    for cookie_name in request.cookies:
        user_obj = User.query.filter_by(nick=cookie_name).first()
        if user_obj:
            secret_key = bs64.b64encode(str.encode(user_obj.nick + user_obj.password[:2])).decode("utf-8")
            if request.cookies.get(cookie_name) == secret_key:
                user = user_obj
                break
            elif request.cookies.get(cookie_name) is not None:
                res = make_response(redirect('hello', 302))
                res.set_cookie(cookie_name, request.cookies.get(cookie_name), max_age=0)
                return res
    if user is None:
        return redirect('/login', 302)
    return render_template('profile.html', nick=user.nick, fio=user.fio)


@app.route("/add_tests", methods=['POST', 'GET'])
def add_tests():
    if request.method == "POST":
        classs = request.form['classSelect']
        print(classs, request.form)
        unit = request.form['unit']
        types = request.form['type']
        print(classs, unit, types)
        times = str(time.time()).split(".")
        link = times[0]+times[1]
        print(link)
        new_test = Test(classs=classs, unit=unit, type=types, link=link)
        db.session.add(new_test)
        db.session.commit()
        return redirect('/tests', 302)
    else:
        return render_template("add_tests.html")

@app.route("/tests")
def tests():
    reqinnone = 0
    user = None
    for cookie_name in request.cookies:
        user_obj = User.query.filter_by(nick=cookie_name).first()
        if user_obj:
            secret_key = bs64.b64encode(str.encode(user_obj.nick + user_obj.password[:2])).decode("utf-8")
            if request.cookies.get(cookie_name) == secret_key:
                user = user_obj
                break
            elif request.cookies.get(cookie_name) is not None:
                res = make_response(redirect('hello', 302))
                res.set_cookie(cookie_name, request.cookies.get(cookie_name), max_age=0)
                return res
    if user is None:
        return redirect('/login', 302)

    tests = Test.query.all()
    return render_template('tests.html', tests=tests)

@app.route("/words/json")
def get_words_json():
    words = Word.query.all()
    data = {}
    for w in words:
        if w.classs not in data:
            data[w.classs] = {}
        if w.unit not in data[w.classs]:
            data[w.classs][w.unit] = []
        data[w.classs][w.unit].append([w.word, w.perevod])
    return jsonify(data)

@app.route("/tests/<id>", methods=['GET', 'POST'])
def test_id(id):
    user = None
    for cookie_name in request.cookies:
        user_obj = User.query.filter_by(nick=cookie_name).first()
        if user_obj:
            secret_key = bs64.b64encode(str.encode(user_obj.nick + user_obj.password[:2])).decode("utf-8")
            if request.cookies.get(cookie_name) == secret_key:
                user = user_obj
                break
            elif request.cookies.get(cookie_name) is not None:
                res = make_response(redirect('hello', 302))
                res.set_cookie(cookie_name, request.cookies.get(cookie_name), max_age=0)
                return res
    if user is None:
        return redirect('/login', 302)

    test = Test.query.filter_by(link=id).first()
    if not test:
        return "Test not found", 404

    classs = test.classs
    unit = test.unit
    test_type = test.type

    words = Word.query.filter_by(classs=classs, unit=unit).all()

    if request.method == 'POST':
        score = 0
        total = len(words)
        if test_type == 'dictation':
            for idx, word_obj in enumerate(words):
                answer = request.form.get(f'answer{idx}', '').strip().lower()
                if answer == word_obj.perevod.lower():
                    score += 1
        elif test_type == 'true_or_false':
            for idx, word_obj in enumerate(words):
                answer = request.form.get(f'answer{idx}', '').strip().lower()
                correct = 'true' if word_obj.perevod.lower() == 'true' else 'false'
                if answer == correct:
                    score += 1
        elif test_type == 'add_letter':
            for idx, word_obj in enumerate(words):
                answer = request.form.get(f'answer{idx}', '').strip().lower()
                if answer == word_obj.perevod.lower():
                    score += 1
        else:
            return "Unknown test type", 400

        return render_template('test_result.html', score=score, total=total, test_type=test_type)

    if test_type == 'dictation':
        return render_template('test_dictation.html', words=words, test_id=id)
    elif test_type == 'true_or_false':
        return render_template('test_true_or_false.html', words=words, test_id=id)
    elif test_type == 'add_letter':
        return render_template('test_add_letter.html', words=words, test_id=id)
    else:
        return "Unknown test type", 400

@app.route("/edit_profile")
def edit_profile():
    user = None
    for cookie_name in request.cookies:
        user_obj = User.query.filter_by(nick=cookie_name).first()
        if user_obj:
            secret_key = bs64.b64encode(str.encode(user_obj.nick + user_obj.password[:2])).decode("utf-8")
            if request.cookies.get(cookie_name) == secret_key:
                user = user_obj
                break
            elif request.cookies.get(cookie_name) is not None:
                res = make_response(redirect('hello', 302))
                res.set_cookie(cookie_name, request.cookies.get(cookie_name), max_age=0)
                return res
    if user is None:
        return redirect('/login', 302)
    return render_template('edit_profile.html', nick=user.nick, fio=user.fio)

@app.route("/save_profile", methods=["POST"])
def save_profile():
    fio = request.form.get("fio")
    nick = request.form.get("nick")

    user = User.query.filter_by(nick=nick).first()
    if user:
        user.fio = fio
        db.session.commit()

    return redirect("/profile")

@app.route("/add_words", methods=['POST', 'GET'])
def add_words():
    if request.method == "POST":
        class_val = request.form.get('classSelect')
        unit_val = request.form.get('unitSelect')
        module_val = request.form.get('moduleSelect')  # Changed from 'module'

        if class_val == 'add_new_class':
            classs = request.form.get('newClassInput', '').strip()
        else:
            classs = class_val

        if unit_val == 'add_new_unit':
            unit = request.form.get('newUnitInput', '').strip()
        else:
            unit = unit_val

        if module_val == 'add_new_module':
            module = request.form.get('newModuleInput', '').strip()
        else:
            module = module_val

        # Ensure classs, unit, and module are not None and provide defaults if necessary
        classs = classs if classs is not None else ""
        unit = unit if unit is not None else ""
        module = module if module is not None else ""

        words = []
        perevods = []

        for key, value in request.form.items():
            if key.startswith("word"):
                words.append(value)
            elif key.startswith("perevod"):
                perevods.append(value)

        for word, perevod in zip(words, perevods):
            new_word = Word(word=word, perevod=perevod, classs=classs, unit=unit, module=module)
            db.session.add(new_word)
        db.session.commit()
        return redirect('/words', 302)

    # GET method: query existing classes
    classes = [str(i) for i in range(1, 12)]
    return render_template("add_words.html", classes=classes)

@app.route("/get_units_for_class")
def get_units_for_class():
    class_name = request.args.get('class_name')
    if not class_name or class_name == 'add_new_class': # Handle placeholder
        return jsonify([])
    units = db.session.query(Word.unit).filter(Word.classs == class_name).distinct().all()
    # Ensure units are actual strings and not None, then sort
    units_list = sorted([u[0] for u in units if u[0]]) 
    return jsonify(units_list)

@app.route("/get_modules_for_unit")
def get_modules_for_unit():
    class_name = request.args.get('class_name')
    unit_name = request.args.get('unit_name')
    if not class_name or not unit_name or class_name == 'add_new_class' or unit_name == 'add_new_unit': # Handle placeholders
        return jsonify([])
    modules = db.session.query(Word.module).filter(Word.classs == class_name, Word.unit == unit_name).distinct().all()
    # Ensure modules are actual strings and not None, then sort
    modules_list = sorted([m[0] for m in modules if m[0]])
    return jsonify(modules_list)

@app.route('/words')
def words():
    words = Word.query.order_by(Word.classs).all()
    items = {}

    # Build items by class, unit, module
    for w in words:
        if w.classs not in items:
            items[w.classs] = {}
        if w.unit not in items[w.classs]:
            items[w.classs][w.unit] = {}
        if w.module not in items[w.classs][w.unit]:
            items[w.classs][w.unit][w.module] = []
        items[w.classs][w.unit][w.module].append([w.word, w.perevod])

    return render_template("words.html", items=items)

@app.route('/edit_word/<word>', methods=['GET', 'POST'])
def edit_word(word):
    classs = request.args.get('class')
    unit = request.args.get('unit')
    module = request.args.get('module')
    perevod = request.args.get('perevod')
    
    # Find the word in the database
    word_obj = Word.query.filter_by(word=word, classs=classs, unit=unit, module=module).first()
    
    if not word_obj:
        return "Word not found", 404
    
    if request.method == 'POST':
        # Update the word
        word_obj.word = request.form.get('word')
        word_obj.perevod = request.form.get('perevod')
        db.session.commit()
        return redirect('/words')
    
    # Get all classes for the dropdown
    all_classes = [str(i) for i in range(1, 12)]
    
    # GET request - render the edit form
    return render_template('edit_word.html', word=word_obj, classs=classs, unit=unit, module=module, all_classes=all_classes)

@app.route('/delete_word/<word>', methods=['POST'])
def delete_word(word):
    # Get the data from the JSON request
    data = request.get_json()
    classs = data.get('class')
    unit = data.get('unit')
    module = data.get('module')
    
    # Find the word in the database
    word_obj = Word.query.filter_by(word=word, classs=classs, unit=unit, module=module).first()
    
    if not word_obj:
        return jsonify({'success': False, 'error': 'Word not found'}), 404
    
    # Delete the word
    db.session.delete(word_obj)
    db.session.commit()
    
    return jsonify({'success': True})

@app.route('/login', methods=['POST', 'GET'])
def login():
    error = None
    if request.method == "POST":
        username = request.form['username']
        password = request.form['password']

        user = User.query.filter_by(nick=username, password=password).first()
        if user:
            secret_key = bs64.b64encode(str.encode(username + password[:2])).decode("utf-8")
            resp = make_response(redirect('hello', 302))
            resp.set_cookie(username, secret_key, 60*60*24*15)
            return resp
        else:
            error = 'Invalid username/password'

    return render_template('login.html', error=error)

@app.route("/logout")
def logout():
    username = None
    for cookie_name in request.cookies:
        if User.query.filter_by(nick=cookie_name).first():
            username = cookie_name
            break
    if username:
        res = make_response(redirect('/login', 302))
        res.set_cookie(username, '', expires=0)
        return res
    else:
        return redirect('/login', 302)

@app.route('/registration', methods=['POST', 'GET'])
def registration():
    error = None
    if request.method == 'POST':
        fio = request.form["fio"]
        username = request.form['username']
        password = request.form['password']

        secret_key = bs64.b64encode(str.encode(username + password[:2])).decode("utf-8")

        max_id = db.session.query(db.func.max(User.id)).scalar()
        if max_id is None:
            max_id = 0
        else:
            max_id += 1

        existing_user = User.query.filter_by(nick=username).first()

        fio_in_mass = fio.split(' ')
        if len(fio_in_mass) == 3:
            if existing_user is None:
                new_user = User(fio=fio, nick=username, password=password, secret_key=secret_key, teacher='no', id=max_id)
                db.session.add(new_user)
                db.session.commit()
                resp = make_response(redirect('hello', 302))
                resp.set_cookie(username, secret_key, 60*60*24*15)
                return resp
            else:
                error = "–í—ã–±—Ä–∞–Ω–Ω—ã–π –≤–∞–º–∏ Username —É–∂–µ –∑–∞–Ω—è—Ç"
        else:
            error = "–§–ò–û –¥–æ–ª–∂–Ω–æ —Å–æ—Å—Ç–æ—è—Ç—å –∏–∑ 3 —Å–ª–æ–≤"
    else:
        error = None

    return render_template('registration.html', error=error)

@app.route("/hello")
def hello():
    user = None
    for cookie_name in request.cookies:
        user_obj = User.query.filter_by(nick=cookie_name).first()
        if user_obj:
            secret_key = bs64.b64encode(str.encode(user_obj.nick + user_obj.password[:2])).decode("utf-8")
            if request.cookies.get(cookie_name) == secret_key:
                user = user_obj
                break
            elif request.cookies.get(cookie_name) is not None:
                res = make_response(redirect('hello', 302))
                res.set_cookie(cookie_name, request.cookies.get(cookie_name), max_age=0)
                return res
    if user is None:
        return redirect('/login', 302)

    fio_parts = user.fio.split(' ')
    try:
        letters = fio_parts[0][:1] + fio_parts[1][:1]
    except:
        letters = user.fio[0] + user.fio[1]

    return render_template('hello.html', username=user.nick, letters=letters)

@app.route("/about")
def about():
    return render_template("about.html")

# Old delete_word route removed in favor of the new route with more precise word identification

@app.route("/edit_word")
def edit_word_form():
    # Get word details from URL parameters
    word = request.args.get("word")
    perevod = request.args.get("perevod")
    classs = request.args.get("class")
    unit = request.args.get("unit")
    
    # Find the word by its attributes
    word_to_edit = db.session.query(Word).filter_by(
        word=word,
        perevod=perevod,
        classs=classs,
        unit=unit
    ).first()
    
    if not word_to_edit:
        flash("Word not found!", "error")
        return redirect(url_for('words'))

    all_classes = [str(i) for i in range(1, 12)] # Assuming classes are 1-11
    # Units and modules will be loaded dynamically by JS
    # The word_to_edit object contains current class, unit, module for pre-selection
    return render_template("edit_word.html", word=word_to_edit, all_classes=all_classes)

@app.route("/update_word", methods=["POST"])
def update_word():
    word_id = request.form.get("word_id")
    word_to_update = Word.query.get(word_id)

    if not word_to_update:
        flash("Word not found for update!", "error")
        return redirect(url_for('words'))

    # Get new values, handling 'add_new_...' for unit and module
    new_class_val = request.form.get('classSelect')
    new_unit_val = request.form.get('unitSelect')
    new_module_val = request.form.get('moduleSelect')

    word_to_update.classs = new_class_val # Assuming classSelect directly provides the class

    if new_unit_val == 'add_new_unit':
        word_to_update.unit = request.form.get('newUnitInput')
    else:
        word_to_update.unit = new_unit_val

    if new_module_val == 'add_new_module':
        word_to_update.module = request.form.get('newModuleInput')
    else:
        word_to_update.module = new_module_val
    
    word_to_update.word = request.form.get("word")
    word_to_update.perevod = request.form.get("perevod")

    try:
        db.session.commit()
        flash("Word updated successfully!", "success")
    except Exception as e:
        db.session.rollback()
        flash(f"Error updating word: {str(e)}", "error")

    return redirect(url_for('words', classs=word_to_update.classs, unit=word_to_update.unit, module=word_to_update.module))

@app.route("/add_unit_to_class")
def add_unit_to_class_form():
    class_name = request.args.get("class")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å —é–Ω–∏—Ç –≤ {class_name}</h2>
    <form action="/save_unit" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="text" name="unit" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ —é–Ω–∏—Ç–∞" required />
        <button type="submit">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
    </form>
    """
@app.route("/add_module_to_unit")
def add_module_to_unit_form():
    class_name = request.args.get("class")
    unit_name = request.args.get("unit")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å –º–æ–¥—É–ª—å –≤ {unit_name} ({class_name})</h2>
    <form action="/save_module" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="hidden" name="unit" value="{unit_name}" />
        <input type="text" name="module" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ –º–æ–¥—É–ª—è" required />
        <button type="submit">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
    </form>
    """

@app.route("/save_module", methods=["POST"])
def save_module():
    class_name = request.form.get("class")
    unit_name = request.form.get("unit")
    module_name = request.form.get("module")

    dummy_word = Word(word="dummy", perevod="–∑–∞–≥–ª—É—à–∫–∞", classs=class_name, unit=unit_name, module=module_name)
    db.session.add(dummy_word)
    db.session.commit()

    return redirect("/words")

@app.route("/add_word_to_module")
def add_word_to_module_form():
    class_name = request.args.get("class")
    unit_name = request.args.get("unit")
    module_name = request.args.get("module")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–æ –≤ –º–æ–¥—É–ª—å: {module_name} ({unit_name}, {class_name})</h2>
    <form action="/add_word" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="hidden" name="unit" value="{unit_name}" />
        <input type="hidden" name="module" value="{module_name}" />
        <label>–°–ª–æ–≤–æ:</label><br/>
        <input type="text" name="word" required /><br/>
        <label>–ü–µ—Ä–µ–≤–æ–¥:</label><br/>
        <input type="text" name="perevod" required /><br/>
        <button type="submit">–î–æ–±–∞–≤–∏—Ç—å</button>
    </form>
    """

@app.route("/save_unit", methods=["POST"])
def save_unit():
    class_name = request.form.get("class")
    unit_name = request.form.get("unit")

    # –ü—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º –ª—é–±–æ–µ —Å–ª–æ–≤–æ, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å —Å–≤—è–∑—å –∫–ª–∞—Å—Å–∞ –∏ –º–æ–¥—É–ª—è
    dummy_word = Word(word="dummy", perevod="–∑–∞–≥–ª—É—à–∫–∞", classs=class_name, unit=unit_name)
    db.session.add(dummy_word)
    db.session.commit()

    return redirect("/words")

@app.route("/add_word_to_unit")
def add_word_to_unit_form():
    class_name = request.args.get("class")
    unit_name = request.args.get("unit")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–æ –≤ {unit_name} ({class_name})</h2>
    <form action="/add_word" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="hidden" name="unit" value="{unit_name}" />
        <label>–°–ª–æ–≤–æ:</label><br/>
        <input type="text" name="word" required /><br/>
        <label>–ü–µ—Ä–µ–≤–æ–¥:</label><br/>
        <input type="text" name="perevod" required /><br/>
        <button type="submit">–î–æ–±–∞–≤–∏—Ç—å</button>
    </form>
    """

@app.route("/add_word", methods=["POST"])
def add_word():
    class_name = request.form.get("class")
    unit_name = request.form.get("unit")
    module_name = request.form.get("module")
    word = request.form.get("word")
    perevod = request.form.get("perevod")

    # Validate that all required fields are filled out
    if not class_name or not unit_name or not module_name:
        flash("–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–æ: –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–∞–ø–æ–ª–Ω–∏—Ç—å –∫–ª–∞—Å—Å, —é–Ω–∏—Ç –∏ –º–æ–¥—É–ª—å", "error")
        return redirect("/words")

    new_word = Word(word=word, perevod=perevod, classs=class_name, unit=unit_name, module=module_name)
    db.session.add(new_word)
    db.session.commit()

    return redirect("/words")



if __name__ == "__main__":
    with app.app_context():
        db.create_all()

start.sh (/home/amir/Documents/Info/Duckly/start.sh):
docker build -t duckly-app .
docker rm -f duckly-container || true
docker run -d \
  --name duckly-container \
  -p 1800:1800 \
  # Mount the local ./instance directory to /app/instance in the container
  # $(pwd) resolves to the current working directory (Linux/macOS)
  -v $(pwd)/instance:/app/instance \
  # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–µ—Å—Å–∏–π
  -v $(pwd)/flask_session:/app/flask_session \
  # IMPORTANT: Change this SECRET_KEY for production environments!
  -e SECRET_KEY='your-development-secret-key-here' \
  duckly-app

static (/home/amir/Documents/Info/Duckly/static):


templates (/home/amir/Documents/Info/Duckly/templates):


test_progress_functionality.py (/home/amir/Documents/Info/Duckly/test_progress_functionality.py):
#!/usr/bin/env python3
"""
–¢–µ—Å—Ç–æ–≤—ã–π —Å–∫—Ä–∏–ø—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
"""

import requests
import json

def test_progress_api():
    """–¢–µ—Å—Ç–∏—Ä—É–µ—Ç API —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞"""
    
    base_url = "http://localhost:1800"
    
    # –¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
    test_id = 1  # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π ID —Ç–µ—Å—Ç–∞
    
    # –î–∞–Ω–Ω—ã–µ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
    test_data = {
        "answers": [
            {
                "test_word_id": 1,
                "user_answer": "hello"
            },
            {
                "test_word_id": 2,
                "user_answer": "world"
            }
        ]
    }
    
    print("–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ API —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞...")
    
    # –¢–µ—Å—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
    print(f"\n1. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –¥–ª—è —Ç–µ—Å—Ç–∞ {test_id}")
    try:
        response = requests.post(
            f"{base_url}/api/test/{test_id}/save_progress",
            json=test_data,
            headers={'Content-Type': 'application/json'}
        )
        print(f"–°—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–∞: {response.status_code}")
        print(f"–û—Ç–≤–µ—Ç: {response.text}")
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏: {e}")
    
    # –¢–µ—Å—Ç –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
    print(f"\n2. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –¥–ª—è —Ç–µ—Å—Ç–∞ {test_id}")
    try:
        response = requests.get(f"{base_url}/api/test/{test_id}/load_progress")
        print(f"–°—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–∞: {response.status_code}")
        print(f"–û—Ç–≤–µ—Ç: {response.text}")
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ: {e}")

if __name__ == "__main__":
    print("–ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞...")
    test_progress_api()
    print("\n–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!")

test.py (/home/amir/Documents/Info/Duckly/test.py):
from site_1 import app, db, Word, User, Test, TestWord
from werkzeug.security import generate_password_hash
import random
import time
import json
import string

def create_word_with_missing_letters(word):
    """–°–æ–∑–¥–∞–µ—Ç —Å–ª–æ–≤–æ —Å –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–º–∏ –±—É–∫–≤–∞–º–∏ –¥–ª—è —Ç–µ—Å—Ç–∞ 'add_letter'"""
    if len(word) <= 2:
        return word[0] + '_' * (len(word) - 1)
    
    # –£–±–∏—Ä–∞–µ–º 1-2 –±—É–∫–≤—ã —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º
    word_list = list(word.lower())
    num_gaps = min(2, max(1, len(word) // 3))
    
    # –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –ø—Ä–æ–ø—É—Å–∫–æ–≤ (–Ω–µ –ø–µ—Ä–≤—É—é –∏ –Ω–µ –ø–æ—Å–ª–µ–¥–Ω—é—é)
    available_positions = list(range(1, len(word) - 1)) if len(word) > 2 else [0]
    gap_positions = random.sample(available_positions, min(num_gaps, len(available_positions)))
    
    for pos in gap_positions:
        word_list[pos] = '_'
    
    return ''.join(word_list)

def create_multiple_choice_options(correct_word, all_words):
    """–°–æ–∑–¥–∞–µ—Ç –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤ –¥–ª—è –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞"""
    # –ë–µ—Ä–µ–º 3 —Å–ª—É—á–∞–π–Ω—ã—Ö –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–∞
    other_words = [w.word for w in all_words if w.word.lower() != correct_word.lower()]
    wrong_options = random.sample(other_words, min(3, len(other_words)))
    
    # –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
    all_options = wrong_options + [correct_word]
    random.shuffle(all_options)
    
    return json.dumps(all_options)

def create_wrong_translation(correct_translation, all_words):
    """–°–æ–∑–¥–∞–µ—Ç –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –¥–ª—è —Ç–µ—Å—Ç–∞ 'true_false'"""
    # –ë–µ—Ä–µ–º —Å–ª—É—á–∞–π–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –¥—Ä—É–≥–æ–≥–æ —Å–ª–æ–≤–∞
    other_translations = [w.perevod for w in all_words if w.perevod != correct_translation]
    if other_translations:
        return random.choice(other_translations)
    return correct_translation

def generate_test_link():
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É –¥–ª—è —Ç–µ—Å—Ç–∞"""
    while True:
        link = ''.join(random.choices(string.ascii_letters + string.digits, k=10))
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–∞–∫–∞—è —Å—Å—ã–ª–∫–∞ –µ—â–µ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        if not Test.query.filter_by(link=link).first():
            return link

def generate_test_data():
    # –°–ø–∏—Å–æ–∫ –∫–ª–∞—Å—Å–æ–≤ (1-11)
    classes = [str(i) for i in range(1, 12)]
    
    # –°–ø–∏—Å–æ–∫ —é–Ω–∏—Ç–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–ª–∞—Å—Å–∞
    units = {
        '1': ['Unit 1: Greetings', 'Unit 2: Numbers', 'Unit 3: Colors'],
        '2': ['Unit 1: Family', 'Unit 2: Animals', 'Unit 3: Food'],
        '3': ['Unit 1: School', 'Unit 2: Weather', 'Unit 3: Clothes'],
        '4': ['Unit 1: Hobbies', 'Unit 2: Sports', 'Unit 3: Music'],
        '5': ['Unit 1: Travel', 'Unit 2: City', 'Unit 3: Nature'],
        '6': ['Unit 1: Technology', 'Unit 2: Science', 'Unit 3: Space'],
        '7': ['Unit 1: History', 'Unit 2: Geography', 'Unit 3: Culture'],
        '8': ['Unit 1: Literature', 'Unit 2: Art', 'Unit 3: Media'],
        '9': ['Unit 1: Business', 'Unit 2: Economy', 'Unit 3: Politics'],
        '10': ['Unit 1: Medicine', 'Unit 2: Law', 'Unit 3: Education'],
        '11': ['Unit 1: Philosophy', 'Unit 2: Psychology', 'Unit 3: Sociology']
    }
    
    # –°–ø–∏—Å–æ–∫ –º–æ–¥—É–ª–µ–π –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —é–Ω–∏—Ç–∞
    modules = {
        'Unit 1: Greetings': ['Basic Greetings', 'Formal Greetings', 'Informal Greetings'],
        'Unit 2: Numbers': ['Cardinal Numbers', 'Ordinal Numbers', 'Fractions'],
        'Unit 3: Colors': ['Basic Colors', 'Shades', 'Color Combinations'],
        'Unit 1: Family': ['Family Members', 'Relationships', 'Family Activities'],
        'Unit 2: Animals': ['Pets', 'Wild Animals', 'Farm Animals'],
        'Unit 3: Food': ['Fruits', 'Vegetables', 'Meals'],
        'Unit 1: School': ['School Subjects', 'School Supplies', 'School Activities'],
        'Unit 2: Weather': ['Weather Conditions', 'Seasons', 'Weather Forecast'],
        'Unit 3: Clothes': ['Basic Clothes', 'Accessories', 'Fashion'],
        'Unit 1: Hobbies': ['Sports', 'Arts', 'Collecting'],
        'Unit 2: Sports': ['Team Sports', 'Individual Sports', 'Sports Equipment'],
        'Unit 3: Music': ['Musical Instruments', 'Music Genres', 'Music Terms'],
        'Unit 1: Travel': ['Transportation', 'Accommodation', 'Tourism'],
        'Unit 2: City': ['City Places', 'City Services', 'City Life'],
        'Unit 3: Nature': ['Landscapes', 'Plants', 'Natural Phenomena'],
        'Unit 1: Technology': ['Computers', 'Internet', 'Gadgets'],
        'Unit 2: Science': ['Physics', 'Chemistry', 'Biology'],
        'Unit 3: Space': ['Solar System', 'Space Exploration', 'Astronomy'],
        'Unit 1: History': ['Ancient History', 'Modern History', 'Historical Events'],
        'Unit 2: Geography': ['Countries', 'Capitals', 'Landmarks'],
        'Unit 3: Culture': ['Traditions', 'Customs', 'Festivals'],
        'Unit 1: Literature': ['Genres', 'Authors', 'Literary Terms'],
        'Unit 2: Art': ['Art Forms', 'Artists', 'Art History'],
        'Unit 3: Media': ['News', 'Entertainment', 'Social Media'],
        'Unit 1: Business': ['Companies', 'Marketing', 'Management'],
        'Unit 2: Economy': ['Economics', 'Finance', 'Trade'],
        'Unit 3: Politics': ['Government', 'Elections', 'International Relations'],
        'Unit 1: Medicine': ['Diseases', 'Treatment', 'Healthcare'],
        'Unit 2: Law': ['Legal System', 'Rights', 'Crimes'],
        'Unit 3: Education': ['Education System', 'Learning', 'Teaching'],
        'Unit 1: Philosophy': ['Philosophical Concepts', 'Philosophers', 'Ethics'],
        'Unit 2: Psychology': ['Mental Processes', 'Behavior', 'Personality'],
        'Unit 3: Sociology': ['Society', 'Social Groups', 'Social Issues']
    }
    
    # –°–ª–æ–≤–∞—Ä—å —Å —Ç–µ—Å—Ç–æ–≤—ã–º–∏ —Å–ª–æ–≤–∞–º–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –º–æ–¥—É–ª—è
    test_words = {
        'Basic Greetings': [
            ('hello', '–ø—Ä–∏–≤–µ—Ç'),
            ('goodbye', '–¥–æ —Å–≤–∏–¥–∞–Ω–∏—è'),
            ('good morning', '–¥–æ–±—Ä–æ–µ —É—Ç—Ä–æ'),
            ('good afternoon', '–¥–æ–±—Ä—ã–π –¥–µ–Ω—å'),
            ('good evening', '–¥–æ–±—Ä—ã–π –≤–µ—á–µ—Ä'),
            ('how are you', '–∫–∞–∫ –¥–µ–ª–∞'),
            ('fine, thank you', '—Ö–æ—Ä–æ—à–æ, —Å–ø–∞—Å–∏–±–æ')
        ],
        'Formal Greetings': [
            ('pleased to meet you', '—Ä–∞–¥ –ø–æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è'),
            ('how do you do', '–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ (—Ñ–æ—Ä–º–∞–ª—å–Ω–æ)'),
            ('it\'s a pleasure', '—ç—Ç–æ —É–¥–æ–≤–æ–ª—å—Å—Ç–≤–∏–µ'),
            ('may I introduce', '–ø–æ–∑–≤–æ–ª—å—Ç–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç—å'),
            ('farewell', '–ø—Ä–æ—â–∞–π—Ç–µ')
        ],
        'Informal Greetings': [
            ('hi', '–ø—Ä–∏–≤–µ—Ç'),
            ('bye', '–ø–æ–∫–∞'),
            ('see ya', '—É–≤–∏–¥–∏–º—Å—è'),
            ('what\'s up', '–∫–∞–∫ –¥–µ–ª–∞ (—Å–ª.)'),
            ('long time no see', '–¥–∞–≤–Ω–æ –Ω–µ –≤–∏–¥–µ–ª–∏—Å—å')
        ],
        'Cardinal Numbers': [
            ('one', '–æ–¥–∏–Ω'), ('two', '–¥–≤–∞'), ('three', '—Ç—Ä–∏'), ('four', '—á–µ—Ç—ã—Ä–µ'),
            ('five', '–ø—è—Ç—å'), ('ten', '–¥–µ—Å—è—Ç—å'), ('twenty', '–¥–≤–∞–¥—Ü–∞—Ç—å'), ('one hundred', '—Å—Ç–æ')
        ],
        'Ordinal Numbers': [
            ('first', '–ø–µ—Ä–≤—ã–π'), ('second', '–≤—Ç–æ—Ä–æ–π'), ('third', '—Ç—Ä–µ—Ç–∏–π'),
            ('fourth', '—á–µ—Ç–≤–µ—Ä—Ç—ã–π'), ('fifth', '–ø—è—Ç—ã–π'), ('tenth', '–¥–µ—Å—è—Ç—ã–π'),
            ('twentieth', '–¥–≤–∞–¥—Ü–∞—Ç—ã–π')
        ],
        'Fractions': [
            ('half', '–ø–æ–ª–æ–≤–∏–Ω–∞'), ('quarter', '—á–µ—Ç–≤–µ—Ä—Ç—å'), ('one third', '–æ–¥–Ω–∞ —Ç—Ä–µ—Ç—å'),
            ('two thirds', '–¥–≤–µ —Ç—Ä–µ—Ç–∏'), ('three quarters', '—Ç—Ä–∏ —á–µ—Ç–≤–µ—Ä—Ç–∏')
        ],
        'Basic Colors': [
            ('red', '–∫—Ä–∞—Å–Ω—ã–π'), ('blue', '—Å–∏–Ω–∏–π'), ('green', '–∑–µ–ª–µ–Ω—ã–π'),
            ('yellow', '–∂–µ–ª—Ç—ã–π'), ('black', '—á–µ—Ä–Ω—ã–π'), ('white', '–±–µ–ª—ã–π'),
            ('orange', '–æ—Ä–∞–Ω–∂–µ–≤—ã–π'), ('purple', '—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π')
        ],
        'Shades': [
            ('light blue', '—Å–≤–µ—Ç–ª–æ-—Å–∏–Ω–∏–π'), ('dark green', '—Ç–µ–º–Ω–æ-–∑–µ–ª–µ–Ω—ã–π'),
            ('bright red', '—è—Ä–∫–æ-–∫—Ä–∞—Å–Ω—ã–π'), ('pale yellow', '–±–ª–µ–¥–Ω–æ-–∂–µ–ª—Ç—ã–π'),
            ('deep purple', '—Ç–µ–º–Ω–æ-—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π'), ('navy blue', '—Ç–µ–º–Ω–æ-—Å–∏–Ω–∏–π')
        ],
        'Color Combinations': [
            ('red and blue', '–∫—Ä–∞—Å–Ω—ã–π –∏ —Å–∏–Ω–∏–π'), ('black and white', '—á–µ—Ä–Ω—ã–π –∏ –±–µ–ª—ã–π'),
            ('green and yellow', '–∑–µ–ª–µ–Ω—ã–π –∏ –∂–µ–ª—Ç—ã–π'), ('blue and white', '—Å–∏–Ω–∏–π –∏ –±–µ–ª—ã–π'),
            ('red and green', '–∫—Ä–∞—Å–Ω—ã–π –∏ –∑–µ–ª–µ–Ω—ã–π'), ('orange and black', '–æ—Ä–∞–Ω–∂–µ–≤—ã–π –∏ —á–µ—Ä–Ω—ã–π')
        ],
        'Family Members': [
            ('mother', '–º–∞—Ç—å'), ('father', '–æ—Ç–µ—Ü'), ('sister', '—Å–µ—Å—Ç—Ä–∞'),
            ('brother', '–±—Ä–∞—Ç'), ('grandmother', '–±–∞–±—É—à–∫–∞'), ('grandfather', '–¥–µ–¥—É—à–∫–∞'),
            ('aunt', '—Ç–µ—Ç—è'), ('uncle', '–¥—è–¥—è'), ('cousin', '–¥–≤–æ—é—Ä–æ–¥–Ω—ã–π –±—Ä–∞—Ç/—Å–µ—Å—Ç—Ä–∞')
        ],
        'Relationships': [
            ('family', '—Å–µ–º—å—è'), ('parents', '—Ä–æ–¥–∏—Ç–µ–ª–∏'), ('children', '–¥–µ—Ç–∏'),
            ('relatives', '—Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏'), ('spouse', '—Å—É–ø—Ä—É–≥/—Å—É–ø—Ä—É–≥–∞'),
            ('niece', '–ø–ª–µ–º—è–Ω–Ω–∏—Ü–∞'), ('nephew', '–ø–ª–µ–º—è–Ω–Ω–∏–∫')
        ],
        'Family Activities': [
            ('cook dinner', '–≥–æ—Ç–æ–≤–∏—Ç—å —É–∂–∏–Ω'), ('clean the house', '—É–±–∏—Ä–∞—Ç—å –¥–æ–º'),
            ('play games', '–∏–≥—Ä–∞—Ç—å –≤ –∏–≥—Ä—ã'), ('read books', '—á–∏—Ç–∞—Ç—å –∫–Ω–∏–≥–∏'),
            ('watch TV', '—Å–º–æ—Ç—Ä–µ—Ç—å —Ç–µ–ª–µ–≤–∏–∑–æ—Ä'), ('go for a walk', '–≥—É–ª—è—Ç—å'),
            ('visit relatives', '–ø–æ—Å–µ—â–∞—Ç—å —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–æ–≤')
        ],
        'Pets': [
            ('dog', '—Å–æ–±–∞–∫–∞'), ('cat', '–∫–æ—à–∫–∞'), ('bird', '–ø—Ç–∏—Ü–∞'),
            ('fish', '—Ä—ã–±–∞'), ('hamster', '—Ö–æ–º—è–∫'), ('guinea pig', '–º–æ—Ä—Å–∫–∞—è —Å–≤–∏–Ω–∫–∞'),
            ('rabbit', '–∫—Ä–æ–ª–∏–∫')
        ],
        'Wild Animals': [
            ('lion', '–ª–µ–≤'), ('tiger', '—Ç–∏–≥—Ä'), ('elephant', '—Å–ª–æ–Ω'),
            ('monkey', '–æ–±–µ–∑—å—è–Ω–∞'), ('giraffe', '–∂–∏—Ä–∞—Ñ'), ('zebra', '–∑–µ–±—Ä–∞'),
            ('bear', '–º–µ–¥–≤–µ–¥—å'), ('wolf', '–≤–æ–ª–∫')
        ],
        'Farm Animals': [
            ('cow', '–∫–æ—Ä–æ–≤–∞'), ('pig', '—Å–≤–∏–Ω—å—è'), ('sheep', '–æ–≤—Ü–∞'),
            ('chicken', '–∫—É—Ä–∏—Ü–∞'), ('horse', '–ª–æ—à–∞–¥—å'), ('duck', '—É—Ç–∫–∞'),
            ('goat', '–∫–æ–∑–∞')
        ],
        'Fruits': [
            ('apple', '—è–±–ª–æ–∫–æ'), ('banana', '–±–∞–Ω–∞–Ω'), ('orange', '–∞–ø–µ–ª—å—Å–∏–Ω'),
            ('grape', '–≤–∏–Ω–æ–≥—Ä–∞–¥'), ('strawberry', '–∫–ª—É–±–Ω–∏–∫–∞'), ('blueberry', '—á–µ—Ä–Ω–∏–∫–∞'),
            ('pineapple', '–∞–Ω–∞–Ω–∞—Å'), ('mango', '–º–∞–Ω–≥–æ')
        ],
        'Vegetables': [
            ('carrot', '–º–æ—Ä–∫–æ–≤—å'), ('potato', '–∫–∞—Ä—Ç–æ—Ñ–µ–ª—å'), ('tomato', '–ø–æ–º–∏–¥–æ—Ä'),
            ('cucumber', '–æ–≥—É—Ä–µ—Ü'), ('onion', '–ª—É–∫'), ('broccoli', '–±—Ä–æ–∫–∫–æ–ª–∏'),
            ('spinach', '—à–ø–∏–Ω–∞—Ç'), ('pepper', '–ø–µ—Ä–µ—Ü')
        ],
        'Meals': [
            ('breakfast', '–∑–∞–≤—Ç—Ä–∞–∫'), ('lunch', '–æ–±–µ–¥'), ('dinner', '—É–∂–∏–Ω'),
            ('snack', '–ø–µ—Ä–µ–∫—É—Å'), ('dessert', '–¥–µ—Å–µ—Ä—Ç'), ('supper', '—É–∂–∏–Ω (–ø–æ–∑–¥–Ω–∏–π)'),
            ('brunch', '–ø–æ–∑–¥–Ω–∏–π –∑–∞–≤—Ç—Ä–∞–∫')
        ],
        'School Subjects': [
            ('math', '–º–∞—Ç–µ–º–∞—Ç–∏–∫–∞'), ('science', '–Ω–∞—É–∫–∞'), ('history', '–∏—Å—Ç–æ—Ä–∏—è'),
            ('geography', '–≥–µ–æ–≥—Ä–∞—Ñ–∏—è'), ('literature', '–ª–∏—Ç–µ—Ä–∞—Ç—É—Ä–∞'),
            ('art', '–∏—Å–∫—É—Å—Å—Ç–≤–æ'), ('music', '–º—É–∑—ã–∫–∞'), ('physical education', '—Ñ–∏–∑–∫—É–ª—å—Ç—É—Ä–∞')
        ],
        'School Supplies': [
            ('pencil', '–∫–∞—Ä–∞–Ω–¥–∞—à'), ('notebook', '—Ç–µ—Ç—Ä–∞–¥—å'), ('book', '–∫–Ω–∏–≥–∞'),
            ('ruler', '–ª–∏–Ω–µ–π–∫–∞'), ('eraser', '–ª–∞—Å—Ç–∏–∫'), ('backpack', '—Ä—é–∫–∑–∞–∫'),
            ('pen', '—Ä—É—á–∫–∞'), ('scissors', '–Ω–æ–∂–Ω–∏—Ü—ã')
        ],
        'School Activities': [
            ('study', '—É—á–∏—Ç—å—Å—è'), ('read', '—á–∏—Ç–∞—Ç—å'), ('write', '–ø–∏—Å–∞—Ç—å'),
            ('draw', '—Ä–∏—Å–æ–≤–∞—Ç—å'), ('calculate', '–≤—ã—á–∏—Å–ª—è—Ç—å'), ('listen to', '—Å–ª—É—à–∞—Ç—å'),
            ('speak', '–≥–æ–≤–æ—Ä–∏—Ç—å'), ('discuss', '–æ–±—Å—É–∂–¥–∞—Ç—å')
        ],
        'Weather Conditions': [
            ('sunny', '—Å–æ–ª–Ω–µ—á–Ω–æ'), ('rainy', '–¥–æ–∂–¥–ª–∏–≤–æ'), ('cloudy', '–æ–±–ª–∞—á–Ω–æ'),
            ('windy', '–≤–µ—Ç—Ä–µ–Ω–æ'), ('snowy', '—Å–Ω–µ–∂–Ω–æ'), ('stormy', '—à—Ç–æ—Ä–º–æ–≤–æ–π'),
            ('foggy', '—Ç—É–º–∞–Ω–Ω–æ'), ('icy', '–≥–æ–ª–æ–ª–µ–¥–∏—Ü–∞')
        ],
        'Seasons': [
            ('spring', '–≤–µ—Å–Ω–∞'), ('summer', '–ª–µ—Ç–æ'), ('autumn', '–æ—Å–µ–Ω—å'),
            ('winter', '–∑–∏–º–∞'), ('season', '—Å–µ–∑–æ–Ω')
        ],
        'Weather Forecast': [
            ('temperature', '—Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞'), ('forecast', '–ø—Ä–æ–≥–Ω–æ–∑ –ø–æ–≥–æ–¥—ã'),
            ('degree Celsius', '–≥—Ä–∞–¥—É—Å –¶–µ–ª—å—Å–∏—è'), ('weather report', '—Å–≤–æ–¥–∫–∞ –ø–æ–≥–æ–¥—ã'),
            ('climate change', '–∏–∑–º–µ–Ω–µ–Ω–∏–µ –∫–ª–∏–º–∞—Ç–∞'), ('humidity', '–≤–ª–∞–∂–Ω–æ—Å—Ç—å')
        ],
        'Basic Clothes': [
            ('shirt', '—Ä—É–±–∞—à–∫–∞'), ('pants', '–±—Ä—é–∫–∏'), ('dress', '–ø–ª–∞—Ç—å–µ'),
            ('jacket', '–∫—É—Ä—Ç–∫–∞'), ('shoes', '–æ–±—É–≤—å'), ('skirt', '—é–±–∫–∞'),
            ('sweater', '—Å–≤–∏—Ç–µ—Ä'), ('socks', '–Ω–æ—Å–∫–∏')
        ],
        'Accessories': [
            ('hat', '—à–ª—è–ø–∞'), ('scarf', '—à–∞—Ä—Ñ'), ('gloves', '–ø–µ—Ä—á–∞—Ç–∫–∏'),
            ('belt', '—Ä–µ–º–µ–Ω—å'), ('watch', '—á–∞—Å—ã'), ('glasses', '–æ—á–∫–∏'),
            ('jewelry', '—é–≤–µ–ª–∏—Ä–Ω—ã–µ –∏–∑–¥–µ–ª–∏—è')
        ],
        'Fashion': [
            ('style', '—Å—Ç–∏–ª—å'), ('trend', '—Ç—Ä–µ–Ω–¥'), ('design', '–¥–∏–∑–∞–π–Ω'),
            ('brand', '–±—Ä–µ–Ω–¥'), ('collection', '–∫–æ–ª–ª–µ–∫—Ü–∏—è'), ('fashionable', '–º–æ–¥–Ω—ã–π'),
            ('outfit', '–Ω–∞—Ä—è–¥')
        ],
        'Team Sports': [
            ('football', '—Ñ—É—Ç–±–æ–ª'), ('basketball', '–±–∞—Å–∫–µ—Ç–±–æ–ª'), ('volleyball', '–≤–æ–ª–µ–π–±–æ–ª'),
            ('hockey', '—Ö–æ–∫–∫–µ–π'), ('soccer', '—Ñ—É—Ç–±–æ–ª (–∞–º–µ—Ä–∏–∫–∞–Ω—Å–∫–∏–π)') # –£—Ç–æ—á–Ω–µ–Ω–∏–µ –¥–ª—è –∞–º–µ—Ä–∏–∫–∞–Ω—Å–∫–æ–≥–æ —Ñ—É—Ç–±–æ–ª–∞
        ],
        'Individual Sports': [
            ('running', '–±–µ–≥'), ('swimming', '–ø–ª–∞–≤–∞–Ω–∏–µ'), ('cycling', '–≤–µ–ª–æ—Å–ø–æ—Ä—Ç'),
            ('tennis', '—Ç–µ–Ω–Ω–∏—Å'), ('gymnastics', '–≥–∏–º–Ω–∞—Å—Ç–∏–∫–∞')
        ],
        'Sports Equipment': [
            ('ball', '–º—è—á'), ('racket', '—Ä–∞–∫–µ—Ç–∫–∞'), ('helmet', '—à–ª–µ–º'),
            ('skates', '–∫–æ–Ω—å–∫–∏'), ('uniform', '—Ñ–æ—Ä–º–∞')
        ],
        'Musical Instruments': [
            ('guitar', '–≥–∏—Ç–∞—Ä–∞'), ('piano', '–ø–∏–∞–Ω–∏–Ω–æ'), ('drums', '–±–∞—Ä–∞–±–∞–Ω—ã'),
            ('violin', '—Å–∫—Ä–∏–ø–∫–∞'), ('flute', '—Ñ–ª–µ–π—Ç–∞')
        ],
        'Music Genres': [
            ('pop', '–ø–æ–ø-–º—É–∑—ã–∫–∞'), ('rock', '—Ä–æ–∫-–º—É–∑—ã–∫–∞'), ('jazz', '–¥–∂–∞–∑'),
            ('classical music', '–∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è –º—É–∑—ã–∫–∞'), ('hip hop', '—Ö–∏–ø-—Ö–æ–ø')
        ],
        'Music Terms': [
            ('melody', '–º–µ–ª–æ–¥–∏—è'), ('rhythm', '—Ä–∏—Ç–º'), ('harmony', '–≥–∞—Ä–º–æ–Ω–∏—è'),
            ('composer', '–∫–æ–º–ø–æ–∑–∏—Ç–æ—Ä'), ('lyrics', '—Ç–µ–∫—Å—Ç –ø–µ—Å–Ω–∏')
        ],
        'Transportation': [
            ('car', '–º–∞—à–∏–Ω–∞'), ('bus', '–∞–≤—Ç–æ–±—É—Å'), ('train', '–ø–æ–µ–∑–¥'),
            ('plane', '—Å–∞–º–æ–ª–µ—Ç'), ('bicycle', '–≤–µ–ª–æ—Å–∏–ø–µ–¥'), ('ship', '–∫–æ—Ä–∞–±–ª—å')
        ],
        'Accommodation': [
            ('hotel', '–æ—Ç–µ–ª—å'), ('apartment', '–∫–≤–∞—Ä—Ç–∏—Ä–∞'), ('hostel', '—Ö–æ—Å—Ç–µ–ª'),
            ('tent', '–ø–∞–ª–∞—Ç–∫–∞'), ('resort', '–∫—É—Ä–æ—Ä—Ç')
        ],
        'Tourism': [
            ('travel', '–ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ'), ('tourist', '—Ç—É—Ä–∏—Å—Ç'), ('sightseeing', '–æ—Å–º–æ—Ç—Ä –¥–æ—Å—Ç–æ–ø—Ä–∏–º–µ—á–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–µ–π'),
            ('attraction', '–¥–æ—Å—Ç–æ–ø—Ä–∏–º–µ—á–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å'), ('souvenir', '—Å—É–≤–µ–Ω–∏—Ä')
        ],
        'City Places': [
            ('park', '–ø–∞—Ä–∫'), ('museum', '–º—É–∑–µ–π'), ('library', '–±–∏–±–ª–∏–æ—Ç–µ–∫–∞'),
            ('restaurant', '—Ä–µ—Å—Ç–æ—Ä–∞–Ω'), ('supermarket', '—Å—É–ø–µ—Ä–º–∞—Ä–∫–µ—Ç')
        ],
        'City Services': [
            ('police station', '–ø–æ–ª–∏—Ü–µ–π—Å–∫–∏–π —É—á–∞—Å—Ç–æ–∫'), ('fire station', '–ø–æ–∂–∞—Ä–Ω–∞—è —Å—Ç–∞–Ω—Ü–∏—è'),
            ('hospital', '–±–æ–ª—å–Ω–∏—Ü–∞'), ('post office', '–ø–æ—á—Ç–æ–≤–æ–µ –æ—Ç–¥–µ–ª–µ–Ω–∏–µ'),
            ('bank', '–±–∞–Ω–∫')
        ],
        'City Life': [
            ('traffic', '–¥–æ—Ä–æ–∂–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ'), ('pedestrian', '–ø–µ—à–µ—Ö–æ–¥'),
            ('public transport', '–æ–±—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç'), ('commute', '–ø–æ–µ–∑–¥–∫–∞ –Ω–∞ —Ä–∞–±–æ—Ç—É'),
            ('skyscraper', '–Ω–µ–±–æ—Å–∫—Ä–µ–±')
        ],
        'Landscapes': [
            ('mountain', '–≥–æ—Ä–∞'), ('river', '—Ä–µ–∫–∞'), ('lake', '–æ–∑–µ—Ä–æ'),
            ('forest', '–ª–µ—Å'), ('desert', '–ø—É—Å—Ç—ã–Ω—è'), ('beach', '–ø–ª—è–∂')
        ],
        'Plants': [
            ('tree', '–¥–µ—Ä–µ–≤–æ'), ('flower', '—Ü–≤–µ—Ç–æ–∫'), ('grass', '—Ç—Ä–∞–≤–∞'),
            ('bush', '–∫—É—Å—Ç'), ('leaf', '–ª–∏—Å—Ç')
        ],
        'Natural Phenomena': [
            ('earthquake', '–∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏–µ'), ('volcano', '–≤—É–ª–∫–∞–Ω'), ('tsunami', '—Ü—É–Ω–∞–º–∏'),
            ('flood', '–Ω–∞–≤–æ–¥–Ω–µ–Ω–∏–µ'), ('drought', '–∑–∞—Å—É—Ö–∞'), ('lightning', '–º–æ–ª–Ω–∏—è')
        ],
        'Computers': [
            ('keyboard', '–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞'), ('mouse', '–º—ã—à—å'), ('screen', '—ç–∫—Ä–∞–Ω'),
            ('laptop', '–Ω–æ—É—Ç–±—É–∫'), ('desktop', '–Ω–∞—Å—Ç–æ–ª—å–Ω—ã–π –∫–æ–º–ø—å—é—Ç–µ—Ä')
        ],
        'Internet': [
            ('website', '–≤–µ–±-—Å–∞–π—Ç'), ('email', '—ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–∞—è –ø–æ—á—Ç–∞'), ('search engine', '–ø–æ–∏—Å–∫–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞'),
            ('social media', '—Å–æ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–µ—Ç–∏'), ('online', '–æ–Ω–ª–∞–π–Ω')
        ],
        'Gadgets': [
            ('smartphone', '—Å–º–∞—Ä—Ç—Ñ–æ–Ω'), ('tablet', '–ø–ª–∞–Ω—à–µ—Ç'), ('headphones', '–Ω–∞—É—à–Ω–∏–∫–∏'),
            ('smartwatch', '—É–º–Ω—ã–µ —á–∞—Å—ã'), ('drone', '–¥—Ä–æ–Ω')
        ],
        'Physics': [
            ('gravity', '–≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è'), ('energy', '—ç–Ω–µ—Ä–≥–∏—è'), ('force', '—Å–∏–ª–∞'),
            ('motion', '–¥–≤–∏–∂–µ–Ω–∏–µ'), ('electricity', '—ç–ª–µ–∫—Ç—Ä–∏—á–µ—Å—Ç–≤–æ')
        ],
        'Chemistry': [
            ('atom', '–∞—Ç–æ–º'), ('molecule', '–º–æ–ª–µ–∫—É–ª–∞'), ('element', '—ç–ª–µ–º–µ–Ω—Ç'),
            ('compound', '—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ'), ('reaction', '—Ä–µ–∞–∫—Ü–∏—è')
        ],
        'Biology': [
            ('cell', '–∫–ª–µ—Ç–∫–∞'), ('gene', '–≥–µ–Ω'), ('organism', '–æ—Ä–≥–∞–Ω–∏–∑–º'),
            ('ecosystem', '—ç–∫–æ—Å–∏—Å—Ç–µ–º–∞'), ('evolution', '—ç–≤–æ–ª—é—Ü–∏—è')
        ],
        'Solar System': [
            ('sun', '—Å–æ–ª–Ω—Ü–µ'), ('moon', '–ª—É–Ω–∞'), ('planet', '–ø–ª–∞–Ω–µ—Ç–∞'),
            ('star', '–∑–≤–µ–∑–¥–∞'), ('galaxy', '–≥–∞–ª–∞–∫—Ç–∏–∫–∞')
        ],
        'Space Exploration': [
            ('astronaut', '–∫–æ—Å–º–æ–Ω–∞–≤—Ç'), ('spaceship', '–∫–æ—Å–º–∏—á–µ—Å–∫–∏–π –∫–æ—Ä–∞–±–ª—å'),
            ('satellite', '—Å–ø—É—Ç–Ω–∏–∫'), ('telescope', '—Ç–µ–ª–µ—Å–∫–æ–ø'), ('universe', '–≤—Å–µ–ª–µ–Ω–Ω–∞—è')
        ],
        'Astronomy': [
            ('constellation', '—Å–æ–∑–≤–µ–∑–¥–∏–µ'), ('observatory', '–æ–±—Å–µ—Ä–≤–∞—Ç–æ—Ä–∏—è'),
            ('celestial body', '–Ω–µ–±–µ—Å–Ω–æ–µ —Ç–µ–ª–æ'), ('comet', '–∫–æ–º–µ—Ç–∞'), ('meteor', '–º–µ—Ç–µ–æ—Ä')
        ],
        'Ancient History': [
            ('pyramid', '–ø–∏—Ä–∞–º–∏–¥–∞'), ('empire', '–∏–º–ø–µ—Ä–∏—è'), ('pharaoh', '—Ñ–∞—Ä–∞–æ–Ω'),
            ('gladiator', '–≥–ª–∞–¥–∏–∞—Ç–æ—Ä'), ('civilization', '—Ü–∏–≤–∏–ª–∏–∑–∞—Ü–∏—è')
        ],
        'Modern History': [
            ('revolution', '—Ä–µ–≤–æ–ª—é—Ü–∏—è'), ('world war', '–º–∏—Ä–æ–≤–∞—è –≤–æ–π–Ω–∞'), ('cold war', '—Ö–æ–ª–æ–¥–Ω–∞—è –≤–æ–π–Ω–∞'),
            ('globalization', '–≥–ª–æ–±–∞–ª–∏–∑–∞—Ü–∏—è'), ('digital age', '—Ü–∏—Ñ—Ä–æ–≤–∞—è —ç–ø–æ—Ö–∞')
        ],
        'Historical Events': [
            ('discovery', '–æ—Ç–∫—Ä—ã—Ç–∏–µ'), ('invention', '–∏–∑–æ–±—Ä–µ—Ç–µ–Ω–∏–µ'), ('treaty', '–¥–æ–≥–æ–≤–æ—Ä'),
            ('battle', '–±–∏—Ç–≤–∞'), ('declaration', '–¥–µ–∫–ª–∞—Ä–∞—Ü–∏—è')
        ],
        'Countries': [
            ('country', '—Å—Ç—Ä–∞–Ω–∞'), ('capital', '—Å—Ç–æ–ª–∏—Ü–∞'), ('continent', '–∫–æ–Ω—Ç–∏–Ω–µ–Ω—Ç'),
            ('ocean', '–æ–∫–µ–∞–Ω'), ('border', '–≥—Ä–∞–Ω–∏—Ü–∞')
        ],
        'Capitals': [
            ('Moscow', '–ú–æ—Å–∫–≤–∞'), ('London', '–õ–æ–Ω–¥–æ–Ω'), ('Paris', '–ü–∞—Ä–∏–∂'),
            ('Berlin', '–ë–µ—Ä–ª–∏–Ω'), ('Tokyo', '–¢–æ–∫–∏–æ')
        ],
        'Landmarks': [
            ('Eiffel Tower', '–≠–π—Ñ–µ–ª–µ–≤–∞ –±–∞—à–Ω—è'), ('Great Wall', '–í–µ–ª–∏–∫–∞—è —Å—Ç–µ–Ω–∞'),
            ('Pyramids of Giza', '–ü–∏—Ä–∞–º–∏–¥—ã –ì–∏–∑—ã'), ('Colosseum', '–ö–æ–ª–∏–∑–µ–π'),
            ('Statue of Liberty', '–°—Ç–∞—Ç—É—è –°–≤–æ–±–æ–¥—ã')
        ],
        'Traditions': [
            ('tradition', '—Ç—Ä–∞–¥–∏—Ü–∏—è'), ('custom', '–æ–±—ã—á–∞–π'), ('ritual', '—Ä–∏—Ç—É–∞–ª'),
            ('ceremony', '—Ü–µ—Ä–µ–º–æ–Ω–∏—è'), ('folklore', '—Ñ–æ–ª—å–∫–ª–æ—Ä')
        ],
        'Customs': [
            ('greeting', '–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ'), ('farewell', '–ø—Ä–æ—â–∞–Ω–∏–µ'), ('dining etiquette', '—Å—Ç–æ–ª–æ–≤—ã–π —ç—Ç–∏–∫–µ—Ç'),
            ('social norms', '—Å–æ—Ü–∏–∞–ª—å–Ω—ã–µ –Ω–æ—Ä–º—ã'), ('taboo', '—Ç–∞–±—É')
        ],
        'Festivals': [
            ('festival', '—Ñ–µ—Å—Ç–∏–≤–∞–ª—å'), ('holiday', '–ø—Ä–∞–∑–¥–Ω–∏–∫'), ('celebration', '–ø—Ä–∞–∑–¥–Ω–æ–≤–∞–Ω–∏–µ'),
            ('parade', '–ø–∞—Ä–∞–¥'), ('carnival', '–∫–∞—Ä–Ω–∞–≤–∞–ª')
        ],
        'Genres': [
            ('novel', '—Ä–æ–º–∞–Ω'), ('poem', '—Å—Ç–∏—Ö–æ—Ç–≤–æ—Ä–µ–Ω–∏–µ'), ('play', '–ø—å–µ—Å–∞'),
            ('short story', '–∫–æ—Ä–æ—Ç–∫–∏–π —Ä–∞—Å—Å–∫–∞–∑'), ('essay', '—ç—Å—Å–µ')
        ],
        'Authors': [
            ('writer', '–ø–∏—Å–∞—Ç–µ–ª—å'), ('poet', '–ø–æ—ç—Ç'), ('dramatist', '–¥—Ä–∞–º–∞—Ç—É—Ä–≥'),
            ('novelist', '—Ä–æ–º–∞–Ω–∏—Å—Ç'), ('biographer', '–±–∏–æ–≥—Ä–∞—Ñ')
        ],
        'Literary Terms': [
            ('plot', '—Å—é–∂–µ—Ç'), ('character', '–ø–µ—Ä—Å–æ–Ω–∞–∂'), ('theme', '—Ç–µ–º–∞'),
            ('metaphor', '–º–µ—Ç–∞—Ñ–æ—Ä–∞'), ('symbolism', '—Å–∏–º–≤–æ–ª–∏–∑–º')
        ],
        'Art Forms': [
            ('painting', '–∂–∏–≤–æ–ø–∏—Å—å'), ('sculpture', '—Å–∫—É–ª—å–ø—Ç—É—Ä–∞'), ('drawing', '—Ä–∏—Å—É–Ω–æ–∫'),
            ('photography', '—Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è'), ('architecture', '–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞')
        ],
        'Artists': [
            ('painter', '—Ö—É–¥–æ–∂–Ω–∏–∫'), ('sculptor', '—Å–∫—É–ª—å–ø—Ç–æ—Ä'), ('photographer', '—Ñ–æ—Ç–æ–≥—Ä–∞—Ñ'),
            ('architect', '–∞—Ä—Ö–∏—Ç–µ–∫—Ç–æ—Ä'), ('musician', '–º—É–∑—ã–∫–∞–Ω—Ç')
        ],
        'Art History': [
            ('Renaissance', '–í–æ–∑—Ä–æ–∂–¥–µ–Ω–∏–µ'), ('Baroque', '–ë–∞—Ä–æ–∫–∫–æ'), ('Impressionism', '–ò–º–ø—Ä–µ—Å—Å–∏–æ–Ω–∏–∑–º'),
            ('Cubism', '–ö—É–±–∏–∑–º'), ('Surrealism', '–°—é—Ä—Ä–µ–∞–ª–∏–∑–º')
        ],
        'News': [
            ('headline', '–∑–∞–≥–æ–ª–æ–≤–æ–∫'), ('reporter', '—Ä–µ–ø–æ—Ä—Ç–µ—Ä'), ('article', '—Å—Ç–∞—Ç—å—è'),
            ('broadcast', '—Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—è'), ('journalism', '–∂—É—Ä–Ω–∞–ª–∏—Å—Ç–∏–∫–∞')
        ],
        'Entertainment': [
            ('movie', '—Ñ–∏–ª—å–º'), ('music', '–º—É–∑—ã–∫–∞'), ('theater', '—Ç–µ–∞—Ç—Ä'),
            ('concert', '–∫–æ–Ω—Ü–µ—Ä—Ç'), ('game', '–∏–≥—Ä–∞')
        ],
        'Social Media': [
            ('post', '–ø–æ—Å—Ç'), ('like', '–ª–∞–π–∫'), ('share', '–ø–æ–¥–µ–ª–∏—Ç—å—Å—è'),
            ('follower', '–ø–æ–¥–ø–∏—Å—á–∏–∫'), ('hashtag', '—Ö–µ—à—Ç–µ–≥')
        ],
        'Companies': [
            ('company', '–∫–æ–º–ø–∞–Ω–∏—è'), ('corporation', '–∫–æ—Ä–ø–æ—Ä–∞—Ü–∏—è'), ('startup', '—Å—Ç–∞—Ä—Ç–∞–ø'),
            ('business', '–±–∏–∑–Ω–µ—Å'), ('enterprise', '–ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏–µ')
        ],
        'Marketing': [
            ('advertisement', '—Ä–µ–∫–ª–∞–º–∞'), ('brand', '–±—Ä–µ–Ω–¥'), ('customer', '–∫–ª–∏–µ–Ω—Ç'),
            ('sales', '–ø—Ä–æ–¥–∞–∂–∏'), ('promotion', '–ø—Ä–æ–¥–≤–∏–∂–µ–Ω–∏–µ')
        ],
        'Management': [
            ('manager', '–º–µ–Ω–µ–¥–∂–µ—Ä'), ('leadership', '–ª–∏–¥–µ—Ä—Å—Ç–≤–æ'), ('teamwork', '–∫–æ–º–∞–Ω–¥–Ω–∞—è —Ä–∞–±–æ—Ç–∞'),
            ('strategy', '—Å—Ç—Ä–∞—Ç–µ–≥–∏—è'), ('project', '–ø—Ä–æ–µ–∫—Ç')
        ],
        'Economics': [
            ('economy', '—ç–∫–æ–Ω–æ–º–∏–∫–∞'), ('supply and demand', '—Å–ø—Ä–æ—Å –∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ'),
            ('inflation', '–∏–Ω—Ñ–ª—è—Ü–∏—è'), ('recession', '—Ä–µ—Ü–µ—Å—Å–∏—è'), ('market', '—Ä—ã–Ω–æ–∫')
        ],
        'Finance': [
            ('money', '–¥–µ–Ω—å–≥–∏'), ('bank', '–±–∞–Ω–∫'), ('investment', '–∏–Ω–≤–µ—Å—Ç–∏—Ü–∏—è'),
            ('budget', '–±—é–¥–∂–µ—Ç'), ('stock market', '—Ñ–æ–Ω–¥–æ–≤—ã–π —Ä—ã–Ω–æ–∫')
        ],
        'Trade': [
            ('export', '—ç–∫—Å–ø–æ—Ä—Ç'), ('import', '–∏–º–ø–æ—Ä—Ç'), ('tariff', '—Ç–∞—Ä–∏—Ñ'),
            ('global trade', '–º–∏—Ä–æ–≤–∞—è —Ç–æ—Ä–≥–æ–≤–ª—è'), ('agreement', '—Å–æ–≥–ª–∞—à–µ–Ω–∏–µ')
        ],
        'Government': [
            ('government', '–ø—Ä–∞–≤–∏—Ç–µ–ª—å—Å—Ç–≤–æ'), ('president', '–ø—Ä–µ–∑–∏–¥–µ–Ω—Ç'), ('parliament', '–ø–∞—Ä–ª–∞–º–µ–Ω—Ç'),
            ('democracy', '–¥–µ–º–æ–∫—Ä–∞—Ç–∏—è'), ('constitution', '–∫–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏—è')
        ],
        'Elections': [
            ('election', '–≤—ã–±–æ—Ä—ã'), ('vote', '–≥–æ–ª–æ—Å–æ–≤–∞—Ç—å'), ('candidate', '–∫–∞–Ω–¥–∏–¥–∞—Ç'),
            ('campaign', '–∫–∞–º–ø–∞–Ω–∏—è'), ('ballot', '–∏–∑–±–∏—Ä–∞—Ç–µ–ª—å–Ω—ã–π –±—é–ª–ª–µ—Ç–µ–Ω—å')
        ],
        'International Relations': [
            ('diplomacy', '–¥–∏–ø–ª–æ–º–∞—Ç–∏—è'), ('treaty', '–¥–æ–≥–æ–≤–æ—Ä'), ('alliance', '–∞–ª—å—è–Ω—Å'),
            ('conflict', '–∫–æ–Ω—Ñ–ª–∏–∫—Ç'), ('peace', '–º–∏—Ä')
        ],
        'Diseases': [
            ('disease', '–±–æ–ª–µ–∑–Ω—å'), ('symptom', '—Å–∏–º–ø—Ç–æ–º'), ('infection', '–∏–Ω—Ñ–µ–∫—Ü–∏—è'),
            ('virus', '–≤–∏—Ä—É—Å'), ('bacteria', '–±–∞–∫—Ç–µ—Ä–∏–∏')
        ],
        'Treatment': [
            ('medicine', '–ª–µ–∫–∞—Ä—Å—Ç–≤–æ'), ('therapy', '—Ç–µ—Ä–∞–ø–∏—è'), ('surgery', '—Ö–∏—Ä—É—Ä–≥–∏—è'),
            ('vaccine', '–≤–∞–∫—Ü–∏–Ω–∞'), ('diagnosis', '–¥–∏–∞–≥–Ω–æ–∑')
        ],
        'Healthcare': [
            ('hospital', '–±–æ–ª—å–Ω–∏—Ü–∞'), ('doctor', '–≤—Ä–∞—á'), ('nurse', '–º–µ–¥—Å–µ—Å—Ç—Ä–∞'),
            ('patient', '–ø–∞—Ü–∏–µ–Ω—Ç'), ('clinic', '–∫–ª–∏–Ω–∏–∫–∞')
        ],
        'Legal System': [
            ('law', '–∑–∞–∫–æ–Ω'), ('court', '—Å—É–¥'), ('judge', '—Å—É–¥—å—è'),
            ('lawyer', '–∞–¥–≤–æ–∫–∞—Ç'), ('justice', '—Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ—Å—Ç—å')
        ],
        'Rights': [
            ('right', '–ø—Ä–∞–≤–æ'), ('freedom', '—Å–≤–æ–±–æ–¥–∞'), ('equality', '—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ'),
            ('human rights', '–ø—Ä–∞–≤–∞ —á–µ–ª–æ–≤–µ–∫–∞'), ('citizen', '–≥—Ä–∞–∂–¥–∞–Ω–∏–Ω')
        ],
        'Crimes': [
            ('crime', '–ø—Ä–µ—Å—Ç—É–ø–ª–µ–Ω–∏–µ'), ('theft', '–∫—Ä–∞–∂–∞'), ('murder', '—É–±–∏–π—Å—Ç–≤–æ'),
            ('fraud', '–º–æ—à–µ–Ω–Ω–∏—á–µ—Å—Ç–≤–æ'), ('arrest', '–∞—Ä–µ—Å—Ç')
        ],
        'Education System': [
            ('school', '—à–∫–æ–ª–∞'), ('university', '—É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç'), ('curriculum', '—É—á–µ–±–Ω—ã–π –ø–ª–∞–Ω'),
            ('grade', '–æ—Ü–µ–Ω–∫–∞'), ('diploma', '–¥–∏–ø–ª–æ–º')
        ],
        'Learning': [
            ('learn', '—É—á–∏—Ç—å—Å—è'), ('knowledge', '–∑–Ω–∞–Ω–∏–µ'), ('skill', '–Ω–∞–≤—ã–∫'),
            ('practice', '–ø—Ä–∞–∫—Ç–∏–∫–∞'), ('understand', '–ø–æ–Ω–∏–º–∞—Ç—å')
        ],
        'Teaching': [
            ('teach', '—É—á–∏—Ç—å'), ('teacher', '—É—á–∏—Ç–µ–ª—å'), ('lesson', '—É—Ä–æ–∫'),
            ('classroom', '–∫–ª–∞—Å—Å–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞'), ('pedagogy', '–ø–µ–¥–∞–≥–æ–≥–∏–∫–∞')
        ],
        'Philosophical Concepts': [
            ('existence', '—Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ'), ('truth', '–∏—Å—Ç–∏–Ω–∞'), ('reality', '—Ä–µ–∞–ª—å–Ω–æ—Å—Ç—å'),
            ('knowledge', '–∑–Ω–∞–Ω–∏–µ'), ('morality', '–º–æ—Ä–∞–ª—å')
        ],
        'Philosophers': [
            ('Plato', '–ü–ª–∞—Ç–æ–Ω'), ('Aristotle', '–ê—Ä–∏—Å—Ç–æ—Ç–µ–ª—å'), ('Kant', '–ö–∞–Ω—Ç'),
            ('Nietzsche', '–ù–∏—Ü—à–µ'), ('Socrates', '–°–æ–∫—Ä–∞—Ç')
        ],
        'Ethics': [
            ('ethics', '—ç—Ç–∏–∫–∞'), ('virtue', '–¥–æ–±—Ä–æ–¥–µ—Ç–µ–ª—å'), ('justice', '—Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ—Å—Ç—å'),
            ('duty', '–¥–æ–ª–≥'), ('conscience', '—Å–æ–≤–µ—Å—Ç—å')
        ],
        'Mental Processes': [
            ('thought', '–º—ã—Å–ª—å'), ('memory', '–ø–∞–º—è—Ç—å'), ('perception', '–≤–æ—Å–ø—Ä–∏—è—Ç–∏–µ'),
            ('emotion', '—ç–º–æ—Ü–∏—è'), ('cognition', '–ø–æ–∑–Ω–∞–Ω–∏–µ')
        ],
        'Behavior': [
            ('behavior', '–ø–æ–≤–µ–¥–µ–Ω–∏–µ'), ('habit', '–ø—Ä–∏–≤—ã—á–∫–∞'), ('reaction', '—Ä–µ–∞–∫—Ü–∏—è'),
            ('instinct', '–∏–Ω—Å—Ç–∏–Ω–∫—Ç'), ('adaptation', '–∞–¥–∞–ø—Ç–∞—Ü–∏—è')
        ],
        'Personality': [
            ('personality', '–ª–∏—á–Ω–æ—Å—Ç—å'), ('trait', '—á–µ—Ä—Ç–∞ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∞'), ('temperament', '—Ç–µ–º–ø–µ—Ä–∞–º–µ–Ω—Ç'),
            ('character', '—Ö–∞—Ä–∞–∫—Ç–µ—Ä'), ('self-esteem', '—Å–∞–º–æ–æ—Ü–µ–Ω–∫–∞')
        ],
        'Society': [
            ('society', '–æ–±—â–µ—Å—Ç–≤–æ'), ('culture', '–∫—É–ª—å—Ç—É—Ä–∞'), ('community', '—Å–æ–æ–±—â–µ—Å—Ç–≤–æ'),
            ('institution', '–∏–Ω—Å—Ç–∏—Ç—É—Ç'), ('social norm', '—Å–æ—Ü–∏–∞–ª—å–Ω–∞—è –Ω–æ—Ä–º–∞')
        ],
        'Social Groups': [
            ('family', '—Å–µ–º—å—è'), ('peer group', '–≥—Ä—É–ø–ø–∞ —Å–≤–µ—Ä—Å—Ç–Ω–∏–∫–æ–≤'), ('organization', '–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è'),
            ('class', '–∫–ª–∞—Å—Å (—Å–æ—Ü–∏–∞–ª—å–Ω—ã–π)'), ('nation', '–Ω–∞—Ü–∏—è')
        ],
        'Social Issues': [
            ('poverty', '–±–µ–¥–Ω–æ—Å—Ç—å'), ('inequality', '–Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ'), ('crime', '–ø—Ä–µ—Å—Ç—É–ø–Ω–æ—Å—Ç—å'),
            ('discrimination', '–¥–∏—Å–∫—Ä–∏–º–∏–Ω–∞—Ü–∏—è'), ('unemployment', '–±–µ–∑—Ä–∞–±–æ—Ç–∏—Ü–∞')
        ]
    }

    with app.app_context():
        # –û—á–∏—Å—Ç–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        TestWord.query.delete()
        Test.query.delete()
        Word.query.delete()
        User.query.delete()
        db.session.commit() # –ö–æ–º–º–∏—Ç –¥–ª—è –æ—á–∏—Å—Ç–∫–∏

        # –°–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É—á–∏—Ç–µ–ª—è
        hashed_teacher_password = generate_password_hash('teacher')
        teacher = User(
            fio='–¢–µ—Å—Ç–æ–≤—ã–π –£—á–∏—Ç–µ–ª—å',
            nick='teacher',
            password=hashed_teacher_password,
            teacher='yes'
        )
        db.session.add(teacher)
        db.session.commit()

        # –°–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Å—Ç—É–¥–µ–Ω—Ç–∞
        hashed_student_password = generate_password_hash('student')
        student = User(
            fio='–¢–µ—Å—Ç–æ–≤—ã–π –°—Ç—É–¥–µ–Ω—Ç',
            nick='student',
            password=hashed_student_password,
            teacher='no',
            class_number='1'
        )
        db.session.add(student)
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –¥–∞–Ω–Ω—ã–º–∏: –Ω–∏–∫ "a", –ø–∞—Ä–æ–ª—å "a", –∫–ª–∞—Å—Å "10", –§–ò–û "a a a"
        hashed_a_password = generate_password_hash('a')
        user_a = User(
            fio='a a a',
            nick='a',
            password=hashed_a_password,
            teacher='no',
            class_number='10'
        )
        db.session.add(user_a)
        db.session.commit()

        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ª–æ–≤ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        for class_num in classes:
            for unit in units[class_num]:
                for module in modules[unit]:
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–ª–æ–≤–∞ –∏–∑ —Å–ª–æ–≤–∞—Ä—è test_words
                    if module in test_words:
                        words_to_add = test_words[module]
                    else:
                        # –ï—Å–ª–∏ –º–æ–¥—É–ª—è –Ω–µ—Ç –≤ —Å–ª–æ–≤–∞—Ä–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º –±–∞–∑–æ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –æ—à–∏–±–æ–∫
                        print(f"Warning: Module '{module}' not found in test_words. Using 'Basic Greetings' words.")
                        words_to_add = test_words['Basic Greetings'] # Fallback
                    
                    for word_en, word_ru in words_to_add:
                        new_word = Word(
                            word=word_en,
                            perevod=word_ru,
                            classs=class_num,
                            unit=unit,
                            module=module
                        )
                        db.session.add(new_word)
        db.session.commit() # –ö–æ–º–º–∏—Ç –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤—Å–µ—Ö —Å–ª–æ–≤

        # –°–æ–∑–¥–∞–Ω–∏–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ç–µ—Å—Ç–æ–≤ –¥–ª—è 10 –∫–ª–∞—Å—Å–∞
        test_class = '10'
        
        # –¢–∏–ø—ã —Ç–µ—Å—Ç–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è
        test_types = [
            {'type': 'dictation', 'title_prefix': '–î–∏–∫—Ç–∞–Ω—Ç'},
            {'type': 'add_letter', 'title_prefix': '–î–æ–±–∞–≤–∏—Ç—å –±—É–∫–≤—É'},
            {'type': 'true_false', 'title_prefix': '–ü—Ä–∞–≤–¥–∞/–õ–æ–∂—å'},
            {'type': 'multiple_choice_single', 'title_prefix': '–í—ã–±–æ—Ä –æ—Ç–≤–µ—Ç–∞'},
            {'type': 'fill_word', 'title_prefix': '–ó–∞–ø–æ–ª–Ω–∏—Ç—å —Å–ª–æ–≤–æ'}
        ]
        
        # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç—ã –¥–ª—è –≤—Å–µ—Ö –º–æ–¥—É–ª–µ–π 10 –∫–ª–∞—Å—Å–∞
        for unit in units[test_class]:
            for module in modules[unit]:
                # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç—ã —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –º–æ–¥—É–ª—è
                for test_type_info in test_types:
                    test_link = generate_test_link()
                    
                    test = Test(
                        title=f'{test_type_info["title_prefix"]}: {module} ({unit})',
                        classs=test_class,
                        unit=unit,
                        module=module,
                        type=test_type_info['type'],
                        link=test_link,
                        created_by=teacher.id,
                        is_active=True,
                        word_order='random'
                    )
                    db.session.add(test)
                    db.session.commit()

                    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ª–æ–≤ –≤ —Ç–µ—Å—Ç –∏–∑ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –º–æ–¥—É–ª—è
                    words_for_test = Word.query.filter_by(
                        classs=test_class,
                        unit=unit,
                        module=module
                    ).all()

                    if not words_for_test:
                        print(f"Warning: No words found for test module '{module}'. Test will be empty.")
                        continue

                    for idx, word_obj in enumerate(words_for_test):
                        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —Ç–µ—Å—Ç–∞
                        test_word_data = {
                            'test_id': test.id,
                            'word': word_obj.word,
                            'perevod': word_obj.perevod,
                            'correct_answer': word_obj.word,
                            'word_order': idx
                        }
                        
                        # –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ —Ç–µ—Å—Ç–æ–≤
                        if test_type_info['type'] == 'add_letter':
                            # –î–ª—è —Ç–µ—Å—Ç–∞ "–¥–æ–±–∞–≤–∏—Ç—å –±—É–∫–≤—É" —Å–æ–∑–¥–∞–µ–º —Å–ª–æ–≤–æ —Å –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–º–∏ –±—É–∫–≤–∞–º–∏
                            word_with_gaps = create_word_with_missing_letters(word_obj.word)
                            test_word_data['missing_letters'] = word_with_gaps
                            test_word_data['word'] = word_with_gaps
                        elif test_type_info['type'] == 'multiple_choice_single':
                            # –î–ª—è –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞ —Å–æ–∑–¥–∞–µ–º –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤
                            options = create_multiple_choice_options(word_obj.word, words_for_test)
                            test_word_data['options'] = options
                        elif test_type_info['type'] == 'true_false':
                            # –î–ª—è –ø—Ä–∞–≤–¥–∞/–ª–æ–∂—å –∏–Ω–æ–≥–¥–∞ –¥–µ–ª–∞–µ–º –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥
                            if random.choice([True, False]):
                                # –°–æ–∑–¥–∞–µ–º –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥
                                wrong_translation = create_wrong_translation(word_obj.perevod, words_for_test)
                                test_word_data['perevod'] = wrong_translation
                                test_word_data['correct_answer'] = 'False'
                            else:
                                test_word_data['correct_answer'] = 'True'
                        
                        test_word = TestWord(**test_word_data)
                        db.session.add(test_word)
                    
                    print(f"Created test: {test.title} with {len(words_for_test)} words")
        
        db.session.commit() # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤—Å–µ—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π
        print("Test data has been successfully loaded into the database!")

if __name__ == "__main__":
    with app.app_context():
        generate_test_data()


test_time_formatting.py (/home/amir/Documents/Info/Duckly/test_time_formatting.py):
#!/usr/bin/env python3
"""
–¢–µ—Å—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤.
"""

def format_time_taken(minutes):
    """
    –ë–µ–∑–æ–ø–∞—Å–Ω–æ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–µ—Å—Ç–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.
    
    Args:
        minutes: –í—Ä–µ–º—è –≤ –º–∏–Ω—É—Ç–∞—Ö (–º–æ–∂–µ—Ç –±—ã—Ç—å None, 0 –∏–ª–∏ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º)
    
    Returns:
        str: –û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –≤—Ä–µ–º–µ–Ω–∏
    """
    if minutes is None or minutes < 0:
        return "0 –º–∏–Ω"
    
    if minutes == 0:
        return "<1 –º–∏–Ω"
    
    hours = minutes // 60
    remaining_minutes = minutes % 60
    
    if hours == 0:
        return f"{remaining_minutes} –º–∏–Ω"
    elif remaining_minutes == 0:
        return f"{hours} —á"
    else:
        return f"{hours} —á {remaining_minutes} –º–∏–Ω"

def test_time_formatting():
    """–¢–µ—Å—Ç–∏—Ä—É–µ—Ç —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Å–ª—É—á–∞–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏."""
    test_cases = [
        (None, "0 –º–∏–Ω"),
        (-5, "0 –º–∏–Ω"),
        (0, "<1 –º–∏–Ω"),
        (1, "1 –º–∏–Ω"),
        (5, "5 –º–∏–Ω"),
        (59, "59 –º–∏–Ω"),
        (60, "1 —á"),
        (61, "1 —á 1 –º–∏–Ω"),
        (65, "1 —á 5 –º–∏–Ω"),
        (120, "2 —á"),
        (125, "2 —á 5 –º–∏–Ω"),
        (180, "3 —á"),
        (185, "3 —á 5 –º–∏–Ω")
    ]
    
    print("–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ format_time_taken:")
    print("=" * 50)
    
    all_passed = True
    for input_minutes, expected in test_cases:
        result = format_time_taken(input_minutes)
        status = "‚úì" if result == expected else "‚úó"
        if result != expected:
            all_passed = False
        print(f"{status} {input_minutes} –º–∏–Ω -> '{result}' (–æ–∂–∏–¥–∞–ª–æ—Å—å: '{expected}')")
    
    print("=" * 50)
    if all_passed:
        print("‚úì –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—à–ª–∏ —É—Å–ø–µ—à–Ω–æ!")
    else:
        print("‚úó –ù–µ–∫–æ—Ç–æ—Ä—ã–µ —Ç–µ—Å—Ç—ã –Ω–µ –ø—Ä–æ—à–ª–∏!")
    
    return all_passed

if __name__ == "__main__":
    test_time_formatting()

blueprints (/home/amir/Documents/Info/Duckly/blueprints):


create_db.py (/home/amir/Documents/Info/Duckly/create_db.py):
from site_1 import app, db

with app.app_context():
    db.create_all()
    print("Database tables created successfully.")


Dockerfile (/home/amir/Documents/Info/Duckly/Dockerfile):
FROM python:3.9-slim

WORKDIR /app
COPY . .

# Print confirmation message and show directory structure
RUN echo "Files successfully copied to container!" && \
    find /app -type f -not -path "*/\.*" | sort

# Create instance directory for SQLite database
RUN mkdir -p /app/instance && \
    touch /app/instance/app.db && \
    chmod 777 /app/instance/app.db

# Create directory for Flask sessions
RUN mkdir -p /app/flask_session && \
    chmod 777 /app/flask_session

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
RUN pip install --no-cache-dir -r requirements.txt

# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è
ENV PYTHONUNBUFFERED=1
ENV FLASK_ENV=production
ENV FLASK_APP=site_1.py

EXPOSE 1800

# –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è —Å —è–≤–Ω—ã–º —É–∫–∞–∑–∞–Ω–∏–µ–º —Ö–æ—Å—Ç–∞ –∏ –ø–æ—Ä—Ç–∞
CMD ["python", "site_1.py"]

fix_static_urls.py (/home/amir/Documents/Info/Duckly/fix_static_urls.py):
#!/usr/bin/env python3
import os
import re

def fix_static_urls(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        content = file.read()
    
    # –ó–∞–º–µ–Ω—è–µ–º {{ /static/... }} –Ω–∞ /static/...
    content = re.sub(r"{{ /static/([^}]+) }}", r"/static/\1", content)
    
    with open(file_path, 'w', encoding='utf-8') as file:
        file.write(content)

def process_templates():
    templates_dir = '/home/amir/Documents/Info/Duckly/templates'
    for root, _, files in os.walk(templates_dir):
        for file in files:
            if file.endswith('.html'):
                file_path = os.path.join(root, file)
                print(f"Processing {file_path}")
                fix_static_urls(file_path)

if __name__ == "__main__":
    process_templates()
    print("Static URL fixes completed!")

fix_urls.py (/home/amir/Documents/Info/Duckly/fix_urls.py):
#!/usr/bin/env python3
import os
import re

def fix_static_urls(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        content = file.read()
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('static', filename='...') –Ω–∞ /static/...
    content = re.sub(r"url_for\('static', filename='([^']+)'\)", r"/static/\1", content)
    content = re.sub(r'url_for\("static", filename="([^"]+)"\)', r'/static/\1', content)
    
    with open(file_path, 'w', encoding='utf-8') as file:
        file.write(content)

def fix_route_urls(file_path):
    with open(file_path, 'r', encoding='utf-8') as file:
        content = file.read()
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('hello') –Ω–∞ /hello
    content = re.sub(r"url_for\('hello'\)", r'"/hello"', content)
    content = re.sub(r'url_for\("hello"\)', r'"/hello"', content)
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('tests') –Ω–∞ /tests
    content = re.sub(r"url_for\('tests'\)", r'"/tests"', content)
    content = re.sub(r'url_for\("tests"\)', r'"/tests"', content)
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('games') –Ω–∞ /games
    content = re.sub(r"url_for\('games'\)", r'"/games"', content)
    content = re.sub(r'url_for\("games"\)', r'"/games"', content)
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('flashcards_select_module') –Ω–∞ /flashcards_select_module
    content = re.sub(r"url_for\('flashcards_select_module'\)", r'"/flashcards_select_module"', content)
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('word_match_select_module') –Ω–∞ /word_match_select_module
    content = re.sub(r"url_for\('word_match_select_module'\)", r'"/word_match_select_module"', content)
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('sentence_scramble_select_module') –Ω–∞ /sentence_scramble_select_module
    content = re.sub(r"url_for\('sentence_scramble_select_module'\)", r'"/sentence_scramble_select_module"', content)
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('add_tests') –Ω–∞ /add_tests
    content = re.sub(r"url_for\('add_tests'\)", r'"/add_tests"', content)
    
    # –ó–∞–º–µ–Ω—è–µ–º url_for('create_test') –Ω–∞ /create_test
    content = re.sub(r"url_for\('create_test'\)", r'"/create_test"', content)
    
    with open(file_path, 'w', encoding='utf-8') as file:
        file.write(content)

def process_templates():
    templates_dir = '/home/amir/Documents/Info/Duckly/templates'
    for root, _, files in os.walk(templates_dir):
        for file in files:
            if file.endswith('.html'):
                file_path = os.path.join(root, file)
                print(f"Processing {file_path}")
                fix_static_urls(file_path)
                fix_route_urls(file_path)

if __name__ == "__main__":
    process_templates()
    print("URL fixes completed!")

flask_session (/home/amir/Documents/Info/Duckly/flask_session):


GAME_IMPROVEMENTS.md (/home/amir/Documents/Info/Duckly/GAME_IMPROVEMENTS.md):
# –£–ª—É—á—à–µ–Ω–∏—è –∏–≥—Ä—ã "–°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –°–ª–æ–≤"

## –†–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ —Ñ–∞–π–ª–∞ ideas

### 1. –£–ª—É—á—à–µ–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –≤—ã–±–æ—Ä–∞ –º–æ–¥—É–ª—è (game_word_match_select.html)

#### ‚úÖ –†–µ–∂–∏–º—ã –≤—ã–±–æ—Ä–∞:
- **–ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –º–æ–¥—É–ª—å** - –≤—ã–±–æ—Ä –∫–ª–∞—Å—Å–∞ ‚Üí —é–Ω–∏—Ç–∞ ‚Üí –º–æ–¥—É–ª—è
- **–í–µ—Å—å —é–Ω–∏—Ç** - –≤—ã–±–æ—Ä –∫–ª–∞—Å—Å–∞ ‚Üí —é–Ω–∏—Ç–∞ (–≤—Å–µ –º–æ–¥—É–ª–∏ –≤–∫–ª—é—á–µ–Ω—ã)
- **–í–µ—Å—å –∫–ª–∞—Å—Å** - –≤—ã–±–æ—Ä —Ç–æ–ª—å–∫–æ –∫–ª–∞—Å—Å–∞ (–≤—Å–µ —é–Ω–∏—Ç—ã –∏ –º–æ–¥—É–ª–∏)
- **–ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –≤—ã–±–æ—Ä** - –≤—ã–±–æ—Ä –Ω–µ—Å–∫–æ–ª—å–∫–∏—Ö –º–æ–¥—É–ª–µ–π –∏–∑ —é–Ω–∏—Ç–∞

#### ‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∫–∞—Ä—Ç–æ—á–µ–∫:
- –°–ª–∞–π–¥–µ—Ä –¥–ª—è –≤—ã–±–æ—Ä–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–∞—Ä—Ç–æ—á–µ–∫ (4-20)
- –ü–æ–ª–µ –≤–≤–æ–¥–∞ –¥–ª—è —Ç–æ—á–Ω–æ–≥–æ —á–∏—Å–ª–∞ –∫–∞—Ä—Ç–æ—á–µ–∫
- –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∞—Ü–∏—è —Å–ª–∞–π–¥–µ—Ä–∞ –∏ –ø–æ–ª—è –≤–≤–æ–¥–∞
- –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ –ø–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤—É –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–ª–æ–≤
- –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –≤—ã–±–æ—Ä–∞ –Ω–µ—á–µ—Ç–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –∫–∞—Ä—Ç–æ—á–µ–∫ (step="1")

#### ‚úÖ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≤—Ä–µ–º–µ–Ω–∏:
- **–¢–∞–π–º–µ—Ä** —Å –ø—Ä–µ–¥—É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–º–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ (30 —Å–µ–∫, 1 –º–∏–Ω, 2 –º–∏–Ω, 3 –º–∏–Ω, 5 –º–∏–Ω, 10 –º–∏–Ω)
- **–°–µ–∫—É–Ω–¥–æ–º–µ—Ä** –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –∏–≥—Ä—ã
- –ö–æ–Ω—Ñ–ª–∏–∫—Ç-—Ä–µ–∑–æ–ª—é—Ü–∏—è: –Ω–µ–ª—å–∑—è –≤–∫–ª—é—á–∏—Ç—å —Ç–∞–π–º–µ—Ä –∏ —Å–µ–∫—É–Ω–¥–æ–º–µ—Ä –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ

#### ‚úÖ –£–ª—É—á—à–µ–Ω–Ω—ã–π –¥–∏–∑–∞–π–Ω:
- –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –º–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π –¥–∏–∑–∞–π–Ω
- –ü–ª–∞–≤–Ω—ã–µ –∞–Ω–∏–º–∞—Ü–∏–∏ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫
- –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã —Å –≤–∏–∑—É–∞–ª—å–Ω–æ–π –æ–±—Ä–∞—Ç–Ω–æ–π —Å–≤—è–∑—å—é
- –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ–¥ –º–æ–±–∏–ª—å–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
- Google Fonts –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è —Ç–∏–ø–æ–≥—Ä–∞—Ñ–∏–∫–∏

### 2. –£–ª—É—á—à–µ–Ω–Ω–∞—è –∏–≥—Ä–∞ —Å –∫—Ä–∞—Å–∏–≤—ã–º–∏ —Å–≤—è–∑—è–º–∏ (game_word_match.html)

#### ‚úÖ –í–∏–∑—É–∞–ª—å–Ω—ã–µ —É–ª—É—á—à–µ–Ω–∏—è:
- **–ö—Ä–∞—Å–∏–≤—ã–µ –∫—Ä–∏–≤—ã–µ —Å–≤—è–∑–∏** –º–µ–∂–¥—É –∫–∞—Ä—Ç–æ—á–∫–∞–º–∏ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º SVG –∏ –∫—Ä–∏–≤—ã—Ö –ë–µ–∑—å–µ
- **–ì—Ä–∞–¥–∏–µ–Ω—Ç–Ω—ã–µ —Å–≤—è–∑–∏** - –∑–µ–ª–µ–Ω—ã–µ –¥–ª—è –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö, –∫—Ä–∞—Å–Ω—ã–µ –¥–ª—è –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö
- **–ê–Ω–∏–º–∞—Ü–∏–∏ –ø–æ—è–≤–ª–µ–Ω–∏—è** —Å–≤—è–∑–µ–π —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è –ª–∏–Ω–∏–∏
- **–ü–æ–¥—Å–≤–µ—Ç–∫–∞ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –∫–∞—Ä—Ç–æ—á–µ–∫** —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º –ø—É–ª—å—Å–∞—Ü–∏–∏
- **–≠—Ñ—Ñ–µ–∫—Ç—ã –Ω–∞–≤–µ–¥–µ–Ω–∏—è** –Ω–∞ –∫–∞—Ä—Ç–æ—á–∫–∏

#### ‚úÖ –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:
- **–í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –∏–∑–º–µ–Ω—è—Ç—å –≤—ã–±–æ—Ä** –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –æ–¥–Ω–æ–≥–æ —Å—Ç–æ–ª–±—Ü–∞
- **–°–∏—Å—Ç–µ–º–∞ —Ä–∞–∑—Ä—ã–≤–∞ —Å–≤—è–∑–µ–π** - –∫–ª–∏–∫ –Ω–∞ —Å–≤—è–∑–∞–Ω–Ω—É—é –∫–∞—Ä—Ç–æ—á–∫—É —Ä–∞–∑—Ä—ã–≤–∞–µ—Ç —Å–≤—è–∑—å
- **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –∫–æ—Ä—Ä–µ–∫—Ü–∏—è —Å—á–µ—Ç–∞** –ø—Ä–∏ —Ä–∞–∑—Ä—ã–≤–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö —Å–≤—è–∑–µ–π
- **–ü–ª–∞–≤–Ω—ã–µ –ø–µ—Ä–µ—Ö–æ–¥—ã** –º–µ–∂–¥—É —Å–æ—Å—Ç–æ—è–Ω–∏—è–º–∏ –∫–∞—Ä—Ç–æ—á–µ–∫

#### ‚úÖ –§—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å —Ç–∞–π–º–µ—Ä–∞/—Å–µ–∫—É–Ω–¥–æ–º–µ—Ä–∞:
- **–¢–∞–π–º–µ—Ä** —Å –æ–±—Ä–∞—Ç–Ω—ã–º –æ—Ç—Å—á–µ—Ç–æ–º –∏ —Ü–≤–µ—Ç–æ–≤–æ–π –∏–Ω–¥–∏–∫–∞—Ü–∏–µ–π (–∑–µ–ª–µ–Ω—ã–π ‚Üí –∂–µ–ª—Ç—ã–π ‚Üí –∫—Ä–∞—Å–Ω—ã–π)
- **–°–µ–∫—É–Ω–¥–æ–º–µ—Ä** —Å –ø—Ä—è–º—ã–º –æ—Ç—Å—á–µ—Ç–æ–º –≤ —Ñ–æ—Ä–º–∞—Ç–µ MM:SS
- **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ** –∏–≥—Ä—ã –ø—Ä–∏ –∏—Å—Ç–µ—á–µ–Ω–∏–∏ –≤—Ä–µ–º–µ–Ω–∏
- **–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –≤—Ä–µ–º–µ–Ω–∏** –≤ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞—Ö –∏–≥—Ä—ã

#### ‚úÖ –°–∏—Å—Ç–µ–º–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤:
- **–î–µ—Ç–∞–ª—å–Ω–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞**: –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø–∞—Ä—ã, —Ç–æ—á–Ω–æ—Å—Ç—å, –≤—Ä–µ–º—è –∏–≥—Ä—ã
- **–ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω–æ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ** —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
- **–ö–æ–Ω—Ñ–µ—Ç—Ç–∏** –ø—Ä–∏ –∏–¥–µ–∞–ª—å–Ω–æ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ (–≤—Å–µ –ø–∞—Ä—ã –ø—Ä–∞–≤–∏–ª—å–Ω—ã–µ)
- **–ö–Ω–æ–ø–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π**: –∏–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞, –∏–∑–º–µ–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏, –≤—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–π –º–æ–¥—É–ª—å

### 3. –û–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π JavaScript (game_word_match.js)

#### ‚úÖ –£–ª—É—á—à–µ–Ω–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞:
- **–ú–æ–¥—É–ª—å–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞** —Å —á–µ—Ç–∫–∏–º —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–µ–º —Ñ—É–Ω–∫—Ü–∏–π
- **–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ–º** –∏–≥—Ä—ã
- **–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–±—ã—Ç–∏–π** –¥–ª—è –≤—Å–µ—Ö –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
- **–°–∏—Å—Ç–µ–º–∞ —Å–≤—è–∑–µ–π** —Å —Ö—Ä–∞–Ω–µ–Ω–∏–µ–º –≤ –º–∞—Å—Å–∏–≤–µ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è

#### ‚úÖ –ê–ª–≥–æ—Ä–∏—Ç–º—ã:
- **Fisher-Yates shuffle** –¥–ª—è –ø–µ—Ä–µ–º–µ—à–∏–≤–∞–Ω–∏—è –∫–∞—Ä—Ç–æ—á–µ–∫
- **–†–∞—Å—á–µ—Ç –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç** –¥–ª—è SVG —Å–≤—è–∑–µ–π
- **–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –∫–æ–ª–ª–∏–∑–∏–π** –¥–ª—è —Ä–∞–∑—Ä—ã–≤–∞ —Å–≤—è–∑–µ–π
- **–°—Ç–∞—Ç–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏—è** (—Ç–æ—á–Ω–æ—Å—Ç—å, –≤—Ä–µ–º—è –∏–≥—Ä—ã)

#### ‚úÖ –ê–Ω–∏–º–∞—Ü–∏–∏ –∏ —ç—Ñ—Ñ–µ–∫—Ç—ã:
- **–ü–ª–∞–≤–Ω–æ–µ –ø–æ—è–≤–ª–µ–Ω–∏–µ** –∫–∞—Ä—Ç–æ—á–µ–∫ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
- **–ê–Ω–∏–º–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–≤—è–∑–∏** —Å —ç—Ñ—Ñ–µ–∫—Ç–æ–º —Ä–∏—Å–æ–≤–∞–Ω–∏—è
- **–ü—É–ª—å—Å–∞—Ü–∏—è** –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
- **–ö–æ–Ω—Ñ–µ—Ç—Ç–∏** –¥–ª—è –ø—Ä–∞–∑–¥–Ω–æ–≤–∞–Ω–∏—è –ø–æ–±–µ–¥—ã

### 4. –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–æ–Ω–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ (game_word_match_demo.html)

#### ‚úÖ –ü–æ–ª–Ω–æ—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è:
- **–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è** —Å–æ–∑–¥–∞–Ω–∏—è —Å–≤—è–∑–µ–π –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
- **–¢–µ–º–Ω–∞—è —Ç–µ–º–∞** —Å –Ω–µ–æ–Ω–æ–≤—ã–º–∏ –∞–∫—Ü–µ–Ω—Ç–∞–º–∏
- **–°—Ç–µ–∫–ª—è–Ω–Ω—ã–π –º–æ—Ä—Ñ–∏–∑–º** –¥–ª—è —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
- **–ü–æ–ª–Ω–∞—è –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å** –≤—Å–µ—Ö —Ñ—É–Ω–∫—Ü–∏–π

## –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –¥–µ—Ç–∞–ª–∏

### CSS —É–ª—É—á—à–µ–Ω–∏—è:
- CSS –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏ —Ü–≤–µ—Ç–æ–≤
- Flexbox –∏ Grid –¥–ª—è –∞–¥–∞–ø—Ç–∏–≤–Ω–æ–π –≤–µ—Ä—Å—Ç–∫–∏
- CSS –∞–Ω–∏–º–∞—Ü–∏–∏ –∏ –ø–µ—Ä–µ—Ö–æ–¥—ã
- Backdrop-filter –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ —Ä–∞–∑–º—ã—Ç–∏—è
- –ì—Ä–∞–¥–∏–µ–Ω—Ç—ã –∏ —Ç–µ–Ω–∏ –¥–ª—è –≥–ª—É–±–∏–Ω—ã

### JavaScript —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç—å:
- ES6+ —Å–∏–Ω—Ç–∞–∫—Å–∏—Å
- –ú–æ–¥—É–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞
- –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç—å—é (–æ—á–∏—Å—Ç–∫–∞ –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–≤, —É–¥–∞–ª–µ–Ω–∏–µ —ç–ª–µ–º–µ–Ω—Ç–æ–≤)
- –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∞–ª–≥–æ—Ä–∏—Ç–º—ã

### –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å:
- –ú–æ–±–∏–ª—å–Ω–∞—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è
- –ì–∏–±–∫–∞—è —Å–µ—Ç–∫–∞
- –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
- Touch-friendly –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å

## –†–µ–∑—É–ª—å—Ç–∞—Ç

–ò–≥—Ä–∞ "–°–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –°–ª–æ–≤" —Ç–µ–ø–µ—Ä—å –ø—Ä–µ–¥—Å—Ç–∞–≤–ª—è–µ—Ç —Å–æ–±–æ–π —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–µ, –∏–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ –∏ –≤–∏–∑—É–∞–ª—å–Ω–æ –ø—Ä–∏–≤–ª–µ–∫–∞—Ç–µ–ª—å–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ —Å:

1. **–ì–∏–±–∫–∏–º–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º–∏** –≤—ã–±–æ—Ä–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞
2. **–ö—Ä–∞—Å–∏–≤—ã–º–∏ –≤–∏–∑—É–∞–ª—å–Ω—ã–º–∏ —ç—Ñ—Ñ–µ–∫—Ç–∞–º–∏** 
3. **–ò–Ω—Ç—É–∏—Ç–∏–≤–Ω—ã–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º**
4. **–ü–æ–¥—Ä–æ–±–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ–π**
5. **–ê–¥–∞–ø—Ç–∏–≤–Ω—ã–º –¥–∏–∑–∞–π–Ω–æ–º**
6. **–ü–ª–∞–≤–Ω—ã–º–∏ –∞–Ω–∏–º–∞—Ü–∏—è–º–∏**

–í—Å–µ –∏–¥–µ–∏ –∏–∑ —Ñ–∞–π–ª–∞ `ideas` –±—ã–ª–∏ —É—Å–ø–µ—à–Ω–æ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω—ã –∏ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω—ã –≤ —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∫–æ–¥–æ–≤—É—é –±–∞–∑—É.

ideas (/home/amir/Documents/Info/Duckly/ideas):
{% extends "base.html" %}

{% block title %}–ò–≥—Ä–∞ "–í–∏—Å–µ–ª–∏—Ü–∞"{% endblock %}

{% block content %}
<div class="container-fluid hangman-game">
    <div class="game-header">
        <div class="game-info">
            <h1 class="game-title">
                <i class="fas fa-skull-crossbones"></i>
                –í–∏—Å–µ–ª–∏—Ü–∞
            </h1>
            <div class="game-subtitle">
                –£–≥–∞–¥–∞–π—Ç–µ –∞–Ω–≥–ª–∏–π—Å–∫–æ–µ —Å–ª–æ–≤–æ –ø–æ –±—É–∫–≤–∞–º!
            </div>
        </div>
        
        <div class="game-stats">
            <div class="stat-item">
                <div class="stat-label">–°–ª–æ–≤–æ</div>
                <div class="stat-value">
                    <span id="current-word">1</span> / <span id="total-words">{{ num_words }}</span>
                </div>
            </div>
            <div class="stat-item">
                <div class="stat-label">–ü—Ä–∞–≤–∏–ª—å–Ω–æ</div>
                <div class="stat-value" id="correct-words">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">–û—à–∏–±–∫–∏</div>
                <div class="stat-value" id="wrong-guesses">0</div>
            </div>
            {% if timer_duration > 0 or enable_stopwatch %}
            <div class="stat-item">
                <div class="stat-label">
                    {% if timer_duration > 0 %}–í—Ä–µ–º—è{% else %}–°–µ–∫—É–Ω–¥–æ–º–µ—Ä{% endif %}
                </div>
                <div class="stat-value" id="timer-display">
                    {% if timer_duration > 0 %}{{ timer_duration }}—Å{% else %}00:00{% endif %}
                </div>
            </div>
            {% endif %}
        </div>
    </div>

    <div class="game-content">
        <!-- Hangman Drawing -->
        <div class="hangman-container">
            <svg class="hangman-svg" viewBox="0 0 200 250">
                <!-- Gallows with improved design -->
                <!-- Base -->
                <ellipse cx="30" cy="235" rx="25" ry="8" fill="#654321" stroke="#5D4037" stroke-width="2"/>
                <!-- Main post -->
                <rect x="25" y="20" width="10" height="215" fill="#8B4513" stroke="#5D4037" stroke-width="2" rx="2"/>
                <!-- Top beam -->
                <rect x="30" y="15" width="95" height="10" fill="#8B4513" stroke="#5D4037" stroke-width="2" rx="2"/>
                <!-- Noose support -->
                <rect x="115" y="20" width="10" height="35" fill="#8B4513" stroke="#5D4037" stroke-width="2" rx="2"/>
                <!-- Support beam -->
                <line x1="35" y1="40" x2="50" y2="25" stroke="#8B4513" stroke-width="3"/>
                <!-- Rope -->
                <line x1="120" y1="50" x2="120" y2="48" stroke="#D2691E" stroke-width="3"/>
                <!-- Wood grain effect -->
                <line x1="27" y1="30" x2="27" y2="220" stroke="#A0522D" stroke-width="1" opacity="0.5"/>
                <line x1="33" y1="35" x2="33" y2="225" stroke="#A0522D" stroke-width="1" opacity="0.5"/>
                <line x1="32" y1="17" x2="120" y2="17" stroke="#A0522D" stroke-width="1" opacity="0.5"/>
                <line x1="32" y1="23" x2="120" y2="23" stroke="#A0522D" stroke-width="1" opacity="0.5"/>
                
                <!-- Body parts (initially hidden) -->
                <g id="hangman-body" class="hangman-body">
                    <!-- Head with improved face -->
                    <g id="head" class="hangman-part">
                        <circle cx="120" cy="60" r="12" stroke="#2C3E50" stroke-width="3" fill="#F4D1AE"/>
                        <!-- Eyes -->
                        <circle cx="115" cy="57" r="1.5" fill="#2C3E50"/>
                        <circle cx="125" cy="57" r="1.5" fill="#2C3E50"/>
                        <!-- Eyebrows -->
                        <path d="M 112 53 Q 115 50 118 53" stroke="#2C3E50" stroke-width="1" fill="none" id="leftBrow"/>
                        <path d="M 122 53 Q 125 50 128 53" stroke="#2C3E50" stroke-width="1" fill="none" id="rightBrow"/>
                        <!-- Smiling mouth -->
                        <path d="M 115 63 Q 120 66 125 63" stroke="#2C3E50" stroke-width="1" fill="none" id="mouth"/>
                        <!-- Hair -->
                        <path d="M 108 52 Q 120 48 132 52" stroke="#8B4513" stroke-width="2" fill="none"/>
                    </g>
                    
                    <!-- Improved body proportions -->
                    <g id="body" class="hangman-part">
                        <ellipse cx="120" cy="110" rx="15" ry="40" stroke="#2C3E50" stroke-width="3" fill="#3498DB"/>
                        <!-- Shirt details -->
                        <line x1="105" y1="85" x2="135" y2="85" stroke="#2980B9" stroke-width="2"/>
                        <circle cx="115" cy="95" r="2" fill="#2980B9"/>
                        <circle cx="125" cy="95" r="2" fill="#2980B9"/>
                        <circle cx="120" cy="105" r="2" fill="#2980B9"/>
                    </g>
                    
                    <!-- Left Arm with physics -->
                    <g id="leftArm" class="hangman-part">
                        <line x1="105" y1="90" x2="85" y2="115" stroke="#F4D1AE" stroke-width="4" id="leftArmLine"/>
                        <line x1="105" y1="90" x2="90" y2="105" stroke="#3498DB" stroke-width="3"/>
                        <!-- Hand -->
                        <circle cx="85" cy="115" r="4" fill="#F4D1AE" stroke="#2C3E50" stroke-width="1" id="leftHand"/>
                    </g>
                    
                    <!-- Right Arm with physics -->
                    <g id="rightArm" class="hangman-part">
                        <line x1="135" y1="90" x2="155" y2="115" stroke="#F4D1AE" stroke-width="4" id="rightArmLine"/>
                        <line x1="135" y1="90" x2="150" y2="105" stroke="#3498DB" stroke-width="3"/>
                        <!-- Hand -->
                        <circle cx="155" cy="115" r="4" fill="#F4D1AE" stroke="#2C3E50" stroke-width="1" id="rightHand"/>
                    </g>
                    
                    <!-- Left Leg with physics -->
                    <g id="leftLeg" class="hangman-part">
                        <line x1="110" y1="150" x2="95" y2="185" stroke="#2C3E50" stroke-width="4" id="leftLegLine"/>
                        <!-- Shoe -->
                        <ellipse cx="95" cy="185" rx="8" ry="4" fill="#34495E" id="leftShoe"/>
                    </g>
                    
                    <!-- Right Leg with physics -->
                    <g id="rightLeg" class="hangman-part">
                        <line x1="130" y1="150" x2="145" y2="185" stroke="#2C3E50" stroke-width="4" id="rightLegLine"/>
                        <!-- Shoe -->
                        <ellipse cx="145" cy="185" rx="8" ry="4" fill="#34495E" id="rightShoe"/>
                    </g>
                </g>
            </svg>
        </div>

        <!-- Word Display -->
        <div class="word-container">
            <div class="word-display" id="word-display">
                <!-- Letters will be populated by JavaScript -->
            </div>
            <div class="word-hint" id="word-hint">
                <!-- Translation will be shown here -->
            </div>
        </div>

        <!-- Alphabet -->
        <div class="alphabet-container">
            <div class="alphabet-grid" id="alphabet-grid">
                <!-- Letters A-Z will be populated by JavaScript -->
            </div>
        </div>
    </div>

    <!-- Game Feedback -->
    <div id="game-feedback" class="game-feedback"></div>
    
    <!-- Game Over Overlay -->
    <div id="game-over-overlay" class="game-over-overlay"></div>

    <!-- Game Controls -->
    <div class="game-controls">
        <button id="hintBtn" class="btn btn-info">
            <i class="fas fa-lightbulb"></i> –ü–æ–¥—Å–∫–∞–∑–∫–∞
        </button>
        <button id="skipWordBtn" class="btn btn-warning">
            <i class="fas fa-forward"></i> –ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å —Å–ª–æ–≤–æ
        </button>
        <button id="resetGameBtn" class="btn btn-danger">
            <i class="fas fa-redo"></i> –ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ
        </button>
    </div>

    <!-- Game Result Modal -->
    <div class="game-result" id="gameResult">
        <div class="result-content">
            <h2 id="result-title">–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!</h2>
            <div class="result-stats">
                <div class="result-stat">
                    <span class="result-value" id="final-correct">0</span>
                    <span class="result-label">–£–≥–∞–¥–∞–Ω–æ —Å–ª–æ–≤</span>
                </div>
                <div class="result-stat">
                    <span class="result-value" id="final-accuracy">0%</span>
                    <span class="result-label">–¢–æ—á–Ω–æ—Å—Ç—å</span>
                </div>
                {% if timer_duration > 0 or enable_stopwatch %}
                <div class="result-stat">
                    <span class="result-value" id="final-time">0</span>
                    <span class="result-label">
                        {% if timer_duration > 0 %}–í—Ä–µ–º—è (—Å–µ–∫){% else %}–í—Ä–µ–º—è –∏–≥—Ä—ã{% endif %}
                    </span>
                </div>
                {% endif %}
            </div>
            <div class="result-actions">
                <button id="playAgainBtn" class="btn btn-success">
                    <i class="fas fa-play"></i> –ò–≥—Ä–∞—Ç—å —Å–Ω–æ–≤–∞
                </button>
                <button id="backToSettingsBtn" class="btn btn-primary">
                    <i class="fas fa-cog"></i> –ò–∑–º–µ–Ω–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
                </button>
                <a href="{{ url_for('hangman_select_module') }}" class="btn btn-outline-secondary">
                    <i class="fas fa-arrow-left"></i> –í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–π –º–æ–¥—É–ª—å
                </a>
            </div>
        </div>
    </div>

    <div class="mt-4 text-center">
        <a href="{{ url_for('hangman_select_module') }}" class="btn btn-outline-secondary back-button">
            <i class="fas fa-arrow-left"></i> –í—ã–±—Ä–∞—Ç—å –¥—Ä—É–≥–æ–π –º–æ–¥—É–ª—å
        </a>
    </div>
</div>

<!-- Game Data -->
<script id="hangmanWords" type="application/json">
    {{ words | tojson | safe }}
</script>
<script id="gameSettings" type="application/json">
    {
        "timerDuration": {{ timer_duration }},
        "enableStopwatch": {{ enable_stopwatch|tojson }},
        "difficulty": "{{ difficulty }}",
        "gameMode": "{{ game_mode }}",
        "totalWords": {{ num_words }}
    }
</script>

<style>
/* ... (–ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å—Ç–∏–ª–∏ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ... */

/* –£–ª—É—á—à–µ–Ω–Ω–∞—è –≤–∏–¥–∏–º–æ—Å—Ç—å —Å–µ–∫—É–Ω–¥–æ–º–µ—Ä–∞ */
.stat-value {
    color: #fff !important;
    text-shadow: 0 0 5px rgba(0,0,0,0.8), 0 0 10px rgba(0,0,0,0.5) !important;
    font-weight: 800 !important;
    background: rgba(255, 255, 255, 0.15) !important;
    padding: 8px 12px !important;
    border-radius: 8px !important;
    border: 1px solid rgba(255, 255, 255, 0.3) !important;
    min-height: 40px !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
}

.stat-value.danger {
    color: #ffdddd !important;
    background: rgba(255, 68, 68, 0.3) !important;
    border-color: rgba(255, 68, 68, 0.5) !important;
    text-shadow: 0 0 5px rgba(255,0,0,0.8), 0 0 10px rgba(255,0,0,0.5) !important;
}

.stat-value.warning {
    color: #ffffaa !important;
    background: rgba(255, 170, 0, 0.3) !important;
    border-color: rgba(255, 170, 0, 0.5) !important;
    text-shadow: 0 0 5px rgba(255,255,0,0.8), 0 0 10px rgba(255,255,0,0.5) !important;
}

/* –£–ª—É—á—à–µ–Ω–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –¥–ª—è –±—É–∫–≤ */
.letter-slot.revealed {
    color: #fff;
    border-color: #4CAF50;
    background: linear-gradient(45deg, #4CAF50, #81C784, #4CAF50, #66BB6A);
    background-size: 300% 300%;
    animation: 
        letterFlip 0.8s cubic-bezier(0.68, -0.55, 0.265, 1.55),
        gradientShift 2s ease-in-out infinite,
        colorPulse 3s infinite alternate;
    box-shadow: 0 0 20px rgba(76, 175, 80, 0.6), inset 0 0 20px rgba(255, 255, 255, 0.2);
    font-weight: bold;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
}

@keyframes letterFlip {
    0% { 
        transform: rotateX(90deg) scale(0.3);
        opacity: 0;
        background: linear-gradient(45deg, #4CAF50, #81C784);
    }
    50% { 
        transform: rotateX(0deg) scale(1.1);
        opacity: 1;
        background: linear-gradient(45deg, #4CAF50, #81C784);
    }
    100% { 
        transform: rotateX(0deg) scale(1);
        background: linear-gradient(45deg, #4CAF50, #81C784, #4CAF50, #66BB6A);
    }
}

@keyframes colorPulse {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

/* –£–ª—É—á—à–µ–Ω–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –ø—Ä–∏ –ø—Ä–æ–∏–≥—Ä—ã—à–µ */
@keyframes physicsSwing {
    0% { transform: rotate(0deg); }
    10% { transform: rotate(8deg); }
    20% { transform: rotate(-6deg); }
    30% { transform: rotate(5deg); }
    40% { transform: rotate(-4deg); }
    50% { transform: rotate(3deg); }
    60% { transform: rotate(-2deg); }
    70% { transform: rotate(1deg); }
    80% { transform: rotate(0deg); }
    100% { transform: rotate(0deg); }
}

@keyframes limbTwitch {
    0%, 100% { transform: rotate(0deg); }
    20% { transform: rotate(10deg); }
    40% { transform: rotate(-8deg); }
    60% { transform: rotate(5deg); }
    80% { transform: rotate(-3deg); }
}

.hangman-body.hanging {
    animation: physicsSwing 3s ease-in-out infinite;
}

.hangman-body.hanging #leftArm,
.hangman-body.hanging #rightArm {
    animation: limbTwitch 1.5s ease-in-out infinite;
}

.hangman-body.hanging #leftLeg,
.hangman-body.hanging #rightLeg {
    animation: limbTwitch 1.8s ease-in-out infinite;
}

/* –ì—Ä—É—Å—Ç–Ω–æ–µ –ª–∏—Ü–æ –ø—Ä–∏ –ø—Ä–æ–∏–≥—Ä—ã—à–µ */
.hangman-body.hanging #leftBrow,
.hangman-body.hanging #rightBrow {
    animation: sadBrows 0.8s ease-in-out forwards;
}

.hangman-body.hanging #mouth {
    animation: sadMouth 0.8s ease-in-out forwards;
}

@keyframes sadBrows {
    0% { d: path("M 112 53 Q 115 50 118 53"); }
    100% { d: path("M 112 55 Q 115 52 118 55"); }
}

@keyframes sadMouth {
    0% { d: path("M 115 63 Q 120 66 125 63"); }
    100% { d: path("M 115 65 Q 120 62 125 65"); }
}

/* –ê–Ω–∏–º–∞—Ü–∏—è –∑–∞—Ç—É—Ö–∞–Ω–∏—è –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ */
@keyframes hangmanFadeOut {
    0% { 
        opacity: 1;
        filter: brightness(1);
    }
    70% { 
        opacity: 0.8;
        filter: brightness(0.7);
    }
    100% { 
        opacity: 0.6;
        filter: brightness(0.5) sepia(1) hue-rotate(0deg);
    }
}

.hangman-container.game-over {
    animation: hangmanFadeOut 2s ease-in-out forwards;
}

/* –î—Ä—É–≥–∏–µ —Å—Ç–∏–ª–∏ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π */
</style>
{% endblock %}

{% block scripts %}
{{ super() }}
<script>
document.addEventListener('DOMContentLoaded', function() {
    // ... (–ø—Ä–µ–¥—ã–¥—É—â–∏–π JavaScript –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...

    function guessLetter(letter) {
        console.log('guessLetter called:', letter, 'gameActive:', gameActive, 'already guessed:', guessedLetters.includes(letter));
        
        if (!gameActive || guessedLetters.includes(letter)) return;
        
        const btn = document.querySelector(`[data-letter="${letter}"]`);
        if (!btn || btn.disabled) {
            console.log('Button not found or disabled:', letter, btn);
            return;
        }
        
        guessedLetters.push(letter);
        
        if (currentWord.includes(letter)) {
            // Correct guess
            btn.classList.add('correct');
            btn.disabled = true;
            
            // Reveal letters with animation delay
            const slots = document.querySelectorAll(`[data-letter="${letter}"]`);
            slots.forEach((slot, index) => {
                if (slot.classList.contains('letter-slot')) {
                    setTimeout(() => {
                        slot.textContent = letter;
                        slot.classList.add('revealed');
                    }, index * 150); // Delay each letter slightly for better effect
                    correctGuesses++;
                }
            });
            
            // Check if word is complete
            const uniqueLetters = [...new Set(currentWord.replace(/\s/g, ''))];
            const guessedUniqueLetters = uniqueLetters.filter(l => guessedLetters.includes(l));
            
            if (guessedUniqueLetters.length === uniqueLetters.length) {
                wordCompleted(true);
            }
        } else {
            // Wrong guess
            btn.classList.add('incorrect');
            btn.disabled = true;
            wrongGuesses++;
            totalWrongGuesses++; // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –æ–±—â–∏–π —Å—á–µ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫
            
            // Show hangman part with animation
            if (wrongGuesses <= hangmanParts.length && hangmanParts[wrongGuesses - 1]) {
                setTimeout(() => {
                    hangmanParts[wrongGuesses - 1].classList.add('show');
                    
                    // Add shake effect to the whole hangman container
                    const hangmanContainer = document.querySelector('.hangman-container');
                    hangmanContainer.style.animation = 'shake 0.5s ease-in-out';
                    setTimeout(() => {
                        hangmanContainer.style.animation = '';
                    }, 500);
                }, 200);
            }
            
            // Check if game over
            if (wrongGuesses >= hangmanParts.length) {
                wordCompleted(false);
            }
        }
        
        updateStats();
    }
    
    function wordCompleted(success) {
        totalAttempts++;
        gameActive = false; // –î–µ–∞–∫—Ç–∏–≤–∏—Ä—É–µ–º –∏–≥—Ä—É –≤–æ –≤—Ä–µ–º—è –æ–±—Ä–∞–±–æ—Ç–∫–∏
        
        if (success) {
            totalCorrectWords++;
            showFeedback('–û—Ç–ª–∏—á–Ω–æ! –°–ª–æ–≤–æ —É–≥–∞–¥–∞–Ω–æ!', 'success');
            
            // Add bonus points for fewer wrong guesses
            if (wrongGuesses === 0) {
                showFeedback('–ò–¥–µ–∞–ª—å–Ω–æ! –ù–∏ –æ–¥–Ω–æ–π –æ—à–∏–±–∫–∏!', 'success');
            }
            
            // Move to next word after delay
            setTimeout(() => {
                currentWordIndex++;
                startNewWord();
            }, 2000);
        } else {
            // Reveal the word
            document.querySelectorAll('.letter-slot').forEach(slot => {
                if (slot.dataset.letter && slot.dataset.letter !== ' ') {
                    slot.textContent = slot.dataset.letter;
                    slot.classList.add('revealed');
                }
            });
            
            // Start hanging animation
            startHangingAnimation();
            
            // Move to next word after hanging animation
            setTimeout(() => {
                currentWordIndex++;
                startNewWord();
            }, 5000); // 5 seconds for hanging animation
        }
    }

    function startHangingAnimation() {
        const hangmanBody = document.getElementById('hangman-body');
        const hangmanContainer = document.querySelector('.hangman-container');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        
        if (hangmanBody && hangmanContainer) {
            // Add hanging animation to the body
            hangmanBody.classList.add('hanging');
            
            // Show overlay after 1 second
            setTimeout(() => {
                if (gameOverOverlay) {
                    gameOverOverlay.classList.add('show');
                }
                hangmanContainer.classList.add('game-over');
            }, 1000);
            
            // Show dramatic text
            setTimeout(() => {
                const dramaticText = document.createElement('div');
                dramaticText.className = 'dramatic-text';
                dramaticText.innerHTML = 'üíÄ –ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê! üíÄ';
                document.body.appendChild(dramaticText);
                
                // Remove dramatic text after 2 seconds
                setTimeout(() => {
                    dramaticText.remove();
                }, 2000);
            }, 2000);
            
            // Show regular feedback
            setTimeout(() => {
                showFeedback(`–°–ª–æ–≤–æ –±—ã–ª–æ: ${currentWord}`, 'error');
            }, 3500);
            
            // Remove animations after 5 seconds
            setTimeout(() => {
                hangmanBody.classList.remove('hanging');
                hangmanContainer.classList.remove('game-over');
                if (gameOverOverlay) {
                    gameOverOverlay.classList.remove('show');
                }
                // gameActive –±—É–¥–µ—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ true –≤ startNewWord()
            }, 5000);
        }
    }

    // ... (–æ—Å—Ç–∞–ª—å–Ω–æ–π JavaScript –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...
});
</script>
{% endblock %}

instance (/home/amir/Documents/Info/Duckly/instance):


migrate_add_test_progress.py (/home/amir/Documents/Info/Duckly/migrate_add_test_progress.py):
#!/usr/bin/env python3
"""
–ú–∏–≥—Ä–∞—Ü–∏—è –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã test_progress
"""

import sqlite3
import os

def migrate_database():
    """–î–æ–±–∞–≤–ª—è–µ—Ç —Ç–∞–±–ª–∏—Ü—É test_progress –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"""
    
    # –ü—É—Ç–∏ –∫ –≤–æ–∑–º–æ–∂–Ω—ã–º –±–∞–∑–∞–º –¥–∞–Ω–Ω—ã—Ö
    db_paths = ['instance/app.db', 'app.db']
    db_path = None
    
    for path in db_paths:
        if os.path.exists(path):
            db_path = path
            break
    
    if not db_path:
        print(f"–ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –ø–æ –ø—É—Ç—è–º: {db_paths}")
        return False
    
    print(f"–ò—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö: {db_path}")
    
    try:
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ —Ç–∞–±–ª–∏—Ü–∞
        cursor.execute("""
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name='test_progress'
        """)
        
        if cursor.fetchone():
            print("–¢–∞–±–ª–∏—Ü–∞ test_progress —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç")
            conn.close()
            return True
        
        # –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—Ü—É test_progress
        cursor.execute("""
            CREATE TABLE test_progress (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                test_result_id INTEGER NOT NULL,
                test_word_id INTEGER NOT NULL,
                user_answer TEXT,
                last_updated DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (test_result_id) REFERENCES test_results (id),
                FOREIGN KEY (test_word_id) REFERENCES test_words (id),
                UNIQUE(test_result_id, test_word_id)
            )
        """)
        
        # –°–æ–∑–¥–∞–µ–º –∏–Ω–¥–µ–∫—Å—ã –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
        cursor.execute("""
            CREATE INDEX idx_test_progress_result_id ON test_progress(test_result_id)
        """)
        
        cursor.execute("""
            CREATE INDEX idx_test_progress_word_id ON test_progress(test_word_id)
        """)
        
        conn.commit()
        print("–¢–∞–±–ª–∏—Ü–∞ test_progress —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞")
        
        conn.close()
        return True
        
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ç–∞–±–ª–∏—Ü—ã: {e}")
        return False

if __name__ == "__main__":
    print("–ó–∞–ø—É—Å–∫ –º–∏–≥—Ä–∞—Ü–∏–∏ –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã test_progress...")
    success = migrate_database()
    if success:
        print("–ú–∏–≥—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ —É—Å–ø–µ—à–Ω–æ!")
    else:
        print("–ú–∏–≥—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –æ—à–∏–±–∫–æ–π!")

models.py (/home/amir/Documents/Info/Duckly/models.py):
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

db = SQLAlchemy()

class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    fio = db.Column(db.String, nullable=False)
    nick = db.Column(db.String, unique=True, nullable=False)
    password = db.Column(db.String, nullable=False) # Will store hashed password
    teacher = db.Column(db.String, nullable=True)
    class_number = db.Column(db.String, nullable=True)  # Added for student class

class Word(db.Model):
    __tablename__ = 'words'
    id = db.Column(db.Integer, primary_key=True)
    word = db.Column(db.String, nullable=False)
    perevod = db.Column(db.String, nullable=False)
    classs = db.Column('class', db.String, nullable=False)
    unit = db.Column(db.String, nullable=False)
    module = db.Column(db.String, nullable=False)

class Test(db.Model):
    __tablename__ = 'tests'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String, nullable=False)
    classs = db.Column('class', db.String, nullable=False)
    unit = db.Column(db.String, nullable=True, default="N/A")
    module = db.Column(db.String, nullable=True, default="N/A")
    type = db.Column(db.String, nullable=False)  # dictation, add_letter, true_false, multiple_choice_single, multiple_choice_multiple, fill_word
    link = db.Column(db.String, unique=True, nullable=False)
    created_by = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    is_active = db.Column(db.Boolean, default=True)
    time_limit = db.Column(db.Integer, nullable=True)  # Time limit in minutes
    word_order = db.Column(db.String, nullable=False)  # 'random' or 'sequential'
    word_count = db.Column(db.Integer, nullable=True)  # For random order
    test_mode = db.Column(db.String, nullable=True)  # 'random_letters' or 'manual_letters' for add_letter type
    
    # New fields for dictation test options
    dictation_word_source = db.Column(db.String, nullable=True) # e.g., "all_module", "selected_specific", "random_from_module"
    dictation_selected_words = db.Column(db.Text, nullable=True) # JSON list of word IDs for "selected_specific"

    created_at = db.Column(db.DateTime, default=db.func.current_timestamp())
    test_words = db.relationship('TestWord', backref='test', lazy=True)

class TestWord(db.Model):
    __tablename__ = 'test_words'
    id = db.Column(db.Integer, primary_key=True)
    test_id = db.Column(db.Integer, db.ForeignKey('tests.id'), nullable=False)
    word = db.Column(db.String, nullable=False)
    perevod = db.Column(db.String, nullable=False)
    missing_letters = db.Column(db.String, nullable=True)  # For add_letter type tests
    options = db.Column(db.String, nullable=True)  # For multiple choice tests (JSON string)
    correct_answer = db.Column(db.String, nullable=False)
    word_order = db.Column(db.Integer, nullable=False)  # To maintain word order in sequential tests

class TestResult(db.Model):
    __tablename__ = 'test_results'
    id = db.Column(db.Integer, primary_key=True)
    test_id = db.Column(db.Integer, db.ForeignKey('tests.id'), nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    score = db.Column(db.Integer, nullable=False, default=0)
    correct_answers = db.Column(db.Integer, nullable=False, default=0)
    total_questions = db.Column(db.Integer, nullable=False, default=0)
    time_taken = db.Column(db.Integer, nullable=False, default=0)  # in minutes
    started_at = db.Column(db.DateTime, nullable=False, default=db.func.current_timestamp())
    completed_at = db.Column(db.DateTime, nullable=True)
    current_word_index = db.Column(db.Integer, default=0)  # Track progress
    answers = db.Column(db.String, nullable=True)  # JSON string of answers

    test = db.relationship('Test', backref=db.backref('results', lazy=True))
    user = db.relationship('User', backref=db.backref('test_results', lazy=True))
    test_answers = db.relationship('TestAnswer', backref='test_result', lazy=True, cascade='all, delete-orphan')

class TestAnswer(db.Model):
    __tablename__ = 'test_answers'
    id = db.Column(db.Integer, primary_key=True)
    test_result_id = db.Column(db.Integer, db.ForeignKey('test_results.id'), nullable=False)
    test_word_id = db.Column(db.Integer, db.ForeignKey('test_words.id'), nullable=False)
    user_answer = db.Column(db.String(255), nullable=True)
    is_correct = db.Column(db.Boolean, nullable=False, default=False)
    answered_at = db.Column(db.DateTime, default=db.func.current_timestamp())

    test_word = db.relationship('TestWord', backref=db.backref('answers', lazy=True))

class TestProgress(db.Model):
    __tablename__ = 'test_progress'
    id = db.Column(db.Integer, primary_key=True)
    test_result_id = db.Column(db.Integer, db.ForeignKey('test_results.id'), nullable=False)
    test_word_id = db.Column(db.Integer, db.ForeignKey('test_words.id'), nullable=False)
    user_answer = db.Column(db.Text, nullable=True)  # JSON string for complex answers like dictation
    last_updated = db.Column(db.DateTime, default=db.func.current_timestamp(), onupdate=db.func.current_timestamp())
    
    # Unique constraint to ensure one progress record per test_result and test_word
    __table_args__ = (db.UniqueConstraint('test_result_id', 'test_word_id', name='_test_progress_uc'),)
    
    test_result = db.relationship('TestResult', backref=db.backref('progress_entries', lazy=True, cascade='all, delete-orphan'))
    test_word = db.relationship('TestWord', backref=db.backref('progress_entries', lazy=True))

class UserWordReview(db.Model):
    __tablename__ = 'user_word_reviews'
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), nullable=False)
    word_id = db.Column(db.Integer, db.ForeignKey('words.id'), nullable=False)
    next_review_at = db.Column(db.DateTime, nullable=False, default=datetime.utcnow)
    interval_days = db.Column(db.Integer, default=0) # Current interval in days
    ease_factor = db.Column(db.Float, default=2.5) # Standard SM-2 starting ease
    last_reviewed_at = db.Column(db.DateTime, nullable=True)
    # Add unique constraint for user_id and word_id
    __table_args__ = (db.UniqueConstraint('user_id', 'word_id', name='_user_word_uc'),)

    user = db.relationship('User', backref=db.backref('reviews', lazy='dynamic'))
    word = db.relationship('Word', backref=db.backref('reviews', lazy='dynamic'))

class Sentence(db.Model):
    __tablename__ = 'sentences'
    id = db.Column(db.Integer, primary_key=True)
    text = db.Column(db.String, nullable=False) # The English sentence
    translation = db.Column(db.String, nullable=True) # Russian translation
    classs = db.Column(db.String, nullable=False)
    unit = db.Column(db.String, nullable=False)
    module = db.Column(db.String, nullable=False)
    # Potentially add difficulty level later

output.txt (/home/amir/Documents/Info/Duckly/output.txt):


__pycache__ (/home/amir/Documents/Info/Duckly/__pycache__):


README.md (/home/amir/Documents/Info/Duckly/README.md):
# Duckly Educational Platform

This project is a web-based educational platform, likely designed for language learning, built with Python and Flask. It allows users to register, manage vocabulary (words), create various types of tests, take tests, and view results. The application is designed to be run in a Docker container.

## Features

*   **User Management:**
    *   User registration (students and teachers).
    *   User login and logout.
    *   User profiles.
*   **Vocabulary Management:**
    *   Adding, editing, and deleting words.
    *   Organizing words by class, unit, and module.
*   **Test Management (for Teachers):**
    *   Creating various types of tests:
        *   Dictation
        *   Add Letter (fill in missing letters)
        *   True/False
        *   Multiple Choice (single and multiple correct answers)
        *   Fill Word (fill in the blank)
    *   Setting test parameters like time limits, word order (random/sequential), and word count.
    *   Linking tests to specific classes, units, or modules.
    *   Archiving tests.
*   **Test Taking (for Students):**
    *   Taking available tests via a unique link.
    *   Submitting answers.
*   **Results Tracking:**
    *   Viewing test scores, correct/incorrect answers, and time taken.
*   **Quizlet-like Functionality:**
    *   Viewing words as flashcards for a given module.
*   **API Endpoints:**
    *   JSON endpoints for retrieving words, units, and modules, likely for dynamic frontend updates.

## Project Structure

```
.
‚îú‚îÄ‚îÄ .git/               # Git repository files
‚îú‚îÄ‚îÄ instance/           # Potentially for instance-specific configurations or data (e.g., persistent DB)
‚îú‚îÄ‚îÄ static/             # Static assets (CSS, JavaScript, images)
‚îú‚îÄ‚îÄ templates/          # HTML templates for the web interface
‚îú‚îÄ‚îÄ __pycache__/        # Python bytecode cache
‚îú‚îÄ‚îÄ app.db              # SQLite database file (Note: May be recreated on container start)
‚îú‚îÄ‚îÄ create_db.py        # Script to initialize the database schema
‚îú‚îÄ‚îÄ Dockerfile          # Defines the Docker image for the application
‚îú‚îÄ‚îÄ requirements.txt    # Python package dependencies
‚îú‚îÄ‚îÄ site_1.py           # Main Flask application file containing routes and logic
‚îú‚îÄ‚îÄ start.sh            # Script to build and run the Docker container
‚îî‚îÄ‚îÄ test.py             # Contains application tests
```

## Technical Stack

*   **Backend:** Python, Flask
*   **Database:** SQLite (via Flask-SQLAlchemy)
*   **Templating:** Jinja2
*   **Containerization:** Docker

## Configuration

Before running the application, especially in a production-like environment, you should configure a `SECRET_KEY`. This key is used by Flask for session management and other security-related purposes.

*   **Environment Variable:** `SECRET_KEY`
*   **How to set:**
    *   When running with Docker (recommended), you can set this environment variable using the `-e` flag:
        ```bash
        docker run -e SECRET_KEY='your_very_strong_and_unique_secret_key' ... other_docker_options ... duckly-app
        ```
    *   If running locally without Docker (for development), you can set it in your shell:
        ```bash
        export SECRET_KEY='your_development_secret_key'
        python site_1.py
        ```
*   **Default:** If `SECRET_KEY` is not set, the application will use a default, insecure key suitable only for development. **It is crucial to set a strong, unique secret key for any production deployment.**

## Setup and Installation

The application is designed to be run using Docker.

### Prerequisites

*   Docker installed and running.

### Running the Application

1.  **Clone the repository (if applicable):**
    ```bash
    git clone <repository_url>
    cd <repository_directory>
    ```

2.  **Build and Run with `start.sh`:**
    The provided `start.sh` script automates the build and run process:
    ```bash
    sh start.sh
    ```
    This script will:
    *   Build a Docker image named `duckly-app`.
    *   Remove any existing container named `duckly-container`.
    *   Run a new container named `duckly-container` in detached mode.
    *   Map port 1800 of the host to port 1800 of the container.
    *   Mount the local `./instance` directory to `/app/instance` in the container. (Note: the script currently uses an absolute path `/home/amir/Duckly/instance` for the volume, you might need to adjust this to your local path or `./instance`).

3.  **Access the application:**
    Once the container is running, the application should be accessible at `http://localhost:1800`.

### Database Initialization

The `Dockerfile` is currently configured to remove `app.db` every time the container starts (`CMD ["sh", "-c", "rm -f app.db && python site_1.py"]`). This means data will not persist across container restarts with the default configuration.

To create the database schema, you can use the `create_db.py` script. You might need to run this script *inside* the running container or modify the application/startup process to handle database creation and persistence.

**Option 1: Run `create_db.py` in a running container (after starting with `start.sh`):**
```bash
docker exec -it duckly-container python create_db.py
```

**Option 2: For a persistent database:**
*   Modify `site_1.py` to store `app.db` inside the `/app/instance` directory (e.g., `app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///instance/app.db'`).
*   Ensure the `instance` directory exists locally before running `start.sh`.
*   Remove `rm -f app.db` from the `CMD` in the `Dockerfile` if the database is moved to the `instance` folder.

## Key Files

*   `site_1.py`: The core Flask application logic, including all routes, database models, and view functions.
*   `Dockerfile`: Instructions for building the Docker image.
*   `requirements.txt`: Lists all Python dependencies.
*   `start.sh`: Utility script to simplify building and running the Docker container.
*   `create_db.py`: Script to create the database tables based on the models defined in `site_1.py`.
*   `templates/`: Contains the HTML templates rendered by Flask.
*   `static/`: Contains static files like CSS and JavaScript.

## Potential Improvements / Areas to Note

*   **Database Persistence:** As mentioned, the current `Dockerfile` setup leads to an ephemeral database. This should be addressed for any practical use by ensuring the database file is stored in the mounted `instance` volume and not deleted on container start.
*   **Secret Key:** The `app.secret_key` in `site_1.py` is hardcoded. For production, this should be set via an environment variable or a configuration file.
*   **Volume Path in `start.sh`:** The `start.sh` script uses an absolute path (`/home/amir/Duckly/instance`) for the volume mount. This should be changed to a relative path (e.g., `-v $(pwd)/instance:/app/instance` for Linux/macOS or an equivalent for Windows) or parameterized to make the script more portable.
*   **Error Handling and Input Validation:** While some basic checks are present, robust error handling and comprehensive input validation would enhance the application's stability.
*   **Testing:** The presence of `test.py` suggests tests exist or are planned. Comprehensive test coverage is important.
*   **Security:** Review security aspects, especially around user authentication, authorization (teacher vs. student access), and protection against common web vulnerabilities (XSS, CSRF, SQL Injection - though SQLAlchemy helps mitigate the latter).

## Contributing

(Provide guidelines here if this is an open project, e.g., how to submit issues, feature requests, or pull requests.)

## License

(Specify the license for the project, e.g., MIT, GPL, etc.) 

rebuild_and_run.sh (/home/amir/Documents/Info/Duckly/rebuild_and_run.sh):
#!/bin/bash

echo "–ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–ø—É—â–µ–Ω–Ω—ã—Ö –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–æ–≤..."

# –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–ø—É—â–µ–Ω –ª–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
if docker ps | grep -q duckly-container; then
    echo "–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∑–∞–ø—É—â–µ–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä duckly-container..."
    docker stop duckly-container
    echo "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω."
fi

# –£–¥–∞–ª—è–µ–º –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä, –µ—Å–ª–∏ –æ–Ω —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
if docker ps -a | grep -q duckly-container; then
    echo "–£–¥–∞–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä duckly-container..."
    docker rm duckly-container
    echo "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —É–¥–∞–ª–µ–Ω."
fi

# –°–æ–∑–¥–∞—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è —Å–µ—Å—Å–∏–π, –µ—Å–ª–∏ –æ–Ω–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
echo "–°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ –¥–ª—è —Å–µ—Å—Å–∏–π..."
mkdir -p flask_session
chmod 777 flask_session
echo "–î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è —Å–µ—Å—Å–∏–π –≥–æ—Ç–æ–≤–∞."

# –ü–µ—Ä–µ—Å–æ–±—Ä–∞—Ç—å –æ–±—Ä–∞–∑
echo "–°–±–æ—Ä–∫–∞ Docker-–æ–±—Ä–∞–∑–∞..."
docker build -t duckly-app .
echo "–û–±—Ä–∞–∑ —Å–æ–±—Ä–∞–Ω —É—Å–ø–µ—à–Ω–æ."

# –ó–∞–ø—É—Å—Ç–∏—Ç—å –Ω–æ–≤—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
echo "–ó–∞–ø—É—Å–∫ –Ω–æ–≤–æ–≥–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞..."
docker run -d \
  --name duckly-container \
  -p 1800:1800 \
  -v $(pwd)/instance:/app/instance \
  -v $(pwd)/flask_session:/app/flask_session \
  -e SECRET_KEY='your-development-secret-key-here' \
  duckly-app

echo "==============================================="
echo "–ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–ø—É—â–µ–Ω–æ –Ω–∞ http://localhost:1800"
echo "==============================================="
echo "–õ–æ–≥–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞ (Ctrl+C –¥–ª—è –≤—ã—Ö–æ–¥–∞):"
docker logs -f duckly-container

requirements.txt (/home/amir/Documents/Info/Duckly/requirements.txt):
Flask==2.2.5
Flask-SQLAlchemy==3.1.1
Flask-Session==0.5.0
SQLAlchemy==2.0.23
MarkupSafe==2.1.3
Werkzeug==2.2.3
itsdangerous==2.1.2
Jinja2==3.1.3
click==8.1.3

run_docker.sh (/home/amir/Documents/Info/Duckly/run_docker.sh):
#!/bin/bash

echo "–û—Å—Ç–∞–Ω–æ–≤–∫–∞ –∏ —É–¥–∞–ª–µ–Ω–∏–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞..."
docker stop duckly-container 2>/dev/null || true
docker rm duckly-container 2>/dev/null || true

echo "–°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π –¥–ª—è –¥–∞–Ω–Ω—ã—Ö..."
mkdir -p instance
mkdir -p flask_session
chmod 777 instance
chmod 777 flask_session

echo "–°–±–æ—Ä–∫–∞ Docker-–æ–±—Ä–∞–∑–∞..."
docker build -t duckly-app .

echo "–ó–∞–ø—É—Å–∫ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞..."
docker run -d \
  --name duckly-container \
  -p 1800:1800 \
  -v $(pwd)/instance:/app/instance \
  -v $(pwd)/flask_session:/app/flask_session \
  -e SECRET_KEY='super-secret-key-for-duckly-app' \
  duckly-app

echo "–ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –∑–∞–ø—É—â–µ–Ω. –ü—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –¥–æ—Å—Ç—É–ø–Ω–æ –ø–æ –∞–¥—Ä–µ—Å—É: http://localhost:1800"
echo "–õ–æ–≥–∏ –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞:"
docker logs -f duckly-container

site_1.py (/home/amir/Documents/Info/Duckly/site_1.py):
from markupsafe import escape
from flask import Flask, jsonify, request, render_template, redirect, url_for, flash, make_response, session, abort
from werkzeug.security import generate_password_hash, check_password_hash # Added for password hashing
from flask_session import Session  # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥–¥–µ—Ä–∂–∫—É —Å–µ—Å—Å–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ñ–∞–π–ª–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã
import time
import sqlite3
import random
import string
from datetime import datetime, timedelta
import json
import subprocess # Added to run external scripts
import re # Add this at the top with other imports
import os # Added for os.makedirs
import tempfile # –î–ª—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ñ–∞–π–ª–æ–≤ —Å–µ—Å—Å–∏–∏

# Import models and db
from models import db, User, Word, Test, TestWord, TestResult, TestAnswer, TestProgress, UserWordReview, Sentence

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—á–∏—Å—Ç–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
AUTO_CLEAR_RESULTS_ON_NEW_TEST = True  # –í–∫–ª—é—á–∏—Ç—å/–≤—ã–∫–ª—é—á–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫—É—é –æ—á–∏—Å—Ç–∫—É
CLEAR_ONLY_ACTIVE_TESTS = True  # –û—á–∏—â–∞—Ç—å —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ —Ç–µ—Å—Ç—ã (—Å–æ—Ö—Ä–∞–Ω—è—Ç—å –∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ)

def format_time_taken(minutes):
    """
    –ë–µ–∑–æ–ø–∞—Å–Ω–æ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–µ—Å—Ç–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.
    
    Args:
        minutes: –í—Ä–µ–º—è –≤ –º–∏–Ω—É—Ç–∞—Ö (–º–æ–∂–µ—Ç –±—ã—Ç—å None, 0 –∏–ª–∏ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º)
    
    Returns:
        str: –û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –≤—Ä–µ–º–µ–Ω–∏
    """
    if minutes is None or minutes < 0:
        return "0 –º–∏–Ω"
    
    if minutes == 0:
        return "<1 –º–∏–Ω"
    
    hours = minutes // 60
    remaining_minutes = minutes % 60
    
    if hours == 0:
        return f"{remaining_minutes} –º–∏–Ω"
    elif remaining_minutes == 0:
        return f"{hours} —á"
    else:
        return f"{hours} —á {remaining_minutes} –º–∏–Ω"

def auto_clear_previous_test_results(teacher_user, class_number, new_test_id):
    """
    –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—á–∏—â–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Ç–µ—Å—Ç–æ–≤ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ —Ç–µ—Å—Ç–∞.
    
    Args:
        teacher_user: –û–±—ä–µ–∫—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è-—É—á–∏—Ç–µ–ª—è
        class_number: –ù–æ–º–µ—Ä –∫–ª–∞—Å—Å–∞
        new_test_id: ID –Ω–æ–≤–æ–≥–æ —Ç–µ—Å—Ç–∞ (–∏—Å–∫–ª—é—á–∞–µ—Ç—Å—è –∏–∑ –æ—á–∏—Å—Ç–∫–∏)
    
    Returns:
        tuple: (–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ_–æ—á–∏—â–µ–Ω–Ω—ã—Ö_—Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤, —Å–ø–∏—Å–æ–∫_–∑–∞—Ç—Ä–æ–Ω—É—Ç—ã—Ö_—Ç–µ—Å—Ç–æ–≤)
    """
    if not AUTO_CLEAR_RESULTS_ON_NEW_TEST:
        return 0, []
    
    try:
        # –°—Ç—Ä–æ–∏–º –∑–∞–ø—Ä–æ—Å –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Ç–µ—Å—Ç–æ–≤
        query = Test.query.filter(
            Test.created_by == teacher_user.id,
            Test.classs == class_number,
            Test.id != new_test_id
        )
        
        # –ï—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ –æ—á–∏—â–∞—Ç—å —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ —Ç–µ—Å—Ç—ã
        if CLEAR_ONLY_ACTIVE_TESTS:
            query = query.filter(Test.is_active == True)
        
        previous_tests = query.all()
        
        results_cleared_count = 0
        tests_affected = []
        
        for prev_test in previous_tests:
            # –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è —ç—Ç–æ–≥–æ —Ç–µ—Å—Ç–∞
            results_to_delete = TestResult.query.filter_by(test_id=prev_test.id).all()
            
            if results_to_delete:  # –ï—Å–ª–∏ –µ—Å—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
                tests_affected.append(prev_test.title)
                
                for result in results_to_delete:
                    # –£–¥–∞–ª—è–µ–º —Å–≤—è–∑–∞–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã
                    TestAnswer.query.filter_by(test_result_id=result.id).delete(synchronize_session=False)
                    # –£–¥–∞–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
                    db.session.delete(result)
                    results_cleared_count += 1
        
        if results_cleared_count > 0:
            db.session.commit()
        
        return results_cleared_count, tests_affected
        
    except Exception as e:
        db.session.rollback()
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—á–∏—Å—Ç–∫–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤: {e}")
        raise e

app = Flask(__name__)
# Create instance folder if it doesn't exist
try:
    os.makedirs(app.instance_path, exist_ok=True)
except OSError as e:
    print(f"Error creating instance directory {app.instance_path}: {e}")

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ø—É—Ç—å –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–∫—Ä—É–∂–µ–Ω–∏—è
if os.path.exists('/app'):
    # –ó–∞–ø—É—Å–∫ –≤ Docker
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:////app/instance/app.db'
else:
    # –õ–æ–∫–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫
    app.config['SQLALCHEMY_DATABASE_URI'] = f'sqlite:///{os.path.join(app.instance_path, "app.db")}'

app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.secret_key = os.environ.get('SECRET_KEY', 'a-default-development-secret-key')  # Load secret key from env var

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å–µ—Å—Å–∏–∏ –¥–ª—è —Ä–∞–±–æ—Ç—ã –≤ Docker
app.config['SESSION_TYPE'] = 'filesystem'
app.config['SESSION_PERMANENT'] = True
app.config['PERMANENT_SESSION_LIFETIME'] = timedelta(days=15)
app.config['SESSION_USE_SIGNER'] = True  # –ü–æ–¥–ø–∏—Å—ã–≤–∞–µ–º cookie –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
app.config['SESSION_KEY_PREFIX'] = 'duckly_'  # –ü—Ä–µ—Ñ–∏–∫—Å –¥–ª—è —Ñ–∞–π–ª–æ–≤ —Å–µ—Å—Å–∏–π

# –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–µ—Å—Å–∏–π
if os.path.exists('/app'):
    # –í Docker –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ—Å—Ç–æ—è–Ω–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
    session_dir = '/app/flask_session'
    if not os.path.exists(session_dir):
        os.makedirs(session_dir, exist_ok=True)
    app.config['SESSION_FILE_DIR'] = session_dir
else:
    # –õ–æ–∫–∞–ª—å–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º –≤—Ä–µ–º–µ–Ω–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
    app.config['SESSION_FILE_DIR'] = tempfile.gettempdir()

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ cookie –¥–ª—è —Å–µ—Å—Å–∏–∏
app.config['SESSION_COOKIE_NAME'] = 'duckly_session'
app.config['SESSION_COOKIE_SECURE'] = False  # –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ True –≤ production —Å HTTPS
app.config['SESSION_COOKIE_HTTPONLY'] = True
app.config['SESSION_COOKIE_SAMESITE'] = 'Lax'
app.config['SESSION_COOKIE_PATH'] = '/'

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ—Å—Å–∏–∏
Session(app)

# Initialize the db with the app
db.init_app(app)

# Import blueprints after app and db initialization to avoid circular imports
from blueprints.auth import auth_bp
from blueprints.words import words_bp

# Register blueprints
app.register_blueprint(auth_bp)
app.register_blueprint(words_bp)

# Models are now imported from models.py


@app.route("/")
def index():
    return redirect('/hello', 302)

@app.route("/user/<name>")
def greet(name):
    return f"Hello, {name}!"

# Auth routes are now in blueprints.auth
# @app.route("/profile") ... (moved)
# @app.route("/edit_profile") ... (moved)
# @app.route("/save_profile", methods=["POST"]) ... (moved)
# @app.route('/login', methods=['POST', 'GET']) ... (moved)
# @app.route("/logout") ... (moved)
# @app.route('/registration', methods=['POST', 'GET']) ... (moved)


@app.route("/add_tests", methods=['POST', 'GET'])
def add_tests():
    if 'user_id' not in session:
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –∫–∞–∫ —É—á–∏—Ç–µ–ª—å.", "warning")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –¢–æ–ª—å–∫–æ —É—á–∏—Ç–µ–ª—è –º–æ–≥—É—Ç –¥–æ–±–∞–≤–ª—è—Ç—å —Ç–µ—Å—Ç—ã.", "warning")
        if not user:
            session.pop('user_id', None)
        return redirect(url_for('auth.login'))
    
    if request.method == "POST":
        test_type = request.form.get('test_type')
        class_number = request.form.get('class_number')
        title = request.form.get('title')
        
        time_limit_str = request.form.get('time_limit')
        time_limit = int(time_limit_str) if time_limit_str and time_limit_str.isdigit() and int(time_limit_str) > 0 else None
        
        word_order_form = request.form.get('word_order', 'sequential') 
        word_count_form_str = request.form.get('word_count')
        word_count_form = int(word_count_form_str) if word_count_form_str and word_count_form_str.isdigit() and int(word_count_form_str) > 0 else None
        test_mode = request.form.get('test_mode', 'random_letters') if test_type == 'add_letter' else None
        
        new_test_params = {
            'title': title,
            'classs': class_number,
            'type': test_type,
            'link': generate_test_link(),
            'created_by': user.id,
            'time_limit': time_limit,
            'word_order': word_order_form,
            'test_mode': test_mode,
            'is_active': True
        }

        words_data_source = []
        word_source_type = request.form.get('word_source_type', 'modules_only')
        selected_module_identifiers = []
        if word_source_type in ['modules_only', 'modules_and_custom']:
            selected_module_identifiers = request.form.getlist('modules[]')

        custom_words_text = []
        custom_translations_text = []
        if word_source_type in ['custom_only', 'modules_and_custom']:
            custom_words_text = request.form.getlist('custom_words[]')
            custom_translations_text = request.form.getlist('custom_translations[]')

        module_words_list = []
        if selected_module_identifiers:
            for module_identifier in selected_module_identifiers:
                try:
                    class_num, unit, module_name = module_identifier.split('|')
                    module_words_db = Word.query.filter_by(classs=class_num, unit=unit, module=module_name).all()
                    for mw in module_words_db:
                        module_words_list.append({'id': mw.id, 'word': mw.word, 'perevod': mw.perevod, 'source': 'module'})
                except ValueError:
                    flash(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –º–æ–¥—É–ª—è: {module_identifier}", "warning")

        if test_type == 'dictation':
            dictation_word_source = request.form.get('dictation_word_source')
            new_test_params['dictation_word_source'] = dictation_word_source
            if dictation_word_source == 'all_module':
                words_data_source.extend(module_words_list)
                new_test_params['word_count'] = word_count_form
            elif dictation_word_source == 'random_from_module':
                dictation_num_random_words_str = request.form.get('dictation_random_word_count')
                dictation_num_random_words = int(dictation_num_random_words_str) if dictation_num_random_words_str and dictation_num_random_words_str.isdigit() and int(dictation_num_random_words_str) > 0 else 0
                new_test_params['word_count'] = dictation_num_random_words if dictation_num_random_words > 0 else None
                if module_words_list and dictation_num_random_words > 0:
                    random.shuffle(module_words_list)
                    words_data_source.extend(module_words_list[:dictation_num_random_words])
            elif dictation_word_source == 'selected_specific':
                specific_word_ids_str = request.form.getlist('dictation_specific_word_ids[]')
                specific_word_ids = [int(id_str) for id_str in specific_word_ids_str if id_str.isdigit()]
                new_test_params['dictation_selected_words'] = json.dumps(specific_word_ids)
                if specific_word_ids:
                    selected_db_words = Word.query.filter(Word.id.in_(specific_word_ids)).all()
                    for sw in selected_db_words:
                        words_data_source.append({'id': sw.id, 'word': sw.word, 'perevod': sw.perevod, 'source': 'module_specific'})
                new_test_params['word_count'] = word_count_form
            for cw_text, ct_text in zip(custom_words_text, custom_translations_text):
                if cw_text and ct_text:
                    words_data_source.append({'word': cw_text, 'perevod': ct_text, 'source': 'custom'})
        else: 
            new_test_params['word_count'] = word_count_form
            words_data_source.extend(module_words_list)
            for cw_text, ct_text in zip(custom_words_text, custom_translations_text):
                if cw_text and ct_text:
                    words_data_source.append({'word': cw_text, 'perevod': ct_text, 'source': 'custom'})
        
        if len(selected_module_identifiers) == 1:
            try:
                _, unit_single, module_single = selected_module_identifiers[0].split('|')
                new_test_params['unit'] = unit_single
                new_test_params['module'] = module_single
            except ValueError:
                new_test_params['unit'] = "N/A"
                new_test_params['module'] = "N/A"
        elif len(selected_module_identifiers) > 1:
            new_test_params['unit'] = "Multiple"
            new_test_params['module'] = "Multiple"
        else: # No modules selected or error
            new_test_params['unit'] = "N/A" # Default if no specific module context
            new_test_params['module'] = "N/A"

        new_test = Test(**new_test_params)
        db.session.add(new_test)
        
        try:
            db.session.commit() # Commit Test object to get its ID

            if new_test.word_order == 'random':
                random.shuffle(words_data_source)
            
            final_word_count_to_use = new_test.word_count
            if final_word_count_to_use is not None and final_word_count_to_use > 0:
                words_data_source = words_data_source[:final_word_count_to_use]
            elif final_word_count_to_use == 0: # Explicitly 0 means no words
                words_data_source = []

            # If no words are sourced, and it's manual_letters, it will show "no words to configure" on the next page.
            # This might be okay, or you could flash a specific warning here and redirect differently.
            # For now, allowing it to proceed.

            for idx, word_entry in enumerate(words_data_source):
                original_word_text = word_entry['word']
                original_translation = word_entry['perevod']
                current_word_for_test_word_model = original_word_text 
                prompt_for_test_word_model = original_translation   
                options_db = None
                missing_letters_positions_db = None
                correct_answer_for_db = original_word_text

                if test_type == 'add_letter':
                    prompt_for_test_word_model = original_translation
                    if test_mode == 'random_letters':
                        if len(original_word_text) > 0:
                            num_letters_to_remove = random.randint(1, min(2, len(original_word_text)))
                            positions_zero_indexed = sorted(random.sample(range(len(original_word_text)), num_letters_to_remove))
                            actual_missing_letters_list = [original_word_text[pos] for pos in positions_zero_indexed]
                            correct_answer_for_db = "".join(actual_missing_letters_list)
                            word_with_gaps_list = list(original_word_text)
                            for pos in positions_zero_indexed: word_with_gaps_list[pos] = '_'
                            current_word_for_test_word_model = "".join(word_with_gaps_list)
                            missing_letters_positions_db = ','.join(str(pos + 1) for pos in positions_zero_indexed)
                        else:
                            current_word_for_test_word_model = ""; correct_answer_for_db = ""; missing_letters_positions_db = ""
                    elif test_mode == 'manual_letters':
                        current_word_for_test_word_model = original_word_text
                        correct_answer_for_db = "" 
                        missing_letters_positions_db = None  
                            
                elif test_type == 'multiple_choice_single':
                    current_word_for_test_word_model = original_translation 
                    prompt_for_test_word_model = "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥:" 
                    correct_answer_for_db = original_word_text
                    all_other_words = [w.word for w in Word.query.filter(Word.classs == class_number, Word.word != original_word_text).limit(20).all()]
                    num_wrong_options = 3
                    wrong_options_list = random.sample(all_other_words, min(num_wrong_options, len(all_other_words)))
                    current_options_list_for_db = wrong_options_list + [original_word_text]
                    random.shuffle(current_options_list_for_db)
                    options_db = '|'.join(current_options_list_for_db)

                elif test_type == 'dictation':
                    current_word_for_test_word_model = ''.join(['_'] * len(original_word_text))
                    prompt_for_test_word_model = original_translation 
                    correct_answer_for_db = original_word_text

                elif test_type == 'true_false':
                    if word_entry['source'] == 'custom':
                        current_word_for_test_word_model = original_word_text
                        correct_answer_for_db = original_translation if original_translation.lower() in ['true', 'false'] else "True"
                    else:
                        current_word_for_test_word_model = f"{original_word_text} - {original_translation}"
                        correct_answer_for_db = "True"
                    prompt_for_test_word_model = "–í–µ—Ä–Ω–æ –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω–æ?"
                    options_db = "True|False"
                    
                elif test_type == 'fill_word':
                    current_word_for_test_word_model = original_translation
                    prompt_for_test_word_model = "–í–ø–∏—à–∏—Ç–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–µ —Å–ª–æ–≤–æ (–æ—Ä–∏–≥–∏–Ω–∞–ª):"
                    correct_answer_for_db = original_word_text

                elif test_type == 'multiple_choice_multiple':
                    current_word_for_test_word_model = original_translation
                    prompt_for_test_word_model = "–í—ã–±–µ—Ä–∏—Ç–µ –≤—Å–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã:"
                    correct_answer_for_db = original_word_text 
                    all_other_words = [w.word for w in Word.query.filter(Word.classs == class_number, Word.word != original_word_text).limit(20).all()]
                    num_options_total = 4
                    num_wrong_options_needed = num_options_total - 1
                    wrong_options_list = random.sample(all_other_words, min(num_wrong_options_needed, len(all_other_words)))
                    current_options_list_for_db = wrong_options_list + [original_word_text]
                    while len(current_options_list_for_db) < num_options_total:
                        current_options_list_for_db.append(f"–í–∞—Ä–∏–∞–Ω—Ç {len(current_options_list_for_db)+1}")
                    random.shuffle(current_options_list_for_db)
                    options_db = '|'.join(current_options_list_for_db[:num_options_total])

                test_word_entry = TestWord(
                    test_id=new_test.id,
                    word=current_word_for_test_word_model,
                    perevod=prompt_for_test_word_model,
                    correct_answer=correct_answer_for_db,
                    options=options_db,
                    missing_letters=missing_letters_positions_db,
                    word_order=idx
                )
                db.session.add(test_word_entry)
            
            db.session.commit() # Commit TestWord objects

            if new_test.type == 'add_letter' and new_test.test_mode == 'manual_letters':
                flash("–¢–µ—Å—Ç —Å–æ–∑–¥–∞–Ω. –¢–µ–ø–µ—Ä—å —É–∫–∞–∂–∏—Ç–µ, –∫–∞–∫–∏–µ –±—É–∫–≤—ã –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –≤ —Å–ª–æ–≤–∞—Ö.", "info")
                return redirect(url_for('configure_test_words', test_id=new_test.id))
            else:
                flash("–¢–µ—Å—Ç —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω!", "success")
                return redirect(url_for('tests')) # Or consider redirecting to test_details

        except Exception as e:
            db.session.rollback()
            # If new_test.id exists, it means the Test object might have been committed
            # before the exception during TestWord creation or the second commit.
            # So, we explicitly delete the Test object to avoid an orphaned Test.
            if new_test.id:
                test_to_delete = Test.query.get(new_test.id)
                if test_to_delete:
                    db.session.delete(test_to_delete)
                    db.session.commit() # Commit the deletion of the orphaned Test
            
            flash(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ —Ç–µ—Å—Ç–∞ –∏–ª–∏ –µ–≥–æ —Å–ª–æ–≤: {str(e)}", "error")
            classes_get = [str(i) for i in range(1, 12)]
            # Pass back form data to repopulate the form
            return render_template("add_tests.html", classes=classes_get, error_message=str(e), **request.form)

    else: # GET request
        classes = [str(i) for i in range(1, 12)]
        # Pass any form data back if it was a failed POST that rendered GET
        form_data = request.form if request.form else {}
        return render_template("add_tests.html", classes=classes, **form_data)

@app.route("/tests")
def tests():
    if 'user_id' not in session:
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user:
        session.pop('user_id', None)
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))

    show_archived = request.args.get('show_archived', 'false') == 'true'
    
    tests_data = []
    if user.teacher == 'yes':
        # Teachers see all tests they created
        tests_query = Test.query.filter_by(created_by=user.id, is_active=not show_archived).order_by(Test.created_at.desc()).all()
        for test_item in tests_query:
            students_in_class = User.query.filter_by(class_number=test_item.classs, teacher='no').count()
            
            # Corrected logic for completed_results: count only student completions
            completed_count = db.session.query(TestResult.id).join(User, TestResult.user_id == User.id).filter(
                TestResult.test_id == test_item.id,
                TestResult.completed_at.isnot(None),
                User.teacher == 'no',  # Ensure only student results are counted
                TestResult.started_at >= test_item.created_at # New condition
            ).count()

            progress = 0
            if students_in_class > 0:
                progress = round((completed_count / students_in_class) * 100)
            
            tests_data.append({
                'test': test_item,
                'students_in_class': students_in_class,
                'completed_count': completed_count,
                'progress': progress
            })
    else:
        # Students see only tests for their class
        tests_query = Test.query.filter_by(classs=user.class_number, is_active=not show_archived).order_by(Test.created_at.desc()).all()
        # For students, we need to check if they completed the test to link to results, especially for archived.
        for test_item in tests_query:
            student_result = TestResult.query.filter_by(
                test_id=test_item.id,
                user_id=user.id,
            ).filter(TestResult.completed_at.isnot(None)).first()

            tests_data.append({
                'test': test_item,
                'students_in_class': 0, # Not relevant for student's direct view here
                'completed_count': 0, # Not relevant
                'progress': 0, # Not relevant
                'student_completed_result_id': student_result.id if student_result else None
            })


    return render_template('tests.html', tests_data=tests_data, show_archived=show_archived, is_teacher=user.teacher == 'yes')

@app.route("/api/tests_progress")
def api_tests_progress():
    if 'user_id' not in session:
        return jsonify({"error": "Unauthorized"}), 401

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        return jsonify({"error": "Forbidden"}), 403

    # We only care about active tests for live progress updates on the main /tests page
    tests_query = Test.query.filter_by(created_by=user.id, is_active=True).order_by(Test.created_at.desc()).all()
    
    progress_data = []
    for test_item in tests_query:
        students_in_class = User.query.filter_by(class_number=test_item.classs, teacher='no').count()
        
        completed_count = db.session.query(TestResult.id).join(User, TestResult.user_id == User.id).filter(
            TestResult.test_id == test_item.id,
            TestResult.completed_at.isnot(None),
            User.teacher == 'no',
            TestResult.started_at >= test_item.created_at # New condition
        ).count()

        progress_data.append({
            'id': test_item.id,
            'title': test_item.title, # Optional: for debugging or richer display
            'students_in_class': students_in_class,
            'completed_count': completed_count
        })
        
    return jsonify(progress_data)

@app.route("/words/json")
def get_words_json():
    words = Word.query.all()
    data = {}
    for w in words:
        if w.classs not in data:
            data[w.classs] = {}
        if w.unit not in data[w.classs]:
            data[w.classs][w.unit] = []
        data[w.classs][w.unit].append([w.word, w.perevod])
    return jsonify(data)

@app.route("/get_words_for_module_selection")
def get_words_for_module_selection():
    module_identifiers_str = request.args.get('modules', '')
    if not module_identifiers_str:
        return jsonify({"words": [], "error": "No modules provided"})

    module_identifiers = module_identifiers_str.split(',')
    words_list = []
    seen_word_ids = set()

    for module_identifier in module_identifiers:
        parts = module_identifier.split('|')
        if len(parts) == 3:
            class_num, unit_name, module_name = parts
            try:
                module_words_db = Word.query.filter_by(
                    classs=class_num,
                    unit=unit_name,
                    module=module_name
                ).order_by(Word.word).all()
                
                for mw in module_words_db:
                    if mw.id not in seen_word_ids:
                        words_list.append({
                            "id": mw.id,
                            "text": f"{mw.word} - {mw.perevod}" # Format for display
                        })
                        seen_word_ids.add(mw.id)
            except Exception as e:
                # Log error or handle it as needed
                print(f"Error fetching words for module {module_identifier}: {e}") # Basic logging
                # Optionally, you could add an error message to the response for this module
                pass # Continue to next module identifier
        else:
            # Log invalid module identifier
            print(f"Invalid module identifier format: {module_identifier}")
            pass # Continue to next module identifier
            
    return jsonify({"words": words_list})

@app.route('/api/test/<int:test_db_id>/dictation_words', methods=['GET'])
def api_test_dictation_words(test_db_id):
    if 'user_id' not in session:
        return jsonify({'error': 'Authentication required'}), 401

    user = User.query.get(session['user_id'])
    if not user:
        return jsonify({'error': 'User not found'}), 403 # Or 401

    test = Test.query.get(test_db_id)
    if not test:
        abort(404)

    if test.type != 'dictation':
        return jsonify({'error': 'Invalid test type for this endpoint'}), 400

    # Teacher preview or student taking test for their class
    if user.teacher != 'yes':
        if test.classs != user.class_number:
            return jsonify({'error': 'Access denied: Test is for a different class'}), 403
        if not test.is_active:
             return jsonify({'error': 'Access denied: Test is not active'}), 403


    test_words_query = TestWord.query.filter_by(test_id=test.id)

    if test.word_order == 'random':
        # –î–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º seed –Ω–∞ –æ—Å–Ω–æ–≤–µ user_id –∏ test_id
        # —á—Ç–æ–±—ã –ø–æ—Ä—è–¥–æ–∫ –±—ã–ª –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º –¥–ª—è –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —Ç–µ—Å—Ç–∞
        test_word_objects = list(test_words_query.all()) # Convert to list to shuffle
        
        # –°–æ–∑–¥–∞–µ–º –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π seed –Ω–∞ –æ—Å–Ω–æ–≤–µ user_id –∏ test_id
        seed_value = hash(f"{user.id}_{test.id}") % (2**32)
        random.seed(seed_value)
        random.shuffle(test_word_objects)
        random.seed()  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º seed –¥–ª—è –¥—Ä—É–≥–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
    else: # 'sequential' or any other case defaults to ordered
        test_word_objects = test_words_query.order_by(TestWord.word_order).all()

    words_data = []
    for tw in test_word_objects:
        words_data.append({
            'id': tw.id,
            'word_placeholder': tw.word,  # This is the gapped/empty string for dictation display
            'prompt': tw.perevod,         # The translation/hint given to the student
            'correct_answer': tw.correct_answer # The actual word the student needs to type
            # 'options': tw.options, # Not typically used for dictation
            # 'missing_letters': tw.missing_letters # Not typically used for dictation
        })

    return jsonify({'words': words_data, 'test_title': test.title})

# Helper function for fetching test words for various types
def _get_test_words_api_data(test_db_id, expected_test_type_slug):
    if 'user_id' not in session:
        return jsonify({'error': 'Authentication required'}), 401

    user = User.query.get(session['user_id'])
    if not user:
        return jsonify({'error': 'User not found'}), 403

    test = Test.query.get_or_404(test_db_id)

    # Teacher preview or student taking test for their class
    if user.teacher != 'yes':
        if test.classs != user.class_number:
            return jsonify({'error': 'Access denied: Test is for a different class'}), 403
        if not test.is_active:
            return jsonify({'error': 'Access denied: Test is not active'}), 403

    # Validate test type if slug implies a specific type (e.g. multiple_choice for multiple_choice_single)
    db_test_type = test.type
    if expected_test_type_slug == 'multiple_choice_single_words' and db_test_type != 'multiple_choice':
        return jsonify({'error': f'Invalid test type for this endpoint. Expected multiple_choice, got {db_test_type}'}), 400
    elif expected_test_type_slug != 'multiple_choice_single_words' and db_test_type != expected_test_type_slug.replace('_words', ''):
         return jsonify({'error': f'Invalid test type for this endpoint. Expected {expected_test_type_slug.replace("_words", "")}, got {db_test_type}'}), 400


    test_words_query = TestWord.query.filter_by(test_id=test.id)

    if test.word_order == 'random':
        # –î–ª—è —Å–ª—É—á–∞–π–Ω–æ–≥–æ –ø–æ—Ä—è–¥–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º seed –Ω–∞ –æ—Å–Ω–æ–≤–µ user_id –∏ test_id
        # —á—Ç–æ–±—ã –ø–æ—Ä—è–¥–æ–∫ –±—ã–ª –æ–¥–∏–Ω–∞–∫–æ–≤—ã–º –¥–ª—è –æ–¥–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —Ç–µ—Å—Ç–∞
        test_word_objects = list(test_words_query.all()) # Convert to list to shuffle
        
        # –°–æ–∑–¥–∞–µ–º –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–π seed –Ω–∞ –æ—Å–Ω–æ–≤–µ user_id –∏ test_id
        seed_value = hash(f"{user.id}_{test.id}") % (2**32)
        random.seed(seed_value)
        random.shuffle(test_word_objects)
        random.seed()  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º seed –¥–ª—è –¥—Ä—É–≥–∏—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
    else: # 'sequential' or any other case defaults to ordered
        test_word_objects = test_words_query.order_by(TestWord.word_order).all()

    return test, test_word_objects, user


@app.route('/api/test/<int:test_db_id>/add_letter_words', methods=['GET'])
def api_test_add_letter_words(test_db_id):
    result = _get_test_words_api_data(test_db_id, 'add_letter_words')
    if not isinstance(result, tuple): # Error response from helper
        return result
    test, test_word_objects, user = result

    words_data = []
    for tw in test_word_objects:
        words_data.append({
            'id': tw.id,
            'word_gapped': tw.word, # The word with underscores
            'prompt': tw.perevod,   # Translation or hint
            'num_inputs': len(tw.correct_answer) if tw.correct_answer else 0,
            'correct_answer_letters': tw.correct_answer # The actual letters to be filled
        })
    return jsonify({'words': words_data, 'test_title': test.title, 'test_type': test.type, 'test_mode': test.test_mode})

@app.route('/api/test/<int:test_db_id>/true_false_words', methods=['GET'])
def api_test_true_false_words(test_db_id):
    result = _get_test_words_api_data(test_db_id, 'true_false_words')
    if not isinstance(result, tuple):
        return result
    test, test_word_objects, user = result

    words_data = []
    for tw in test_word_objects:
        words_data.append({
            'id': tw.id,
            'statement': tw.word, # The statement to be judged
            'prompt': tw.perevod,  # Usually "–í–µ—Ä–Ω–æ –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω–æ?" or a hint
            'options': tw.options.split('|') if tw.options else ["True", "False"], # Should be ["True", "False"]
            'correct_answer': tw.correct_answer # "True" or "False"
        })
    return jsonify({'words': words_data, 'test_title': test.title, 'test_type': test.type})

@app.route('/api/test/<int:test_db_id>/multiple_choice_single_words', methods=['GET'])
def api_test_multiple_choice_single_words(test_db_id):
    # Note: DB test.type is 'multiple_choice' for this
    result = _get_test_words_api_data(test_db_id, 'multiple_choice_single_words')
    if not isinstance(result, tuple):
        return result
    test, test_word_objects, user = result

    words_data = []
    for tw in test_word_objects:
        words_data.append({
            'id': tw.id,
            'question': tw.word, # The question text (e.g., word to translate, or definition)
            'prompt': tw.perevod, # Supporting prompt like "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥:"
            'options': tw.options.split('|') if tw.options else [],
            'correct_answer': tw.correct_answer
        })
    return jsonify({'words': words_data, 'test_title': test.title, 'test_type': test.type})


@app.route('/api/test/<int:test_db_id>/fill_word_words', methods=['GET'])
def api_test_fill_word_words(test_db_id):
    result = _get_test_words_api_data(test_db_id, 'fill_word_words')
    if not isinstance(result, tuple):
        return result
    test, test_word_objects, user = result

    words_data = []
    for tw in test_word_objects:
        words_data.append({
            'id': tw.id,
            'question_prompt': tw.word, # The prompt, e.g., a sentence with a blank or a definition
            'instruction': tw.perevod, # Specific instruction like "–í–ø–∏—à–∏—Ç–µ —Å–ª–æ–≤–æ"
            'correct_answer': tw.correct_answer
        })
    return jsonify({'words': words_data, 'test_title': test.title, 'test_type': test.type})

@app.route('/api/test/<int:test_db_id>/multiple_choice_multiple_words', methods=['GET'])
def api_test_multiple_choice_multiple_words(test_db_id):
    result = _get_test_words_api_data(test_db_id, 'multiple_choice_multiple_words')
    if not isinstance(result, tuple):
        return result
    test, test_word_objects, user = result

    words_data = []
    for tw in test_word_objects:
        words_data.append({
            'id': tw.id,
            'question': tw.word, # The question or statement
            'prompt': tw.perevod, # Supporting prompt like "–í—ã–±–µ—Ä–∏—Ç–µ –≤—Å–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã:"
            'options': tw.options.split('|') if tw.options else [],
            'correct_answers_pipe_separated': tw.correct_answer # Correct answers, e.g. "ans1|ans3"
        })
    return jsonify({'words': words_data, 'test_title': test.title, 'test_type': test.type})

@app.route("/test/<id>", methods=['GET', 'POST'])
def test_id(id):
    if 'user_id' not in session:
        flash("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –≤ —Å–∏—Å—Ç–µ–º—É, —á—Ç–æ–±—ã –ø—Ä–æ–π—Ç–∏ —Ç–µ—Å—Ç.", "error")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user:
        session.pop('user_id', None)
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))
        
    # –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–µ—Å—Å–∏–∏ –∏ cookies
    print(f"DEBUG: test_id route - session data: {dict(session)}")
    print(f"DEBUG: Current user: {user.nick}, ID: {user.id}")
    print(f"DEBUG: Cookies: {request.cookies}")
    
    if 'active_test_result_id' in session:
        print(f"DEBUG: active_test_result_id from session: {session['active_test_result_id']}")
    else:
        print("DEBUG: No active_test_result_id in session")
        
    if 'active_test_result_id' in request.cookies:
        print(f"DEBUG: active_test_result_id from cookie: {request.cookies.get('active_test_result_id')}")

    test = Test.query.filter_by(link=id).first()
    if not test:
        abort(404)

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ —Ä–µ–∂–∏–º–æ–º –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –¥–ª—è —É—á–∏—Ç–µ–ª—è
    is_teacher_preview_mode = False
    if user.teacher == 'yes' and (session.get('is_teacher_preview', False) or session.get('test_link') == id):
        is_teacher_preview_mode = True
        print("DEBUG: Teacher preview mode detected")
    
    # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π —Ç–µ—Å—Ç –∏–∑ —Å–µ—Å—Å–∏–∏ –∏–ª–∏ cookie –¥–ª—è —Å—Ç—É–¥–µ–Ω—Ç–∞
    test_result = None
    
    # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –∏–∑ —Å–µ—Å—Å–∏–∏
    if 'active_test_result_id' in session:
        test_result_id = session['active_test_result_id']
        test_result = TestResult.query.get(test_result_id)
        print(f"DEBUG: Found test_result from session: {test_result}")
    
    # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ –≤ —Å–µ—Å—Å–∏–∏, –ø—Ä–æ–±—É–µ–º –∏–∑ cookie
    if not test_result and 'active_test_result_id' in request.cookies:
        try:
            test_result_id = int(request.cookies.get('active_test_result_id'))
            test_result = TestResult.query.get(test_result_id)
            if test_result:
                # –ï—Å–ª–∏ –Ω–∞—à–ª–∏ –≤ cookie, —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Å–µ—Å—Å–∏—é –¥–ª—è –±—É–¥—É—â–∏—Ö –∑–∞–ø—Ä–æ—Å–æ–≤
                session['active_test_result_id'] = test_result_id
                session['test_link'] = id
                session.modified = True
                print(f"DEBUG: Found test_result from cookie and saved to session: {test_result}")
        except (ValueError, TypeError):
            print("DEBUG: Invalid test_result_id in cookie")
    
    # –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ —É—á–∏—Ç–µ–ª—å –∏ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Ç–µ—Å—Ç–∞ –Ω–∏ –≤ —Å–µ—Å—Å–∏–∏, –Ω–∏ –≤ cookie,
    # –ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–π —Ç–µ—Å—Ç –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ —ç—Ç–æ–≥–æ —Ç–µ—Å—Ç–∞
    if user.teacher == 'no' and not test_result:
        incomplete_result = TestResult.query.filter_by(
            test_id=test.id,
            user_id=user.id,
            completed_at=None
        ).first()
        
        if incomplete_result:
            test_result = incomplete_result
            session['active_test_result_id'] = incomplete_result.id
            session['test_link'] = id
            session.modified = True
            print(f"DEBUG: Found incomplete test result from database: {test_result}")
        else:
            print("DEBUG: Student without active test result, redirecting to take_test")
            flash("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ —Ç–µ—Å—Ç —Å –Ω–∞—á–∞–ª—å–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã.", "warning")
            return redirect(url_for('take_test', test_link=id))

    # Handle POST requests (submitting answers)
    if request.method == 'POST':
        if user.teacher == 'yes':
            # Teachers in preview mode do not save results
            flash("–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —Ç–µ—Å—Ç–∞. –û—Ç–≤–µ—Ç—ã –Ω–µ –±—ã–ª–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã.", "info")
            return redirect(url_for('test_details', test_id=test.id))
        
        # --- STUDENT SUBMISSION LOGIC (remains largely the same) ---
        if not test_result: # Should not happen if student started test correctly
            # This indicates a potential issue or direct POST without GET,
            # or test_result was not initiated properly.
            # For robustness, try to get or create one.
            test_result = TestResult.query.filter_by(
                test_id=test.id,
                user_id=user.id,
                completed_at=None
            ).first()
            if not test_result: # If still not found, student likely hasn't started.
                                # This situation ideally is caught by GET request flow.
                flash("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –∞–∫—Ç–∏–≤–Ω—ã–π —Å–µ–∞–Ω—Å —Ç–µ—Å—Ç–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ —Ç–µ—Å—Ç —Å–Ω–∞—á–∞–ª–∞.", "warning")
                return redirect(url_for('take_test', test_link=test.link)) # Redirect to start

        # Process answers
        answers_dict_for_json = {} # To store in TestResult.answers (JSON)
        score = 0
        processed_answers_for_db = [] # To store TestAnswer objects

        for word in test.test_words:
            user_input_answer = request.form.get(f'answer{word.id}', '').strip()
            # Storing raw user input for TestAnswer, lowercasing for comparison
            user_answer_for_comparison = user_input_answer.lower()
            
            answers_dict_for_json[str(word.id)] = user_input_answer # Store original case for JSON

            is_this_answer_correct = False
            actual_correct_answer_for_comparison = word.correct_answer.lower()

            if test.type == 'add_letter':
                # For add_letter, word.correct_answer already holds the combined missing letters
                if user_answer_for_comparison == actual_correct_answer_for_comparison:
                    is_this_answer_correct = True
            elif test.type == 'multiple_choice_single' or test.type == 'multiple_choice_multiple':
                # For MC, word.correct_answer holds the correct option text
                if user_answer_for_comparison == actual_correct_answer_for_comparison:
                    is_this_answer_correct = True
            elif test.type == 'dictation':
                if user_answer_for_comparison == actual_correct_answer_for_comparison:
                    is_this_answer_correct = True
            elif test.type == 'true_false':
                # For true_false, correct_answer is 'True' or 'False'
                if user_input_answer.capitalize() == word.correct_answer: # Comparison is case-insensitive for T/F but store as True/False
                    is_this_answer_correct = True
            elif test.type == 'fill_word':
                if user_answer_for_comparison == actual_correct_answer_for_comparison:
                    is_this_answer_correct = True
            else: # Fallback for any other types or if logic is missing
                if user_answer_for_comparison == actual_correct_answer_for_comparison:
                    is_this_answer_correct = True
            
            if is_this_answer_correct:
                score += 1
            
            processed_answers_for_db.append({
                'test_word_id': word.id,
                'user_answer': user_input_answer, # Store raw input
                'is_correct': is_this_answer_correct
            })

        # Update test result
        test_result.score = int((score / len(test.test_words)) * 100) if len(test.test_words) > 0 else 0
        test_result.correct_answers = score
        completion_time = datetime.utcnow()
        test_result.completed_at = completion_time
        
        # Calculate time taken in minutes (safe calculation)
        if test_result.started_at:
            time_diff = completion_time - test_result.started_at
            test_result.time_taken = max(0, int(time_diff.total_seconds() / 60))  # Convert to minutes, ensure non-negative
        else:
            test_result.time_taken = 0  # Fallback if started_at is missing
            
        test_result.answers = json.dumps(answers_dict_for_json) # Keep the JSON dump as it might be used elsewhere or for quick view
        
        # Add TestAnswer instances
        for ans_data in processed_answers_for_db:
            test_answer_entry = TestAnswer(
                test_result_id=test_result.id,
                test_word_id=ans_data['test_word_id'],
                user_answer=ans_data['user_answer'],
                is_correct=ans_data['is_correct']
            )
            db.session.add(test_answer_entry)

        db.session.commit()

        return redirect(url_for('test_results', test_id=test.id, result_id=test_result.id))

    # --- HANDLE GET REQUESTS ---

    # Teacher Preview Logic for GET
    if user.teacher == 'yes':
        # Teachers can preview their own tests or any active test.
        # If archived, only creator can preview.
        if not test.is_active and test.created_by != user.id:
            flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç –∑–∞–∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞–Ω, –∏ –≤—ã –Ω–µ —è–≤–ª—è–µ—Ç–µ—Å—å –µ–≥–æ —Å–æ–∑–¥–∞—Ç–µ–ª–µ–º. –ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –Ω–µ–≤–æ–∑–º–æ–∂–µ–Ω.", "warning")
            return redirect(url_for('tests'))
        
        is_teacher_preview_mode = True
        # For teachers, no TestResult is needed for preview.
        # Time is unlimited for preview.
        remaining_time_seconds = -1 # Indicator for unlimited time
        test_result = None # Explicitly set to None for teacher preview context
    
    # Student Test-Taking Logic for GET
    else: # user.teacher == 'no'
        # Check if student has access to this test (class matches)
        print(f"DEBUG: test.classs={test.classs}, user.class_number={user.class_number}")
        if test.classs != user.class_number:
            flash(f"–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω: —Ç–µ—Å—Ç –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –∫–ª–∞—Å—Å–∞ {test.classs}, –∞ –≤—ã –≤ –∫–ª–∞—Å—Å–µ {user.class_number}.", "error")
            return redirect(url_for('tests'))

        # Check if test is active (students cannot take archived tests)
        if not test.is_active:
            flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç –±–æ–ª—å—à–µ –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω.", "error")
            return redirect(url_for('tests'))

        # Get or create test result for students
        test_result = TestResult.query.filter_by(
            test_id=test.id,
            user_id=user.id,
            completed_at=None
        ).first()

        if test_result: # An incomplete test was found
            if not test_result.started_at: # Ensure it has a start time if resuming
                test_result.started_at = datetime.utcnow()
                db.session.commit()
        else: # No incomplete test_result was found
            completed_test_run = TestResult.query.filter_by(
                test_id=test.id,
                user_id=user.id
            ).filter(TestResult.completed_at.isnot(None)).order_by(TestResult.completed_at.desc()).first()

            if completed_test_run:
                flash("–í—ã —É–∂–µ –∑–∞–≤–µ—Ä—à–∏–ª–∏ —ç—Ç–æ—Ç —Ç–µ—Å—Ç. –ü—Ä–æ—Å–º–æ—Ç—Ä –≤–∞—à–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.", "info")
                return redirect(url_for('test_results', test_id=test.id, result_id=completed_test_run.id))
            else:
                # Student is starting for the first time
                test_result = TestResult(
                    test_id=test.id,
                    user_id=user.id,
                    total_questions=len(test.test_words) if test.test_words else 0,
                    started_at=datetime.utcnow()
                )
                db.session.add(test_result)
                db.session.commit()
        
        # Calculate remaining time for students
        remaining_time_seconds = -1 # Default for unlimited time
        time_is_up_on_server = False
        if test.time_limit and test.time_limit > 0 and test_result and test_result.started_at:
            elapsed_seconds = (datetime.utcnow() - test_result.started_at).total_seconds()
            total_duration_seconds = test.time_limit * 60
            remaining_time_seconds = max(0, int(total_duration_seconds - elapsed_seconds))
            if remaining_time_seconds == 0:
                time_is_up_on_server = True
                if not test_result.completed_at: # Auto-submit if time is up on server
                    flash("–í—Ä–µ–º—è –Ω–∞ —Ç–µ—Å—Ç –≤—ã—à–ª–æ. –¢–µ—Å—Ç –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.", "warning")
                    # Simplified auto-submit: mark as completed. Client should ideally handle submission.
                    # For a more robust auto-submit, answers would need to be saved progressively.
                    # Consider if answers submitted via form post-timeout should be accepted or rejected.
                    # The POST handler has its own time check.
                    pass # Let client-side timer trigger submission for now.


    # Common rendering logic for both teachers (preview) and students (taking test)
    # The specific template and words_list will depend on test.type

    if test.type == 'add_letter':
        if not is_teacher_preview_mode: # Student specific checks
            if test.test_mode == 'manual_letters':
                if test.test_words and any(tw.missing_letters is None for tw in test.test_words):
                    flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç (–≤—Å—Ç–∞–≤–∏—Ç—å –±—É–∫–≤—ã) –µ—â–µ –Ω–µ –ø–æ–ª–Ω–æ—Å—Ç—å—é –Ω–∞—Å—Ç—Ä–æ–µ–Ω —É—á–∏—Ç–µ–ª–µ–º –∏ –ø–æ–∫–∞ –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω –¥–ª—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è.", "warning")
                    return redirect(url_for('tests'))

        # words_list = []
        # for word in test.test_words:
            # Debug prints can be removed in production
            # print(f"--- Word Details for Test '{test.title}' (Link: {test.link}) ---")
            # print(f"  TestWord ID: {word.id}")
            # print(f"  Gapped Word (to display): '{word.word}'")
            # print(f"  Translation/Hint: '{word.perevod}'")
            # print(f"  Correct letters (to be inserted by student): '{word.correct_answer}'")
            # if word.missing_letters:
            #     print(f"  Missing letter positions (1-indexed in original word): '{word.missing_letters}'")
            # print(f"  Number of letters to input: {len(word.correct_answer) if word.correct_answer else 0}")
            # print("-" * 40)
            # words_list.append({
            #     'id': word.id,
            #     'word': word.word,
            #     'perevod': word.perevod,
            #     'num_inputs': len(word.correct_answer) if word.correct_answer else 0
            # })
        return render_template('test_add_letter.html', 
                             # words=words_list,
                             test_id=id, # link
                             test_result=test_result, # Will be None for teacher preview
                             time_limit=test.time_limit,
                             remaining_time_seconds=remaining_time_seconds,
                             test_title=test.title, 
                             test_db_id=test.id, # numerical ID
                             is_teacher_preview=is_teacher_preview_mode) # Pass the preview flag
    elif test.type == 'dictation':
        # This block was modified in the previous step, ensuring it remains correct.
        # Debug prints can be removed
        # print(f"DEBUG: Accessing dictation test with link: {id}")
        # print(f"DEBUG: Test object: {test}")
        # print(f"DEBUG: Test.test_words count: {len(test.test_words) if test.test_words else 0}")
        # if test.test_words:
        #     for i, tw in enumerate(test.test_words):
        #         print(f"DEBUG: TestWord {i}: id={tw.id}, word='{tw.word}', perevod='{tw.perevod}', correct_answer='{tw.correct_answer}'")
        
        # words_list = [(word.word, word.perevod, word.correct_answer, word.id) for word in test.test_words]
        
        current_test_result_for_template = test_result # Use the one determined by student/teacher logic
        if is_teacher_preview_mode:
            current_test_result_for_template = None # Ensure no result object for teacher preview

        return render_template('test_dictation.html', 
                             test_title=test.title,
                             # words_data=words_list, # Removed as per requirement
                             test_link_id=id,
                             current_test_result=current_test_result_for_template, # Pass the correct result object
                             time_limit_seconds=test.time_limit * 60 if test.time_limit else 0,
                             remaining_time_seconds=remaining_time_seconds,
                             test_db_id=test.id,
                             is_teacher_preview=is_teacher_preview_mode) # Pass the preview flag
    elif test.type == 'true_false':
        # words_list = [(word.word, word.perevod, word.id) for word in test.test_words] # Added word.id
        return render_template('test_true_false.html',
                             # words=words_list,
                             test_id=id, # link
                             test_result=test_result, # Will be None for teacher preview
                             time_limit=test.time_limit,
                             remaining_time_seconds=remaining_time_seconds,
                             test_title=test.title,
                             test_db_id=test.id,
                             is_teacher_preview=is_teacher_preview_mode)
    elif test.type == 'multiple_choice':
        # words_list = []
        # for word in test.test_words:
            # options = word.options.split('|') if word.options else []
            # words_list.append({
                # 'id': word.id,
                # 'word': word.word, # This is the question (e.g., translation)
                # 'perevod': word.perevod, # This is the prompt (e.g., "Choose the correct word")
                # 'options': options
            # })
        return render_template('test_multiple_choice.html', 
                             # words=words_list,
                             test_id=id, # link
                             test_result=test_result, # Will be None for teacher preview
                             time_limit=test.time_limit,
                             remaining_time_seconds=remaining_time_seconds,
                             test_title=test.title,
                             test_db_id=test.id,
                             is_teacher_preview=is_teacher_preview_mode)
    elif test.type == 'fill_word':
        # words_list = []
        # for word in test.test_words:
            # words_list.append({
                # 'id': word.id,
                # 'word': word.word, # This is the question (e.g., translation)
                # 'perevod': word.perevod # This is the prompt (e.g., "Fill in the original word")
            # })
        return render_template('test_fill_word.html',
                             # words=words_list,
                             test_id=id, # link
                             test_result=test_result, # Will be None for teacher preview
                             time_limit=test.time_limit,
                             remaining_time_seconds=remaining_time_seconds,
                             test_title=test.title,
                             test_db_id=test.id,
                             is_teacher_preview=is_teacher_preview_mode)
    elif test.type == 'multiple_choice_multiple':
        # words_list = []
        # for word in test.test_words:
            # options = word.options.split('|') if word.options else []
            # words_list.append({
                # 'id': word.id,
                # 'word': word.word,       # Question (e.g., translation/definition)
                # 'perevod': word.perevod, # Prompt (e.g., "Select all correct options")
                # 'options': options
            # })
        return render_template('test_multiple_choice_multiple.html',
                             # words=words_list,
                             test_id=id, # link
                             test_result=test_result, # Will be None for teacher preview
                             time_limit=test.time_limit,
                             remaining_time_seconds=remaining_time_seconds,
                             test_title=test.title,
                             test_db_id=test.id,
                             is_teacher_preview=is_teacher_preview_mode)
    else:
        # Fallback for unknown test types
        flash(f"–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Ç–µ—Å—Ç–∞: {test.type}", "error")
        return redirect(url_for('tests'))

@app.route("/edit_profile")
def edit_profile():
    if 'user_id' not in session:
        return redirect(url_for('auth.login'))
    
    user = User.query.get(session['user_id'])
    if not user:
        session.pop('user_id', None)
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))
        
    return render_template('edit_profile.html', nick=user.nick, fio=user.fio)

@app.route("/save_profile", methods=["POST"])
def save_profile():
    fio = request.form.get("fio")
    nick = request.form.get("nick")

    user = User.query.filter_by(nick=nick).first()
    if user:
        user.fio = fio
        db.session.commit()

    return redirect("/profile")

# @app.route("/add_words", methods=['POST', 'GET']) # This route is now handled by words_bp
# def add_words():
#     ... (implementation removed) ...

@app.route("/get_units_for_class")
def get_units_for_class():
    class_name = request.args.get('class_name')
    if not class_name:
        return jsonify([])
    
    # Get unique units for the selected class
    units = db.session.query(Word.unit).filter(
        Word.classs == class_name
    ).distinct().all()
    
    return jsonify([unit[0] for unit in units])

@app.route("/get_modules_for_unit")
def get_modules_for_unit():
    class_name = request.args.get('class_name')
    unit_name = request.args.get('unit_name')
    
    if not class_name or not unit_name:
        return jsonify([])
    
    # Get unique modules for the selected class and unit
    modules = db.session.query(Word.module).filter(
        Word.classs == class_name,
        Word.unit == unit_name
    ).distinct().all()
    
    return jsonify([module[0] for module in modules])

@app.route('/get_word_count')
def get_word_count():
    class_name = request.args.get('class_name')
    unit_name = request.args.get('unit_name')
    module_name = request.args.get('module_name')
    units = request.args.getlist('units')
    modules = request.args.getlist('modules')
    
    if not class_name:
        return jsonify({'count': 0})
    
    query = Word.query.filter_by(classs=class_name)
    
    if units:
        # Multiple units
        query = query.filter(Word.unit.in_(units))
    elif unit_name:
        query = query.filter_by(unit=unit_name)
        
        if modules:
            # Multiple modules within a unit
            query = query.filter(Word.module.in_(modules))
        elif module_name:
            # Specific module
            query = query.filter_by(module=module_name)
    
    count = query.count()
    return jsonify({'count': count})

@app.route("/get_modules_for_sentence_game")
def get_modules_for_sentence_game():
    class_name = request.args.get('class_name')
    unit_name = request.args.get('unit_name')
    
    if not class_name or not unit_name:
        return jsonify([])
    
    # Get unique modules for the selected class and unit that have sentences
    modules = db.session.query(Sentence.module).filter(
        Sentence.classs == class_name,
        Sentence.unit == unit_name
    ).distinct().order_by(Sentence.module).all()
    
    return jsonify([module[0] for module in modules if module[0]])

# Words routes are now in blueprints.words
# @app.route('/words/json') ... (moved)
# @app.route("/get_units_for_class") ... (moved)
# @app.route("/get_modules_for_unit") ... (moved)
# @app.route('/words') ... (moved)
# @app.route("/add_words", methods=['POST', 'GET']) ... (moved)
# @app.route('/edit_word/<int:word_id>', methods=['GET', 'POST']) ... (moved)
# @app.route('/delete_word/<int:word_id>', methods=['POST']) ... (moved)
# @app.route('/class/<class_name>/<unit_name>/<module_name>') ... (moved)
# @app.route('/quizlet/<class_name>/<unit_name>/<module_name>') ... (moved)
# Note: Obsolete /edit_word and /update_word routes were already removed or not part of this list.
# Note: Granular add routes like /add_unit_to_class were already removed or not part of this list.


@app.route("/hello")
def hello():
    if 'user_id' not in session:
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user:
        session.pop('user_id', None) # Clean up invalid session
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))

    fio_parts = user.fio.split(' ')
    try:
        letters = fio_parts[0][:1] + fio_parts[1][:1]
    except:
        letters = user.fio[0] + user.fio[1]

    return render_template('hello.html', username=user.nick, letters=letters)

@app.route("/about")
def about():
    return render_template("about.html")

# Old delete_word route removed in favor of the new route with more precise word identification

# @app.route("/edit_word") # This route is now handled by words_bp.edit_word
# def edit_word_form():
#  ... (implementation removed) ...

# @app.route("/update_word", methods=["POST"]) # This functionality is now part of words_bp.edit_word (POST)
# def update_word():
#  ... (implementation removed) ...

@app.route("/add_unit_to_class")
def add_unit_to_class_form():
    class_name = request.args.get("class")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å —é–Ω–∏—Ç –≤ {class_name}</h2>
    <form action="/save_unit" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="text" name="unit" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ —é–Ω–∏—Ç–∞" required />
        <button type="submit">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
    </form>
    """
@app.route("/add_module_to_unit")
def add_module_to_unit_form():
    class_name = request.args.get("class")
    unit_name = request.args.get("unit")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å –º–æ–¥—É–ª—å –≤ {unit_name} ({class_name})</h2>
    <form action="/save_module" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="hidden" name="unit" value="{unit_name}" />
        <input type="text" name="module" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ –º–æ–¥—É–ª—è" required />
        <button type="submit">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
    </form>
    """

@app.route("/save_module", methods=["POST"])
def save_module():
    class_name = request.form.get("class")
    unit_name = request.form.get("unit")
    module_name = request.form.get("module")

    dummy_word = Word(word="dummy", perevod="–∑–∞–≥–ª—É—à–∫–∞", classs=class_name, unit=unit_name, module=module_name)
    db.session.add(dummy_word)
    db.session.commit()

    return redirect(url_for('words.words'))

@app.route("/add_word_to_module")
def add_word_to_module_form():
    class_name = request.args.get("class")
    unit_name = request.args.get("unit")
    module_name = request.args.get("module")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–æ –≤ –º–æ–¥—É–ª—å: {module_name} ({unit_name}, {class_name})</h2>
    <form action="/add_word" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="hidden" name="unit" value="{unit_name}" />
        <input type="hidden" name="module" value="{module_name}" />
        <label>–°–ª–æ–≤–æ:</label><br/>
        <input type="text" name="word" required /><br/>
        <label>–ü–µ—Ä–µ–≤–æ–¥:</label><br/>
        <input type="text" name="perevod" required /><br/>
        <button type="submit">–î–æ–±–∞–≤–∏—Ç—å</button>
    </form>
    """

@app.route("/save_unit", methods=["POST"])
def save_unit():
    class_name = request.form.get("class")
    unit_name = request.form.get("unit")

    # –ü—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º –ª—é–±–æ–µ —Å–ª–æ–≤–æ, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å —Å–≤—è–∑—å –∫–ª–∞—Å—Å–∞ –∏ –º–æ–¥—É–ª—è
    dummy_word = Word(word="dummy", perevod="–∑–∞–≥–ª—É—à–∫–∞", classs=class_name, unit=unit_name)
    db.session.add(dummy_word)
    db.session.commit()

    return redirect(url_for('words.words'))

@app.route("/add_word_to_unit")
def add_word_to_unit_form():
    class_name = request.args.get("class")
    unit_name = request.args.get("unit")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–æ –≤ {unit_name} ({class_name})</h2>
    <form action="/add_word" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="hidden" name="unit" value="{unit_name}" />
        <label>–°–ª–æ–≤–æ:</label><br/>
        <input type="text" name="word" required /><br/>
        <label>–ü–µ—Ä–µ–≤–æ–¥:</label><br/>
        <input type="text" name="perevod" required /><br/>
        <button type="submit">–î–æ–±–∞–≤–∏—Ç—å</button>
    </form>
    """

@app.route("/add_word", methods=["POST"])
def add_word():
    class_name = request.form.get("class")
    unit_name = request.form.get("unit")
    module_name = request.form.get("module")
    word = request.form.get("word")
    perevod = request.form.get("perevod")

    # Validate that all required fields are filled out
    if not class_name or not unit_name or not module_name:
        flash("–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–æ: –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–∞–ø–æ–ª–Ω–∏—Ç—å –∫–ª–∞—Å—Å, —é–Ω–∏—Ç –∏ –º–æ–¥—É–ª—å", "error")
        return redirect(url_for('words.words'))

    new_word = Word(word=word, perevod=perevod, classs=class_name, unit=unit_name, module=module_name)
    db.session.add(new_word)
    db.session.commit()

    return redirect(url_for('words.words'))



@app.route('/class/<class_name>/<unit_name>/<module_name>')
def module_words(class_name, unit_name, module_name):
    words = Word.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()
    return render_template('module_words.html', 
                         words=words,
                         class_name=class_name,
                         unit_name=unit_name,
                         module_name=module_name)

@app.route('/quizlet/<class_name>/<unit_name>/<module_name>')
def quizlet_cards(class_name, unit_name, module_name):
    word_objects = Word.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()
    # Convert Word objects to dictionaries for JSON serialization
    words = [{'id': word.id, 'word': word.word, 'perevod': word.perevod, 
              'classs': word.classs, 'unit': word.unit, 'module': word.module} 
             for word in word_objects]
    return render_template('quizlet_cards.html',
                         words=words,
                         class_name=class_name,
                         unit_name=unit_name,
                         module_name=module_name)

def generate_test_link():
    """Generate a random unique link for a test"""
    while True:
        link = ''.join(random.choices(string.ascii_letters + string.digits, k=10))
        if not Test.query.filter_by(link=link).first():
            return link

@app.route("/create_test", methods=['GET', 'POST'])
def create_test():
    if 'user_id' not in session:
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –∫–∞–∫ —É—á–∏—Ç–µ–ª—å.", "warning")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –¢–æ–ª—å–∫–æ —É—á–∏—Ç–µ–ª—è –º–æ–≥—É—Ç —Å–æ–∑–¥–∞–≤–∞—Ç—å —Ç–µ—Å—Ç—ã.", "warning")
        if not user: # If user is None (e.g. ID in session is invalid), pop session and redirect
            session.pop('user_id', None)
        return redirect(url_for('auth.login'))
    
    if request.method == 'POST':
        test_type = request.form.get('test_type')
        class_number = request.form.get('class_number')
        title = request.form.get('title')
        
        time_limit_str = request.form.get('time_limit')
        # Time limit: 0 or empty means None (unlimited)
        time_limit = int(time_limit_str) if time_limit_str and time_limit_str.isdigit() and int(time_limit_str) > 0 else None
        
        # General word order for the final list of test words
        word_order_form = request.form.get('word_order', 'sequential') 
        
        # General word count to limit the final number of words (can be None)
        word_count_form_str = request.form.get('word_count')
        word_count_form = int(word_count_form_str) if word_count_form_str and word_count_form_str.isdigit() and int(word_count_form_str) > 0 else None

        test_mode = request.form.get('test_mode', 'random_letters') if test_type == 'add_letter' else None
        
        new_test_params = {
            'title': title,
            'classs': class_number,
            'type': test_type,
            'link': generate_test_link(),
            'created_by': user.id,
            'time_limit': time_limit,
            'word_order': word_order_form, # This is the overall order
            'test_mode': test_mode,
            # unit and module will default to "N/A" if not provided by selected modules
        }

        words_data_source = [] # Holds {'word': ..., 'perevod': ..., 'source': ...}

        if test_type == 'dictation':
            dictation_word_source = request.form.get('dictation_word_source')
            new_test_params['dictation_word_source'] = dictation_word_source

            selected_modules = request.form.getlist('modules[]')
            module_words_list = []
            if selected_modules: # Fetch module words if any modules are selected
                for module_identifier in selected_modules:
                    class_num, unit, module_name = module_identifier.split('|')
                    module_words_db = Word.query.filter_by(
                        classs=class_num,
                        unit=unit,
                        module=module_name
                    ).all()
                    for mw in module_words_db:
                        module_words_list.append({'word': mw.word, 'perevod': mw.perevod, 'source': 'module'})
            
            if dictation_word_source == 'all_module':
                words_data_source.extend(module_words_list)
                # General word_count_form applies as a limiter
                new_test_params['word_count'] = word_count_form 

            elif dictation_word_source == 'random_from_module':
                dictation_num_random_words_str = request.form.get('dictation_random_word_count')
                dictation_num_random_words = int(dictation_num_random_words_str) if dictation_num_random_words_str and dictation_num_random_words_str.isdigit() else 0
                
                new_test_params['word_count'] = dictation_num_random_words if dictation_num_random_words > 0 else None # Store the count of random words
                
                if module_words_list and dictation_num_random_words > 0:
                    random.shuffle(module_words_list)
                    words_data_source.extend(module_words_list[:dictation_num_random_words])

            elif dictation_word_source == 'selected_specific':
                specific_word_ids_str = request.form.getlist('dictation_specific_word_ids[]')
                specific_word_ids = [int(id_str) for id_str in specific_word_ids_str if id_str.isdigit()]
                new_test_params['dictation_selected_words'] = json.dumps(specific_word_ids)
                
                if specific_word_ids:
                    selected_db_words = Word.query.filter(Word.id.in_(specific_word_ids)).all()
                    for sw in selected_db_words:
                        words_data_source.append({'word': sw.word, 'perevod': sw.perevod, 'source': 'module_specific'})
                # General word_count_form can optionally limit these selected words
                new_test_params['word_count'] = word_count_form

            # Add custom words for dictation - these are always included
            custom_words_text = request.form.getlist('custom_words[]')
            custom_translations_text = request.form.getlist('custom_translations[]')
            for cw_text, ct_text in zip(custom_words_text, custom_translations_text):
                if cw_text and ct_text:
                    words_data_source.append({'word': cw_text, 'perevod': ct_text, 'source': 'custom'})
        
        else: # For other test types (non-dictation)
            new_test_params['word_count'] = word_count_form # General word count applies

            selected_modules = request.form.getlist('modules[]')
            if selected_modules:
                for module_identifier in selected_modules:
                    class_num, unit, module_name = module_identifier.split('|')
                    module_words_db = Word.query.filter_by(
                        classs=class_num,
                        unit=unit,
                        module=module_name
                    ).all()
                    for mw in module_words_db:
                        words_data_source.append({'word': mw.word, 'perevod': mw.perevod, 'source': 'module'})

            custom_words_text = request.form.getlist('custom_words[]')
            custom_translations_text = request.form.getlist('custom_translations[]')
            for cw_text, ct_text in zip(custom_words_text, custom_translations_text):
                if cw_text and ct_text:
                    words_data_source.append({'word': cw_text, 'perevod': ct_text, 'source': 'custom'})
        
        # Create Test object
        new_test = Test(**new_test_params)
        db.session.add(new_test)
        db.session.commit() # Commit to get new_test.id so TestWord entries can be linked
        
        # –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–ê–Ø –û–ß–ò–°–¢–ö–ê –†–ï–ó–£–õ–¨–¢–ê–¢–û–í –ü–†–ï–î–´–î–£–©–ò–• –¢–ï–°–¢–û–í
        try:
            results_cleared_count, tests_affected = auto_clear_previous_test_results(
                teacher_user=user,
                class_number=class_number,
                new_test_id=new_test.id
            )
            
            if results_cleared_count > 0:
                affected_tests_str = ", ".join(tests_affected[:3])  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 3 —Ç–µ—Å—Ç–∞
                if len(tests_affected) > 3:
                    affected_tests_str += f" –∏ –µ—â–µ {len(tests_affected) - 3}"
                
                test_type_str = "–∞–∫—Ç–∏–≤–Ω—ã—Ö —Ç–µ—Å—Ç–æ–≤" if CLEAR_ONLY_ACTIVE_TESTS else "—Ç–µ—Å—Ç–æ–≤"
                flash(f"–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ—á–∏—â–µ–Ω–æ {results_cleared_count} —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –∏–∑ {test_type_str} –¥–ª—è –∫–ª–∞—Å—Å–∞ {class_number} ({affected_tests_str}).", "info")
            
        except Exception as e:
            # –ï—Å–ª–∏ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ—á–∏—Å—Ç–∫–µ, –Ω–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–∞
            # –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –Ω–æ–≤–æ–≥–æ —Ç–µ—Å—Ç–∞
            try:
                db.session.rollback()
                db.session.add(new_test)
                db.session.commit()
            except:
                pass  # –ï—Å–ª–∏ –∏ —ç—Ç–æ –Ω–µ —É–¥–∞–ª–æ—Å—å, –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º
            
            print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—á–∏—Å—Ç–∫–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤: {e}")
            flash("–¢–µ—Å—Ç —Å–æ–∑–¥–∞–Ω, –Ω–æ –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—á–∏—Å—Ç–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Ç–µ—Å—Ç–æ–≤.", "warning")

        # Final processing of words_data_source based on general word_order and word_count
        # (This was previously somewhat mixed with initial fetching)

        # 1. Shuffle if overall word_order is 'random'
        if new_test.word_order == 'random':
            random.shuffle(words_data_source)
        
        # 2. Apply general word_count as a final limiter, 
        #    but only if it hasn't been specifically set by 'random_from_module' dictation.
        #    For 'all_module' and 'selected_specific' dictation, word_count_form acts as the limiter.
        #    For non-dictation tests, word_count_form acts as the limiter.
        
        final_word_count_to_use = new_test.word_count # This comes from new_test_params

        if final_word_count_to_use is not None and final_word_count_to_use > 0:
            if len(words_data_source) > final_word_count_to_use:
                words_data_source = words_data_source[:final_word_count_to_use]
        elif final_word_count_to_use == 0: # Explicitly 0 means no words (edge case, but good to define)
             words_data_source = []


        # Create test words (The rest of the logic for populating TestWord based on test_type)
        for idx, word_entry in enumerate(words_data_source):
            original_word_text = word_entry['word']
            original_translation = word_entry['perevod']
            
            current_word_for_test_word_model = original_word_text 
            prompt_for_test_word_model = original_translation   
            options_db = None
            missing_letters_positions_db = None
            correct_answer_for_db = original_word_text 

            if test_type == 'add_letter':
                prompt_for_test_word_model = original_translation
                if test_mode == 'random_letters':
                    letter_indices = [i for i, char in enumerate(original_word_text) if char != ' ']
                    num_actual_letters = len(letter_indices)

                    if num_actual_letters > 0:
                        # Determine base number of letters to remove based on actual letter count
                        if num_actual_letters <= 3:
                            val = 1
                        elif num_actual_letters <= 6:
                            val = random.randint(1, 2)
                        elif num_actual_letters <= 9:
                            val = random.randint(2, 3)
                        else: # 10+ actual letters
                            val = random.randint(3, 4)

                        # Adjust num_letters_to_remove
                        if num_actual_letters == 1: # For a single letter word, always remove that one letter
                            num_letters_to_remove = 1
                        else:
                            # For words with more than one letter, remove at most half, but at least 1
                            num_letters_to_remove = min(val, num_actual_letters // 2)
                            num_letters_to_remove = max(1, num_letters_to_remove)

                        positions_zero_indexed = sorted(random.sample(letter_indices, num_letters_to_remove))
                        
                        actual_missing_letters_list = [original_word_text[pos] for pos in positions_zero_indexed]
                        correct_answer_for_db = "".join(actual_missing_letters_list)
                        
                        word_with_gaps_list = list(original_word_text)
                        for pos in positions_zero_indexed:
                            word_with_gaps_list[pos] = '_'
                        current_word_for_test_word_model = "".join(word_with_gaps_list)
                        missing_letters_positions_db = ','.join(str(pos + 1) for pos in positions_zero_indexed) # Store 1-indexed

                    else: # No actual letters in original_word_text (it's empty or all spaces)
                        current_word_for_test_word_model = original_word_text
                        correct_answer_for_db = ""
                        missing_letters_positions_db = ""
                elif test_mode == 'manual_letters':
                    # For manual mode, initially save the original word.
                    # Configuration will happen in a separate step via configure_test_words.
                    current_word_for_test_word_model = original_word_text
                    # prompt_for_test_word_model is already set
                    correct_answer_for_db = ""  # Intentionally blank, to be filled in config step
                    missing_letters_positions_db = None  # To be filled in config step
                    # Removed logic that tried to get 'manual_missing_indices_for_words' here.
                    # Removed flash messages regarding missing manual indices here.
                        
            elif test_type == 'multiple_choice_single':
                current_word_for_test_word_model = original_translation # This is the question: "What is the word for X?"
                prompt_for_test_word_model = "–í—ã–±–µ—Ä–∏—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥:" 
                correct_answer_for_db = original_word_text
                
                all_other_words_in_class = [w.word for w in Word.query.filter(Word.classs == class_number, Word.word != original_word_text).all()]
                num_wrong_options = 3
                
                wrong_options_list = []
                if len(all_other_words_in_class) >= num_wrong_options:
                    wrong_options_list = random.sample(all_other_words_in_class, num_wrong_options)
                else: 
                    wrong_options_list = all_other_words_in_class
                
                current_options_list_for_db = wrong_options_list + [original_word_text]
                random.shuffle(current_options_list_for_db)
                options_db = '|'.join(current_options_list_for_db)

            elif test_type == 'dictation':
                # Student hears/sees translation (prompt) and types the word (correct_answer).
                # `word` field can be empty or show underscores matching word length as a visual cue.
                current_word_for_test_word_model = ''.join(['_'] * len(original_word_text)) # Visual cue for length
                prompt_for_test_word_model = original_translation 
                correct_answer_for_db = original_word_text

            elif test_type == 'true_false':
                # The 'word' field will store the statement. Teacher needs UI to define statement & if T/F.
                # Placeholder: Assume statement is "Word - Translation" and it's True.
                # For custom words, teacher would input the statement and T/F.
                # This part requires significant teacher input for meaningful questions.
                if word_entry['source'] == 'custom': # Assume custom word text *is* the statement
                    current_word_for_test_word_model = original_word_text
                    # And custom translation *is* the True/False value
                    correct_answer_for_db = original_translation if original_translation.lower() in ['true', 'false'] else "True"
                else: # From module
                    # Determine if the statement should be true or false
                    if random.choice([True, False]):
                        # Make a true statement
                        current_word_for_test_word_model = f"{original_word_text} - {original_translation}"
                        correct_answer_for_db = "True"
                    else:
                        # Try to make a false statement
                        # Need to get current class and unit for the original_word_text to find distractors
                        # This assumes word_entry might have class/unit/module if it's from a module.
                        # If not, this part needs refinement on how to get context for distractors.
                        # For now, using the overall test's class_number.
                        # And assuming unit/module context might be in new_test_params if available,
                        # otherwise, this might be too broad or too narrow.

                        # Attempt to find a distractor translation from the same class.
                        # More specific (unit/module) would be better if that context is reliably available here.
                        distractor_words = Word.query.filter(
                            Word.classs == new_test_params.get('classs'),
                            Word.word != original_word_text # Exclude the original word itself
                        ).all()

                        if distractor_words:
                            distractor_word_obj = random.choice(distractor_words)
                            distractor_translation = distractor_word_obj.perevod

                            # Ensure the distractor translation isn't the same as the original,
                            # which could happen if different words have the same translation.
                            if distractor_translation != original_translation:
                                current_word_for_test_word_model = f"{original_word_text} - {distractor_translation}"
                                correct_answer_for_db = "False"
                            else:
                                # Fallback: if distractor is same as original, make it a true statement
                                current_word_for_test_word_model = f"{original_word_text} - {original_translation}"
                                correct_answer_for_db = "True"
                        else:
                            # Fallback: if no distractors found, make it a true statement
                            current_word_for_test_word_model = f"{original_word_text} - {original_translation}"
                            correct_answer_for_db = "True"
                
                prompt_for_test_word_model = "–í–µ—Ä–Ω–æ –∏–ª–∏ –Ω–µ–≤–µ—Ä–Ω–æ?" 
                options_db = "True|False"
                
            elif test_type == 'fill_word':
                # Student sees translation (word field) and needs to write the original word (correct_answer).
                current_word_for_test_word_model = original_translation # This is shown to the student as the question/prompt
                prompt_for_test_word_model = "–í–ø–∏—à–∏—Ç–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–µ–µ —Å–ª–æ–≤–æ (–æ—Ä–∏–≥–∏–Ω–∞–ª):"
                correct_answer_for_db = original_word_text

            elif test_type == 'multiple_choice_multiple':
                # Question is the translation/prompt. Options are words. Multiple can be correct.
                # Teacher needs UI to select multiple correct answers. This is a complex setup.
                # Placeholder: Treat like single choice for now, teacher defines one correct answer.
                current_word_for_test_word_model = original_translation # Question: "Select all words that mean X"
                prompt_for_test_word_model = "–í—ã–±–µ—Ä–∏—Ç–µ –≤—Å–µ –ø–æ–¥—Ö–æ–¥—è—â–∏–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã:"
                correct_answer_for_db = original_word_text # Placeholder: single correct answer.
                                                    # Real implementation: "ans1|ans2"
                
                all_other_words_in_class = [w.word for w in Word.query.filter(Word.classs == class_number, Word.word != original_word_text).all()]
                num_options_total = 4 
                
                # This logic is simplified; creating diverse and multiple correct options needs more.
                # For now, generate options similar to single choice.
                num_wrong_options_needed = num_options_total - 1 # Assuming 1 correct for now
                
                wrong_options_list = []
                if len(all_other_words_in_class) >= num_wrong_options_needed:
                    wrong_options_list = random.sample(all_other_words_in_class, num_wrong_options_needed)
                else:
                    wrong_options_list = all_other_words_in_class
                
                current_options_list_for_db = wrong_options_list + [original_word_text]
                # Fill with placeholders if not enough unique words
                while len(current_options_list_for_db) < num_options_total:
                    current_options_list_for_db.append(f"–í–∞—Ä–∏–∞–Ω—Ç {len(current_options_list_for_db)+1}")

                random.shuffle(current_options_list_for_db)
                options_db = '|'.join(current_options_list_for_db[:num_options_total])


            test_word_entry = TestWord(
                test_id=new_test.id,
                word=current_word_for_test_word_model,    # What the student sees as the question/task item
                perevod=prompt_for_test_word_model,       # Supporting info, like translation or detailed prompt
                correct_answer=correct_answer_for_db,
                options=options_db,
                missing_letters=missing_letters_positions_db,
                word_order=idx
            )
            db.session.add(test_word_entry)

        db.session.commit() # Commit TestWord entries. Test object (new_test) was committed earlier.

        # Use new_test.type and new_test.test_mode for the redirect condition
        if new_test.type == 'add_letter' and new_test.test_mode == 'manual_letters':
            flash("–¢–µ—Å—Ç —Å–æ–∑–¥–∞–Ω. –¢–µ–ø–µ—Ä—å —É–∫–∞–∂–∏—Ç–µ, –∫–∞–∫–∏–µ –±—É–∫–≤—ã –ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å –≤ —Å–ª–æ–≤–∞—Ö.", "info")
            return redirect(url_for('configure_test_words', test_id=new_test.id))
        else:
            flash("–¢–µ—Å—Ç —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω!", "success")
            return redirect(url_for('test_details', test_id=new_test.id))

    # GET request:
    user = User.query.get(session['user_id']) # Ensure user is fetched for GET request as well
    # Fetch available modules to populate the form (example, adjust as per actual logic)
    available_modules = {} # Replace with actual module fetching logic if needed for the GET request
    classes_get = [str(i) for i in range(1, 12)]
    
    # Pass any other necessary context for the template
    return render_template("create_test.html", user=user, classes=classes_get, available_modules=available_modules)

@app.route('/configure_test_words/<int:test_id>', methods=['GET', 'POST'])
def configure_test_words(test_id):
    if 'user_id' not in session:
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ.", "warning")
        return redirect(url_for('auth.login'))
    
    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –¢–æ–ª—å–∫–æ —É—á–∏—Ç–µ–ª—è –º–æ–≥—É—Ç –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞—Ç—å —Ç–µ—Å—Ç—ã.", "warning")
        return redirect(url_for('tests'))

    test = Test.query.get_or_404(test_id)
    
    if test.created_by != user.id:
        flash("–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —ç—Ç–æ—Ç —Ç–µ—Å—Ç, —Ç–∞–∫ –∫–∞–∫ –Ω–µ —è–≤–ª—è–µ—Ç–µ—Å—å –µ–≥–æ —Å–æ–∑–¥–∞—Ç–µ–ª–µ–º.", "danger")
        return redirect(url_for('tests'))

    if not (test.type == 'add_letter' and test.test_mode == 'manual_letters'):
        flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç –Ω–µ —Ç—Ä–µ–±—É–µ—Ç —Ä—É—á–Ω–æ–π –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –±—É–∫–≤.", "info")
        return redirect(url_for('test_details', test_id=test.id))

    test_words_for_config = TestWord.query.filter_by(test_id=test.id).order_by(TestWord.word_order).all()

    if request.method == 'POST':
        try:
            for word_obj in test_words_for_config:
                # In the create_test step, word_obj.word stored the original_word_text
                original_word_text = word_obj.word 
                submitted_indices_str = request.form.get(f'word_{word_obj.id}_indices')

                if submitted_indices_str:
                    positions_zero_indexed = sorted(list(set(
                        [int(p.strip()) for p in submitted_indices_str.split(',') if p.strip().isdigit()]
                    )))
                    
                    valid_positions = [p for p in positions_zero_indexed if 0 <= p < len(original_word_text)]

                    if valid_positions:
                        actual_missing_letters_list = [original_word_text[pos] for pos in valid_positions]
                        word_obj.correct_answer = "".join(actual_missing_letters_list)
                        
                        word_with_gaps_list = list(original_word_text)
                        for pos in valid_positions:
                            word_with_gaps_list[pos] = '_'
                        # Update word_obj.word to store the word with gaps for student view
                        word_obj.word = "".join(word_with_gaps_list) 
                        word_obj.missing_letters = ','.join(str(pos + 1) for pos in valid_positions) # Store 1-indexed
                    else:
                        # No valid indices submitted (e.g., empty string or out-of-bound numbers)
                        word_obj.word = original_word_text # Keep original word (no gaps)
                        word_obj.correct_answer = ""       # No letters are missing
                        word_obj.missing_letters = None
                        if submitted_indices_str: # If teacher submitted something but it was invalid/empty after parsing
                             flash(f"–î–ª—è —Å–ª–æ–≤–∞ '{original_word_text}' –Ω–µ –±—ã–ª–∏ —É–∫–∞–∑–∞–Ω—ã –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –±—É–∫–≤ –∏–ª–∏ –æ–Ω–∏ –±—ã–ª–∏ –≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞. –ü—Ä–æ–ø—É—Å–∫–∏ –Ω–µ —Å–æ–∑–¥–∞–Ω—ã.", "warning")
                else:
                    # No indices submitted for this word at all, treat as "no letters hidden"
                    word_obj.word = original_word_text
                    word_obj.correct_answer = ""
                    word_obj.missing_letters = None
                    # Optional: flash message if you want to inform that a word was skipped
                    # flash(f"–î–ª—è —Å–ª–æ–≤–∞ '{original_word_text}' –Ω–µ —É–∫–∞–∑–∞–Ω—ã –±—É–∫–≤—ã –¥–ª—è –ø—Ä–æ–ø—É—Å–∫–∞. –°–ª–æ–≤–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π.", "info")
            
            db.session.commit()
            flash("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã—Ö –±—É–∫–≤ —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!", "success")
            return redirect(url_for('test_details', test_id=test.id))
        
        except ValueError as ve:
            db.session.rollback()
            flash(f"–û—à–∏–±–∫–∞ –≤ —Ñ–æ—Ä–º–∞—Ç–µ —É–∫–∞–∑–∞–Ω–Ω—ã—Ö –ø–æ–∑–∏—Ü–∏–π. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–æ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä–∞ –±—É–∫–≤ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é (–Ω–∞–ø—Ä–∏–º–µ—Ä, 0,2). {str(ve)}", "danger")
        except Exception as e:
            db.session.rollback()
            flash(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –Ω–∞—Å—Ç—Ä–æ–µ–∫: {str(e)}", "error")
            
    # GET request: fetch words and render the configuration template
    # Pre-calculate 0-indexed display strings for missing letter indices.
    for word_obj_from_db in test_words_for_config:
        display_indices_value = ""
        if word_obj_from_db.missing_letters:
            try:
                # missing_letters is 1-indexed from DB, e.g., "1,3,5"
                one_indexed_indices = [int(x.strip()) for x in word_obj_from_db.missing_letters.split(',') if x.strip().isdigit()]
                # Convert to 0-indexed for form display, e.g., "0,2,4"
                zero_indexed_indices = [str(idx - 1) for idx in one_indexed_indices if idx > 0] # ensure idx-1 is non-negative
                display_indices_value = ','.join(zero_indexed_indices)
            except ValueError:
                # If parsing fails (e.g., non-integer data), pass empty string.
                # Consider logging this case.
                display_indices_value = "" 
        
        # Dynamically add the pre-calculated string as an attribute to the object for easy template access
        setattr(word_obj_from_db, 'display_indices_for_form', display_indices_value)

    # Pass the (now modified with .display_indices_for_form) test_words_for_config to the template.
    return render_template('configure_test_words.html', test=test, test_words=test_words_for_config, user=user)

@app.route("/test/<int:test_id>")
def test_details(test_id):
    if 'user_id' not in session:
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user:
        session.pop('user_id', None)
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))

    test = Test.query.get_or_404(test_id)
    
    if user.teacher == 'yes':
        # Teacher's view: Gather student progress and render details page
        students_in_class = User.query.filter_by(class_number=test.classs, teacher='no').all()
        total_students_in_class = len(students_in_class)
        all_results_for_test = TestResult.query.filter(
            TestResult.test_id == test.id,
            TestResult.started_at >= test.created_at
        ).all()

        completed_students_details = []
        in_progress_students_details = []
        not_started_student_ids = {s.id for s in students_in_class}

        for result in all_results_for_test:
            student_user = User.query.get(result.user_id)
            if not student_user or student_user.teacher == 'yes': # Skip non-students or if user somehow deleted
                if student_user and result.user_id in not_started_student_ids:
                    not_started_student_ids.remove(result.user_id)
                continue

            if result.user_id in not_started_student_ids:
                not_started_student_ids.remove(result.user_id)
            
            if result.completed_at:
                completed_students_details.append({'user': student_user, 'result': result})
            else:
                item_data_for_template = {
                    'user': student_user,
                    'result': result,
                    'remaining_time_display': "–ë–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π",
                    'has_time_limit': False,
                    'end_time_utc_iso': None
                }
                if test.time_limit and test.time_limit > 0:
                    end_time_utc = result.started_at + timedelta(minutes=test.time_limit)
                    now_utc = datetime.utcnow()
                    item_data_for_template['has_time_limit'] = True
                    item_data_for_template['end_time_utc_iso'] = end_time_utc.isoformat() + "Z"
                    if now_utc < end_time_utc:
                        remaining_delta = end_time_utc - now_utc
                        hours, remainder = divmod(remaining_delta.total_seconds(), 3600)
                        minutes, seconds_float = divmod(remainder, 60)
                        seconds = int(seconds_float)
                        if hours > 0:
                            item_data_for_template['remaining_time_display'] = f"{int(hours)}h {int(minutes)}m {seconds}s left"
                        else:
                            item_data_for_template['remaining_time_display'] = f"{int(minutes)}m {seconds}s left"
                    else:
                        item_data_for_template['remaining_time_display'] = "–í—Ä–µ–º—è –≤—ã—à–ª–æ"
                in_progress_students_details.append(item_data_for_template)

        not_started_students = [User.query.get(uid) for uid in not_started_student_ids]
        not_started_students = [s for s in not_started_students if s] 
        
        completed_count = len(completed_students_details)
        progress_percentage = (completed_count / total_students_in_class * 100) if total_students_in_class > 0 else 0

        return render_template('test_details.html',
                             test=test,
                             total_students_in_class=total_students_in_class,
                             completed_students_details=completed_students_details,
                             in_progress_students_details=in_progress_students_details,
                             not_started_students=not_started_students,
                             progress_percentage=progress_percentage,
                             is_teacher=True) # Ensure is_teacher is passed
    
    # --- STUDENT PATH --- (if user.teacher == 'no')
    else:
        student_completed_result = TestResult.query.filter_by(
            test_id=test.id,
            user_id=user.id
        ).filter(TestResult.completed_at.isnot(None)).order_by(TestResult.completed_at.desc()).first()

        if not test.is_active: # Test is ARCHIVED
            if student_completed_result:
                flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –∞—Ä—Ö–∏–≤–µ. –ü—Ä–æ—Å–º–æ—Ç—Ä –≤–∞—à–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.", "info")
                return redirect(url_for('test_results', test_id=test.id, result_id=student_completed_result.id))
            else:
                flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ –∞—Ä—Ö–∏–≤–µ, –∏ –≤—ã –µ–≥–æ –Ω–µ –ø—Ä–æ—Ö–æ–¥–∏–ª–∏.", "warning")
                return redirect(url_for('tests'))
        else: # Test is ACTIVE
            if student_completed_result:
                flash("–í—ã —É–∂–µ –∑–∞–≤–µ—Ä—à–∏–ª–∏ —ç—Ç–æ—Ç —Ç–µ—Å—Ç. –ü—Ä–æ—Å–º–æ—Ç—Ä –≤–∞—à–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.", "info")
                return redirect(url_for('test_results', test_id=test.id, result_id=student_completed_result.id))
            else:
                # If active and not completed (or no result at all), student should be able to take it.
                return redirect(url_for('take_test', test_link=test.link))
    
    # Fallback for any unhandled student cases, though the logic above should cover students.
    # This line should ideally not be reached if student logic is complete.
    flash("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–æ–±—Ä–∞–∑–∏—Ç—å –¥–µ—Ç–∞–ª–∏ —Ç–µ—Å—Ç–∞ –¥–ª—è –≤–∞—à–µ–≥–æ —Å—Ç–∞—Ç—É—Å–∞.", "warning")
    return redirect(url_for('tests'))

@app.route("/test/<int:test_id>/archive", methods=['POST'])
def archive_test(test_id):
    if 'user_id' not in session:
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –∫–∞–∫ —É—á–∏—Ç–µ–ª—å.", "warning")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        flash("–¢–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–µ—Å—Ç–∞ –º–æ–∂–µ—Ç –µ–≥–æ –∞—Ä—Ö–∏–≤–∏—Ä–æ–≤–∞—Ç—å.", "warning")
        if not user: session.pop('user_id', None)
        return redirect(url_for('tests')) # Or back to test_details

    test = Test.query.get_or_404(test_id)
    if test.created_by != user.id:
        return redirect('/tests', 302)

    test.is_active = False
    db.session.commit()
    return redirect(url_for('test_details', test_id=test_id))

@app.route("/test/<int:test_id>/unarchive", methods=['POST'])
def unarchive_test(test_id):
    if 'user_id' not in session:
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –∫–∞–∫ —É—á–∏—Ç–µ–ª—å.", "warning")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        flash("–¢–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–µ—Å—Ç–∞ –º–æ–∂–µ—Ç –µ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∏–∑ –∞—Ä—Ö–∏–≤–∞.", "warning")
        if not user: session.pop('user_id', None)
        return redirect(url_for('tests'))

    test = Test.query.get_or_404(test_id)
    if test.created_by != user.id:
        flash("–¢–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–µ—Å—Ç–∞ –º–æ–∂–µ—Ç –µ–≥–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å.", "warning")
        return redirect(url_for('test_details', test_id=test_id))

    test.is_active = True
    db.session.commit()
    flash(f"–¢–µ—Å—Ç '{test.title}' —É—Å–ø–µ—à–Ω–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–∑ –∞—Ä—Ö–∏–≤–∞.", "success")
    return redirect(url_for('test_details', test_id=test_id))

@app.route("/test/<int:test_id>/clear_results", methods=['POST'])
def clear_test_results(test_id):
    if 'user_id' not in session:
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –∫–∞–∫ —É—á–∏—Ç–µ–ª—å.", "warning")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        flash("–¢–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–µ—Å—Ç–∞ –º–æ–∂–µ—Ç –æ—á–∏—Å—Ç–∏—Ç—å –µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã.", "warning")
        if not user: session.pop('user_id', None)
        return redirect(url_for('tests')) # Or back to test_details

    test = Test.query.get_or_404(test_id)
    if test.created_by != user.id:
        flash("–¢–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–µ—Å—Ç–∞ –º–æ–∂–µ—Ç –æ—á–∏—Å—Ç–∏—Ç—å –µ–≥–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã.", "warning")
        return redirect(url_for('test_details', test_id=test_id))

    results_to_delete = TestResult.query.filter_by(test_id=test.id).all()
    
    if not results_to_delete:
        flash(f"–ù–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ –¥–ª—è —Ç–µ—Å—Ç–∞ '{test.title}'.", "info")
        return redirect(url_for('test_details', test_id=test_id))

    try:
        for result in results_to_delete:
            # Explicitly delete TestAnswer objects associated with this result
            TestAnswer.query.filter_by(test_result_id=result.id).delete(synchronize_session=False)
            # Now delete the TestResult object
            db.session.delete(result)
        
        db.session.commit()
        flash(f"–í—Å–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è —Ç–µ—Å—Ç–∞ '{test.title}' –±—ã–ª–∏ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω—ã.", "success")
    except Exception as e:
        db.session.rollback()
        flash(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ç–µ—Å—Ç–∞: {str(e)}", "error")
        # app.logger.error(f"Error clearing test results for test_id {test_id}: {e}") # Requires app.logger to be configured
        print(f"Error clearing test results for test_id {test_id}: {e}") # simple print for now

    return redirect(url_for('test_details', test_id=test_id))

@app.route("/test/<int:test_id>/delete", methods=['POST'])
def delete_test_completely(test_id):
    if 'user_id' not in session:
        flash("–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –∫–∞–∫ —É—á–∏—Ç–µ–ª—å.", "warning")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes':
        flash("–¢–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–µ—Å—Ç–∞ –º–æ–∂–µ—Ç –µ–≥–æ —É–¥–∞–ª–∏—Ç—å.", "warning")
        if not user: session.pop('user_id', None)
        return redirect(url_for('tests'))

    test_to_delete = Test.query.get_or_404(test_id)
    if test_to_delete.created_by != user.id:
        flash("–¢–æ–ª—å–∫–æ —Å–æ–∑–¥–∞—Ç–µ–ª—å —Ç–µ—Å—Ç–∞ –º–æ–∂–µ—Ç –µ–≥–æ —É–¥–∞–ª–∏—Ç—å.", "warning")
        return redirect(url_for('test_details', test_id=test_id))

    try:
        # Delete associated TestAnswer entries
        TestAnswer.query.filter(TestAnswer.test_result_id.in_(db.session.query(TestResult.id).filter_by(test_id=test_id))).delete(synchronize_session=False)
        # Delete associated TestResult entries
        TestResult.query.filter_by(test_id=test_id).delete(synchronize_session=False)
        # Delete associated TestWord entries
        TestWord.query.filter_by(test_id=test_id).delete(synchronize_session=False)
        
        db.session.delete(test_to_delete)
        db.session.commit()
        flash(f"–¢–µ—Å—Ç '{test_to_delete.title}' –∏ –≤—Å–µ —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å –Ω–∏–º –¥–∞–Ω–Ω—ã–µ –±—ã–ª–∏ —É—Å–ø–µ—à–Ω–æ —É–¥–∞–ª–µ–Ω—ã.", "success")
        return redirect(url_for('tests'))
    except Exception as e:
        db.session.rollback()
        flash(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ç–µ—Å—Ç–∞: {str(e)}", "error")
        return redirect(url_for('test_details', test_id=test_id))

@app.route('/take_test/<test_link>', methods=['GET', 'POST'])
def take_test(test_link):
    if 'user_id' not in session:
        flash("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –≤ —Å–∏—Å—Ç–µ–º—É, —á—Ç–æ–±—ã –ø—Ä–æ–π—Ç–∏ —Ç–µ—Å—Ç.", "error")
        return redirect(url_for('auth.login'))

    current_user = User.query.get(session['user_id'])
    if not current_user:
        session.pop('user_id', None)
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))
    
    test = Test.query.filter_by(link=test_link).first_or_404()

    # –û—Ç–ª–∞–¥–æ—á–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ —Å–µ—Å—Å–∏–∏
    print(f"DEBUG: Session data at take_test start: {dict(session)}")
    print(f"DEBUG: Current user: {current_user.nick}, ID: {current_user.id}")
    print(f"DEBUG: Test ID: {test.id}, Test Link: {test.link}")

    # Check if student belongs to the correct class for the test
    if current_user.teacher == 'no' and test.classs != current_user.class_number:
        flash("–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –ø—Ä–æ–π—Ç–∏ —ç—Ç–æ—Ç —Ç–µ—Å—Ç, —Ç–∞–∫ –∫–∞–∫ –æ–Ω –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –¥—Ä—É–≥–æ–≥–æ –∫–ª–∞—Å—Å–∞.", "error")
        return redirect(url_for('tests'))

    # Check if the test is active (students cannot take archived tests)
    # Teachers can preview archived tests they created (handled in test_id route)
    if current_user.teacher == 'no' and not test.is_active:
        flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç –±–æ–ª—å—à–µ –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω –∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—Ä–æ–π–¥–µ–Ω.", "error")
        return redirect(url_for('tests'))

    # POST request: Starting the test
    if request.method == 'POST':
        if current_user.teacher == 'yes':
            # Teachers starting a test go directly to preview mode via test_id route
            # No TestResult is created for them.
            flash("–ù–∞—á–∞—Ç –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —Ç–µ—Å—Ç–∞.", "info")
            # –Ø–≤–Ω–æ —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–µ—Å—Å–∏—é –¥–ª—è —É—á–∏—Ç–µ–ª—è
            session['is_teacher_preview'] = True
            session['test_link'] = test.link
            session.modified = True
            print(f"DEBUG: Teacher preview mode activated, session: {dict(session)}")
            return jsonify({'success': True, 'redirect_url': '/test/' + test.link})

        # --- STUDENT LOGIC FOR POST (starting a test) ---
        if test.classs != current_user.class_number:
            flash("–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ –Ω–∞—á–∞—Ç—å —ç—Ç–æ—Ç —Ç–µ—Å—Ç, —Ç–∞–∫ –∫–∞–∫ –æ–Ω –ø—Ä–µ–¥–Ω–∞–∑–Ω–∞—á–µ–Ω –¥–ª—è –¥—Ä—É–≥–æ–≥–æ –∫–ª–∞—Å—Å–∞.", "error")
            return jsonify({'success': False, 'error': '–ö–ª–∞—Å—Å –Ω–µ —Å–æ–≤–ø–∞–¥–∞–µ—Ç', 'redirect_url': url_for('tests')}), 403
        if not test.is_active:
            flash("–≠—Ç–æ—Ç —Ç–µ—Å—Ç –±–æ–ª—å—à–µ –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω –∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–∞—á–∞—Ç.", "error")
            return jsonify({'success': False, 'error': '–¢–µ—Å—Ç –Ω–µ –∞–∫—Ç–∏–≤–µ–Ω', 'redirect_url': url_for('tests')}), 403

        # Check for existing incomplete result for student
        existing_incomplete_result = TestResult.query.filter_by(
            test_id=test.id,
            user_id=current_user.id,
            completed_at=None
        ).first()

        if existing_incomplete_result:
            # If student already has an incomplete test, use that one
            session['active_test_result_id'] = existing_incomplete_result.id
            session['test_link'] = test.link
            # –Ø–≤–Ω–æ –ø–æ–º–µ—á–∞–µ–º —Å–µ—Å—Å–∏—é –∫–∞–∫ –∏–∑–º–µ–Ω–µ–Ω–Ω—É—é
            session.modified = True
            print(f"DEBUG: Using existing test result, ID: {existing_incomplete_result.id}, session: {dict(session)}")
            
            # –í–º–µ—Å—Ç–æ JSON-–æ—Ç–≤–µ—Ç–∞ –¥–µ–ª–∞–µ–º –ø—Ä—è–º–æ–π —Ä–µ–¥–∏—Ä–µ–∫—Ç
            resp = make_response(redirect('/test/' + test.link))
            resp.set_cookie('active_test_result_id', str(existing_incomplete_result.id))
            resp.set_cookie('test_link', test.link)
            return resp
        else:
            # If no incomplete test, check if they completed it before.
            # Depending on policy, you might prevent retakes or allow new attempts.
            # For now, let's allow a new attempt if previous was completed or none exists.
            
            # Create a new TestResult for the student
            new_test_result = TestResult(
                test_id=test.id,
                user_id=current_user.id,
                total_questions=len(test.test_words) if test.test_words else 0,
                started_at=datetime.utcnow()
            )
            db.session.add(new_test_result)
            db.session.commit()
            
            session['active_test_result_id'] = new_test_result.id
            session['test_link'] = test.link
            # –Ø–≤–Ω–æ –ø–æ–º–µ—á–∞–µ–º —Å–µ—Å—Å–∏—é –∫–∞–∫ –∏–∑–º–µ–Ω–µ–Ω–Ω—É—é
            session.modified = True
            print(f"DEBUG: Created new test result, ID: {new_test_result.id}, session: {dict(session)}")
            
            # –í–º–µ—Å—Ç–æ JSON-–æ—Ç–≤–µ—Ç–∞ –¥–µ–ª–∞–µ–º –ø—Ä—è–º–æ–π —Ä–µ–¥–∏—Ä–µ–∫—Ç
            resp = make_response(redirect('/test/' + test.link))
            resp.set_cookie('active_test_result_id', str(new_test_result.id))
            resp.set_cookie('test_link', test.link)
            return resp

    # GET request logic:
    if current_user.teacher == 'yes':
        # Teachers see the start page, clicking "Start" will POST and then redirect to preview
        return render_template('test_start.html', test=test, user=current_user)
        
    # --- STUDENT LOGIC FOR GET ---
    # If there's an existing incomplete test result, student should resume it.
    incomplete_result = TestResult.query.filter_by(
        test_id=test.id,
        user_id=current_user.id,
        completed_at=None
    ).first()

    if incomplete_result:
        # If student has an incomplete test, take them directly to it to resume
        session['active_test_result_id'] = incomplete_result.id
        session['test_link'] = test.link
        # –Ø–≤–Ω–æ –ø–æ–º–µ—á–∞–µ–º —Å–µ—Å—Å–∏—é –∫–∞–∫ –∏–∑–º–µ–Ω–µ–Ω–Ω—É—é
        session.modified = True
        print(f"DEBUG: Resuming incomplete test, ID: {incomplete_result.id}, session: {dict(session)}")
        # Redirect to the test interface itself (test_id handles rendering based on type)
        resp = make_response(redirect('/test/' + test.link))
        resp.set_cookie('active_test_result_id', str(incomplete_result.id))
        resp.set_cookie('test_link', test.link)
        return resp

    # If test is completed, show link to results or message
    completed_result = TestResult.query.filter(
        TestResult.test_id == test.id,
        TestResult.user_id == current_user.id,
        TestResult.completed_at.isnot(None)
    ).order_by(TestResult.completed_at.desc()).first()

    if completed_result:
        flash("–í—ã —É–∂–µ –∑–∞–≤–µ—Ä—à–∏–ª–∏ —ç—Ç–æ—Ç —Ç–µ—Å—Ç. –ü–æ—Å–º–æ—Ç—Ä–∏—Ç–µ —Å–≤–æ–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã.", "info")
        return redirect(url_for('test_results', test_id=test.id, result_id=completed_result.id))

    # Otherwise, show the test start page (if it's a GET request and no active/completed test for this user)
    return render_template('test_start.html', test=test, user=current_user)

@app.route('/submit_test/<int:test_id>', methods=['POST'])
def submit_test(test_id):
    if 'user_id' not in session:
        # For form submissions, redirect is more appropriate than JSON error
        flash("–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –Ω–µ –ø—Ä–æ–π–¥–µ–Ω–∞. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user:
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))

    test = Test.query.get_or_404(test_id)
    active_test_result = TestResult.query.filter_by(
        test_id=test.id,
        user_id=user.id,
        completed_at=None
    ).first()

    if not active_test_result:
        # This might happen if user tries to submit to a test they haven't started
        # or if they refresh the submit page after already submitting.
        # Check if a completed result exists to redirect to results page.
        completed_result = TestResult.query.filter_by(
            test_id=test.id,
            user_id=user.id
        ).filter(TestResult.completed_at.isnot(None)).order_by(TestResult.completed_at.desc()).first()
        if completed_result:
            flash("–í—ã —É–∂–µ –∑–∞–≤–µ—Ä—à–∏–ª–∏ —ç—Ç–æ—Ç —Ç–µ—Å—Ç.", "info")
            return redirect(url_for('test_results', test_id=test.id, result_id=completed_result.id))
        else:
            flash("–ù–µ –Ω–∞–π–¥–µ–Ω–æ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è —Ç–µ—Å—Ç–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –Ω–∞—á–Ω–∏—Ç–µ —Ç–µ—Å—Ç.", "warning")
            return redirect(url_for('take_test', test_link=test.link)) # Or to tests list

    # Server-side time limit check before processing answers
    if test.time_limit and test.time_limit > 0 and active_test_result.started_at:
        allowed_duration = timedelta(minutes=test.time_limit)
        # Add a small grace period (e.g., 5-10 seconds) to account for submission latency
        grace_period = timedelta(seconds=10)
        actual_time_limit_on_server = active_test_result.started_at + allowed_duration + grace_period
        
        if datetime.utcnow() > actual_time_limit_on_server:
            # Time is definitively up on the server
            flash("–í—Ä–µ–º—è –Ω–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —Ç–µ—Å—Ç–∞ –∏—Å—Ç–µ–∫–ª–æ. –û—Ç–≤–µ—Ç—ã, –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–µ –ø–æ—Å–ª–µ –∏—Å—Ç–µ—á–µ–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏, –Ω–µ –∑–∞—Å—á–∏—Ç–∞–Ω—ã.", "error")
            
            if not active_test_result.completed_at: # Ensure we only complete it once
                active_test_result.completed_at = active_test_result.started_at + allowed_duration # Mark completion at the exact intended end time
                # Calculate time taken for timeout case (should be exactly the time limit)
                if active_test_result.started_at:
                    active_test_result.time_taken = test.time_limit  # Time limit in minutes
                else:
                    active_test_result.time_taken = 0
                # Optionally, set score to 0 if no answers are accepted post-deadline
                # This depends on whether partial/in-time answers were already saved progressively.
                # For the current setup, it implies answers submitted with this request are too late.
                # If you want to be very strict and not rely on progressively saved state (which isn't fully there for add_letter):
                # active_test_result.score = 0
                # active_test_result.correct_answers = 0
                # active_test_result.answers = json.dumps({}) # Clear any answers if submission is void
                # However, if the client *did* submit something just before this server check, 
                # but the check still determines it's too late, those answers won't be processed by the code below.
                # The most straightforward for now is to ensure it's marked completed and then redirect.
                # The scoring logic below will not run if we redirect here.
                
            db.session.commit()
            return redirect(url_for('test_results', test_id=test.id, result_id=active_test_result.id))

    # data = request.get_json() # Changed to use request.form for standard HTML form submission
    submitted_answers_map = {}
    if test.type == 'add_letter':
        # For add_letter, reconstruct answers from individual input boxes
        # Inputs are named like: answer_{test_word.id}_{input_index_in_word}
        for key, value in request.form.items():
            if key.startswith('answer_'):
                parts = key.split('_')
                if len(parts) == 3:
                    try:
                        word_id = int(parts[1])
                        input_idx = int(parts[2])
                        if word_id not in submitted_answers_map:
                            submitted_answers_map[word_id] = {}
                        submitted_answers_map[word_id][input_idx] = value.strip()
                    except ValueError:
                        # Handle cases where parsing fails, though names should be controlled
                        print(f"Warning: Could not parse form key {key}")
                        pass # Or log an error
    # else: # For other test types, if they were using AJAX and data.get('answers', [])
        # This part would need to be adapted if other test types also switch to form submission
        # For now, let's assume other test types might still send answers differently or need updates
        # If they also submit via form with a simple list-like structure for answers (e.g. answer_0, answer_1):
        # pass # Or retrieve their answers based on their specific form field naming
        # If other tests also submit via form, they might name fields like `answer_{test_word.id}` directly.
        # For now, this path is not fully handled for non-add_letter types if they stop using JSON.
        pass

    # Calculate score based on test type
    current_score_count = 0
    detailed_results_for_db = [] # To store TestAnswer objects
    total_questions = len(test.test_words)
    answers_json_for_db = {} # To store in TestResult.answers (JSON)

    # Ensure test words are ordered by their defined word_order for consistent processing
    ordered_test_words = sorted(test.test_words, key=lambda tw: tw.word_order)

    for test_word in ordered_test_words:
        user_submitted_answer_string = ""
        is_correct = False

        if test.type == 'add_letter':
            if test_word.id in submitted_answers_map:
                # Reconstruct the answer from sorted input characters
                answer_chars = []
                sorted_inputs = sorted(submitted_answers_map[test_word.id].items())
                for _, char_val in sorted_inputs:
                    answer_chars.append(char_val)
                user_submitted_answer_string = "".join(answer_chars)
            # For add_letter, TestWord.correct_answer stores the combined missing letters
            is_correct = user_submitted_answer_string.lower() == test_word.correct_answer.lower()
        
        elif test.type == 'multiple_choice_multiple':
            user_selected_options = sorted(request.form.getlist(f'answer_{test_word.id}'))
            user_submitted_answer_string = "|".join(user_selected_options)

            correct_options_list = sorted(test_word.correct_answer.split('|'))
            actual_correct_string_for_comparison = "|".join(correct_options_list)

            is_correct = user_submitted_answer_string.lower() == actual_correct_string_for_comparison.lower()

        elif test.type == 'multiple_choice_single':
            user_submitted_answer_string = request.form.get(f'answer_{test_word.id}', '').strip()
            is_correct = user_submitted_answer_string.lower() == test_word.correct_answer.lower()
        elif test.type == 'dictation':
            current_word_chars_map = {}
            # Collect all characters for this specific test_word.id
            # Key format: dictation_answer_{test_word.id}_{char_index}
            prefix = f'dictation_answer_{test_word.id}_'
            for key, value in request.form.items():
                if key.startswith(prefix):
                    try:
                        char_idx_str = key[len(prefix):] # Get the part after the prefix
                        char_idx = int(char_idx_str)
                        
                        # Ensure value is a single character, take the first if multiple submitted
                        # maxlength=1 on client side should prevent multiple.
                        char_value = value.strip()
                        if len(char_value) > 1:
                            char_value = char_value[0]
                        # If char_value is empty, it represents an empty box for that position.
                        
                        current_word_chars_map[char_idx] = char_value
                    except ValueError:
                        # Log or handle malformed key if char_idx_str is not an int
                        print(f"Warning: Could not parse char index from key {key} for dictation word {test_word.id}")
                        pass # Ignore malformed keys
            
            answer_chars = []
            if current_word_chars_map:
                # Reconstruct the word by sorting characters by their index.
                # Iterate from 0 up to the maximum index found for this word.
                max_idx_found = -1
                if current_word_chars_map: # Ensure not empty before calling max
                    max_idx_found = max(current_word_chars_map.keys())
                
                for i in range(max_idx_found + 1):
                    answer_chars.append(current_word_chars_map.get(i, "")) # Append char or empty string if index is missing
            
            user_submitted_answer_string = "".join(answer_chars)
            
            # Normalize answers for comparison in dictation
            normalized_user_answer = re.sub(r'[\s\.,!?-]', '', user_submitted_answer_string).lower()
            normalized_correct_answer = re.sub(r'[\s\.,!?-]', '', test_word.correct_answer).lower()
            is_correct = normalized_user_answer == normalized_correct_answer
        elif test.type == 'true_false': # Example
            user_submitted_answer_string = request.form.get(f'answer_{test_word.id}', '').strip()
            is_correct = user_submitted_answer_string.capitalize() == test_word.correct_answer # True/False comparison
        else: # Fallback for other types or if logic is missing
            user_submitted_answer_string = request.form.get(f'answer_{test_word.id}', '').strip()
            is_correct = user_submitted_answer_string.lower() == test_word.correct_answer.lower()
        
        if is_correct:
            current_score_count += 1
        
        answers_json_for_db[str(test_word.id)] = user_submitted_answer_string
        detailed_results_for_db.append({
            'test_word_id': test_word.id,
            'user_answer': user_submitted_answer_string,
            'is_correct': is_correct
        })

    # Update active_test_result
    active_test_result.score = int((current_score_count / total_questions) * 100) if total_questions > 0 else 0
    active_test_result.correct_answers = current_score_count
    active_test_result.total_questions = total_questions # Should already be set at start, but good to confirm
    completion_time = datetime.utcnow()
    active_test_result.completed_at = completion_time
    
    # Calculate time taken in minutes (safe calculation)
    if active_test_result.started_at:
        time_diff = completion_time - active_test_result.started_at
        active_test_result.time_taken = max(0, int(time_diff.total_seconds() / 60))  # Convert to minutes, ensure non-negative
    else:
        active_test_result.time_taken = 0  # Fallback if started_at is missing
        
    active_test_result.answers = json.dumps(answers_json_for_db)
    
    # Add TestAnswer instances
    for ans_data in detailed_results_for_db:
        test_answer_entry = TestAnswer(
            test_result_id=active_test_result.id,
            test_word_id=ans_data['test_word_id'],
            user_answer=ans_data['user_answer'],
            is_correct=ans_data['is_correct']
        )
        db.session.add(test_answer_entry)

    try:
        db.session.commit()
        flash("–¢–µ—Å—Ç —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω!", "success")
        return redirect(url_for('test_results', test_id=test.id, result_id=active_test_result.id))
    except Exception as e:
        db.session.rollback()
        flash(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ç–µ—Å—Ç–∞: {str(e)}", "error")
        # Redirect back to the test page, or a general error page
        return redirect(url_for('take_test', test_link=test.link))

@app.route('/test_results/<int:test_id>/<int:result_id>')
def test_results(test_id, result_id):
    if 'user_id' not in session:
        return redirect(url_for('auth.login'))

    user = User.query.get(session['user_id'])
    if not user:
        session.pop('user_id', None)
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))

    test = Test.query.get_or_404(test_id)
    result = TestResult.query.get_or_404(result_id)

    # Verify access to results
    can_view_results = False
    if result.user_id == user.id: # Student viewing their own results
        can_view_results = True
    elif user.teacher == 'yes' and test.created_by == user.id: # Teacher viewing results of a test they created
        can_view_results = True

    if not can_view_results:
        flash("–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –¥–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ —ç—Ç–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤.", "warning")
        return redirect(url_for('tests'))

    # Determine if detailed results should be shown
    show_detailed_results = False  # Default to False
    if user.teacher == 'yes' and test.created_by == user.id:
        # Teacher can always see detailed results for tests they created
        show_detailed_results = True
    elif result.user_id == user.id:  # It's a student viewing their own results
        if not test.is_active:  # Student can see details ONLY if the test is archived
            show_detailed_results = True
        # If the test is active, show_detailed_results remains False for the student

    # Get detailed results if allowed
    detailed_answers = [] 
    if show_detailed_results: # Only fetch if we are going to show them
        for answer_obj in result.test_answers: # answer_obj is a TestAnswer instance
            test_word_instance = answer_obj.test_word # This is the TestWord instance
            
            detailed_answers_item = {
                'user_answer': answer_obj.user_answer,
                'actual_correct_answer': test_word_instance.correct_answer,
                'is_correct': answer_obj.is_correct,
                'options': test_word_instance.options,
                # Initialize parts for add_letter, will be populated below
                'student_reconstructed_parts': None,
                'correct_reconstructed_parts': None
            }

            if test.type == 'add_letter':
                detailed_answers_item['question_presented'] = test_word_instance.word 
                detailed_answers_item['prompt_or_support'] = test_word_instance.perevod

                # Reconstruct student's attempt
                student_parts = []
                gapped_template = test_word_instance.word
                student_letters = list(answer_obj.user_answer)
                s_idx = 0
                correct_letters_iter_for_student = iter(test_word_instance.correct_answer)
                for char_template in gapped_template:
                    part_info = {'char': char_template, 'is_student_input': False, 'is_correct_char': None}
                    if char_template == '_':
                        if s_idx < len(student_letters):
                            part_info['char'] = student_letters[s_idx]
                            part_info['is_student_input'] = True
                            try:
                                correct_char_for_gap = next(correct_letters_iter_for_student)
                                if student_letters[s_idx].lower() == correct_char_for_gap.lower():
                                    part_info['is_correct_char'] = True
                                else:
                                    part_info['is_correct_char'] = False
                            except StopIteration: # More student letters than correct gaps implies mismatch
                                part_info['is_correct_char'] = False
                            s_idx += 1
                        else: # Not enough student letters for this gap
                            part_info['char'] = '_' 
                            part_info['is_student_input'] = True # It was a gap student should have filled
                            part_info['is_correct_char'] = False # Mark as incorrect as it's unfilled
                    student_parts.append(part_info)
                detailed_answers_item['student_reconstructed_parts'] = student_parts

                # Reconstruct correct word display
                correct_parts = []
                correct_letters = list(test_word_instance.correct_answer)
                c_idx = 0
                for char_template in gapped_template:
                    part_info = {'char': char_template, 'is_student_input': False}
                    if char_template == '_':
                        if c_idx < len(correct_letters):
                            part_info['char'] = correct_letters[c_idx]
                            part_info['is_student_input'] = True # It's a filled gap
                            c_idx += 1
                        else:
                            part_info['char'] = '_' # Should not happen if data is consistent
                    correct_parts.append(part_info)
                detailed_answers_item['correct_reconstructed_parts'] = correct_parts
            
            elif test.type == 'multiple_choice_single' or test.type == 'multiple_choice_multiple':
                detailed_answers_item['question_presented'] = test_word_instance.perevod
                detailed_answers_item['prompt_or_support'] = test_word_instance.word
            elif test.type == 'fill_word':
                detailed_answers_item['question_presented'] = test_word_instance.word
                detailed_answers_item['prompt_or_support'] = test_word_instance.perevod
            elif test.type == 'true_false':
                detailed_answers_item['question_presented'] = test_word_instance.word
                detailed_answers_item['prompt_or_support'] = test_word_instance.perevod
            else: # Default for dictation etc.
                detailed_answers_item['question_presented'] = test_word_instance.word 
                detailed_answers_item['prompt_or_support'] = test_word_instance.perevod

            detailed_answers.append(detailed_answers_item)

    # Format time taken for display
    time_taken_display = format_time_taken(result.time_taken)
    
    return render_template('test_results.html',
        test=test,
        score=result.score,
        correct_answers=result.correct_answers,
        total_questions=result.total_questions,
        time_taken=time_taken_display,
        time_taken_raw=result.time_taken,  # Raw minutes for any calculations
        incorrect_answers=result.total_questions - result.correct_answers,
        results_summary=detailed_answers, # Changed variable name passed to template
        show_detailed_results=show_detailed_results
    )

@app.route("/games")
def games():
    if 'user_id' not in session:
        return redirect(url_for('auth.login'))
    
    user = User.query.get(session['user_id'])
    if not user:
        session.pop('user_id', None)
        flash("–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ —Å–Ω–æ–≤–∞.", "error")
        return redirect(url_for('auth.login'))
        
    return render_template('games.html', is_teacher=user.teacher == 'yes')

# flashcards_select_module and flashcards_game will be moved to games_bp

@app.route('/games/flashcards/select', methods=['GET'])
def flashcards_select_module():
    if 'user_id' not in session:
        return redirect(url_for('auth.login')) # Corrected url_for
    # Fetch all unique classes for the first dropdown
    classes = db.session.query(Word.classs).distinct().order_by(Word.classs).all()
    classes = [c[0] for c in classes if c[0]] # Ensure not None or empty
    return render_template('game_flashcards_select_improved.html', classes=classes)

@app.route('/games/flashcards/<class_name>/<unit_name>/<module_name>')
@app.route('/games/flashcards/<class_name>/<unit_name>')
@app.route('/games/flashcards/<class_name>')
def flashcards_game(class_name, unit_name=None, module_name=None):
    if 'user_id' not in session:
        flash("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –≤ —Å–∏—Å—Ç–µ–º—É –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ–ª—ç—à-–∫–∞—Ä—Ç–æ—á–∫–∞–º.", "warning")
        return redirect(url_for('auth.login'))

    user_id = session['user_id']
    
    # –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–≥—Ä—ã –∏–∑ URL
    mode = request.args.get('mode', 'specific')
    cards_count = int(request.args.get('cards', 0))  # 0 –æ–∑–Ω–∞—á–∞–µ—Ç –≤—Å–µ –∫–∞—Ä—Ç–æ—á–∫–∏
    selected_modules = request.args.get('modules', '').split(',') if request.args.get('modules') else []
    selected_units = request.args.get('units', '').split(',') if request.args.get('units') else []
    
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞–∫–∏–µ —Å–ª–æ–≤–∞ –∑–∞–≥—Ä—É–∂–∞—Ç—å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞
    words_in_module = []
    
    if mode == 'specific' and unit_name and module_name:
        # –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –º–æ–¥—É–ª—å
        words_in_module = Word.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name}, –ú–æ–¥—É–ª—å: {module_name}"
    elif mode == 'unit' and unit_name:
        # –í–µ—Å—å —é–Ω–∏—Ç
        words_in_module = Word.query.filter_by(classs=class_name, unit=unit_name).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name} (–≤—Å–µ –º–æ–¥—É–ª–∏)"
    elif mode == 'class':
        # –í–µ—Å—å –∫–ª–∞—Å—Å
        words_in_module = Word.query.filter_by(classs=class_name).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name} (–≤—Å–µ —é–Ω–∏—Ç—ã –∏ –º–æ–¥—É–ª–∏)"
    elif mode == 'multiple-modules' and unit_name and selected_modules:
        # –ù–µ—Å–∫–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –º–æ–¥—É–ª–µ–π
        words_in_module = Word.query.filter(
            Word.classs == class_name,
            Word.unit == unit_name,
            Word.module.in_(selected_modules)
        ).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name}, –ú–æ–¥—É–ª–∏: {', '.join(selected_modules)}"
    elif mode == 'multiple-units' and selected_units:
        # –ù–µ—Å–∫–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —é–Ω–∏—Ç–æ–≤
        words_in_module = Word.query.filter(
            Word.classs == class_name,
            Word.unit.in_(selected_units)
        ).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç—ã: {', '.join(selected_units)}"
    else:
        # Fallback –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –º–æ–¥—É–ª—é
        if unit_name and module_name:
            words_in_module = Word.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()
            display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name}, –ú–æ–¥—É–ª—å: {module_name}"
        else:
            flash("–ù–µ–≤–µ—Ä–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–≥—Ä—ã.", "warning")
            return redirect(url_for('flashcards_select_module'))

    if not words_in_module:
        flash(f"–î–ª—è –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ —Å–ª–æ–≤.", "warning")
        return redirect(url_for('flashcards_select_module'))

    augmented_words_list = []
    now = datetime.utcnow()

    for word_obj in words_in_module:
        review_data = UserWordReview.query.filter_by(user_id=user_id, word_id=word_obj.id).first()

        is_new = review_data is None
        next_review_at_iso = None
        interval = None

        if review_data:
            next_review_at_iso = review_data.next_review_at.isoformat()
            interval = review_data.interval_days
            is_due = review_data.next_review_at <= now
        else: # New word, always due
            is_due = True
            # next_review_at_iso remains None for new cards, they will be sorted first.

        augmented_words_list.append({
            'id': word_obj.id,
            'word': word_obj.word,
            'perevod': word_obj.perevod,
            'classs': word_obj.classs,
            'unit': word_obj.unit,
            'module': word_obj.module,
            'next_review_at': next_review_at_iso,
            'interval_days': interval,
            'is_new': is_new,
            'is_due': is_due # Helper for sorting
        })

    # Sort words:
    # 1. Due words (next_review_at <= now or is_new) first.
    # 2. Among due words, sort new ones before reviewed ones.
    # 3. Among reviewed due words, sort by earliest next_review_at.
    # 4. Among not-due words, sort by earliest next_review_at.
    # 5. As a final tie-breaker, shuffle or use word ID. For now, word ID for stability.

    augmented_words_list.sort(key=lambda x: (
        not x['is_due'],  # False (due) comes before True (not due)
        x['next_review_at'] is None, # New words (None) come before reviewed due words
        x['next_review_at'] if x['next_review_at'] else now.isoformat(), # Actual review date, use now for None to group them
        x['id'] # Stable sort by ID as a final tie-breaker
    ))


    # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞—Ä—Ç–æ—á–µ–∫ –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω–æ
    if cards_count > 0 and len(augmented_words_list) > cards_count:
        augmented_words_list = augmented_words_list[:cards_count]

    if not augmented_words_list: # Should be caught by words_in_module check, but as a safeguard
        flash(f"–î–ª—è –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ —Å–ª–æ–≤.", "warning")
        return redirect(url_for('flashcards_select_module'))

    return render_template('game_flashcards_improved.html',
                           words=augmented_words_list,
                           class_name=class_name,
                           unit_name=unit_name or "–í—Å–µ —é–Ω–∏—Ç—ã",
                           module_name=module_name or "–í—Å–µ –º–æ–¥—É–ª–∏",
                           display_info=display_info,
                           total_cards=len(augmented_words_list),
                           game_mode=mode)

# word_match_select_module and word_match_game will be moved to games_bp

@app.route('/games/word_match/select', methods=['GET'])
def word_match_select_module():
    if 'user_id' not in session:
        return redirect(url_for('auth.login')) # Corrected url_for
    classes = db.session.query(Word.classs).distinct().order_by(Word.classs).all()
    classes = [c[0] for c in classes if c[0]]
    return render_template('game_word_match_select_improved.html', classes=classes)

@app.route('/games/word_match/<class_name>/<unit_name>/<module_name>')
@app.route('/games/word_match/<class_name>/<unit_name>')
@app.route('/games/word_match/<class_name>')
def word_match_game(class_name, unit_name=None, module_name=None):
    if 'user_id' not in session:
        flash("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –≤ —Å–∏—Å—Ç–µ–º—É.", "warning")
        return redirect(url_for('auth.login'))

    # –ü–æ–ª—É—á–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–≥—Ä—ã –∏–∑ URL
    mode = request.args.get('mode', 'specific')
    cards_count = int(request.args.get('cards', 8))  # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∞—Ä —Å–ª–æ–≤
    timer_duration = int(request.args.get('timer', 0))
    enable_stopwatch = request.args.get('stopwatch') == 'true'
    selected_modules = request.args.get('modules', '').split(',') if request.args.get('modules') else []
    selected_units = request.args.get('units', '').split(',') if request.args.get('units') else []

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –∫–∞–∫–∏–µ —Å–ª–æ–≤–∞ –∑–∞–≥—Ä—É–∂–∞—Ç—å –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ä–µ–∂–∏–º–∞
    all_words = []
    
    if mode == 'specific' and unit_name and module_name:
        # –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –º–æ–¥—É–ª—å
        all_words = Word.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name}, –ú–æ–¥—É–ª—å: {module_name}"
    elif mode == 'unit' and unit_name:
        # –í–µ—Å—å —é–Ω–∏—Ç
        all_words = Word.query.filter_by(classs=class_name, unit=unit_name).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name} (–≤—Å–µ –º–æ–¥—É–ª–∏)"
    elif mode == 'class':
        # –í–µ—Å—å –∫–ª–∞—Å—Å
        all_words = Word.query.filter_by(classs=class_name).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name} (–≤—Å–µ —é–Ω–∏—Ç—ã –∏ –º–æ–¥—É–ª–∏)"
    elif mode == 'multiple-modules' and unit_name and selected_modules:
        # –ù–µ—Å–∫–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –º–æ–¥—É–ª–µ–π
        all_words = Word.query.filter(
            Word.classs == class_name,
            Word.unit == unit_name,
            Word.module.in_(selected_modules)
        ).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name}, –ú–æ–¥—É–ª–∏: {', '.join(selected_modules)}"
    elif mode == 'multiple-units' and selected_units:
        # –ù–µ—Å–∫–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —é–Ω–∏—Ç–æ–≤
        all_words = Word.query.filter(
            Word.classs == class_name,
            Word.unit.in_(selected_units)
        ).all()
        display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç—ã: {', '.join(selected_units)}"
    else:
        # Fallback –∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É –º–æ–¥—É–ª—é
        if unit_name and module_name:
            all_words = Word.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()
            display_info = f"–ö–ª–∞—Å—Å: {class_name}, –Æ–Ω–∏—Ç: {unit_name}, –ú–æ–¥—É–ª—å: {module_name}"
        else:
            flash("–ù–µ–≤–µ—Ä–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∏–≥—Ä—ã.", "warning")
            return redirect(url_for('word_match_select_module'))

    if not all_words:
        flash(f"–î–ª—è –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ —Å–ª–æ–≤.", "warning")
        return redirect(url_for('word_match_select_module'))

    # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–∞—Ä –¥–æ—Å—Ç—É–ø–Ω—ã–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Å–ª–æ–≤
    max_pairs = len(all_words)
    num_pairs = min(cards_count, max_pairs)

    if num_pairs < 2:
        flash(f"–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å–ª–æ–≤ –¥–ª—è –∏–≥—Ä—ã (–Ω—É–∂–Ω–æ —Ö–æ—Ç—è –±—ã 2, –Ω–∞–π–¥–µ–Ω–æ {max_pairs}).", "warning")
        return redirect(url_for('word_match_select_module'))

    # –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ —Å–ª–æ–≤–∞
    selected_word_objects = random.sample(all_words, num_pairs)

    original_words_for_js = []
    jumbled_words_list = []
    jumbled_translations_list = []

    for word_obj in selected_word_objects:
        original_words_for_js.append({'id': word_obj.id, 'word': word_obj.word, 'translation': word_obj.perevod})
        jumbled_words_list.append({'id': word_obj.id, 'text': word_obj.word})
        jumbled_translations_list.append({'id': word_obj.id, 'text': word_obj.perevod})

    random.shuffle(jumbled_words_list)
    random.shuffle(jumbled_translations_list)

    return render_template('game_word_match.html',
                           original_words=original_words_for_js,
                           jumbled_words_list=jumbled_words_list,
                           jumbled_translations_list=jumbled_translations_list,
                           class_name=class_name,
                           unit_name=unit_name or "–í—Å–µ —é–Ω–∏—Ç—ã",
                           module_name=module_name or "–í—Å–µ –º–æ–¥—É–ª–∏",
                           display_info=display_info,
                           num_pairs=num_pairs,
                           timer_duration=timer_duration,
                           enable_stopwatch=enable_stopwatch,
                           game_mode=mode)

# sentence_scramble_select_module and sentence_scramble_game will be moved to games_bp

@app.route('/games/sentence_scramble/select', methods=['GET'])
def sentence_scramble_select_module():
    if 'user_id' not in session:
        return redirect(url_for('auth.login')) # Corrected url_for
    # Fetch all unique classes that have sentences
    classes = db.session.query(Sentence.classs).distinct().order_by(Sentence.classs).all()
    classes = [c[0] for c in classes if c[0]]
    return render_template('game_sentence_scramble_select.html', classes=classes)

@app.route('/games/sentence_scramble/<class_name>/<unit_name>/<module_name>')
def sentence_scramble_game(class_name, unit_name, module_name):
    if 'user_id' not in session:
        flash("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –≤ —Å–∏—Å—Ç–µ–º—É.", "warning")
        return redirect(url_for('auth.login')) # Corrected url_for

    sentences_query = Sentence.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()

    if not sentences_query:
        flash(f"–î–ª—è –º–æ–¥—É–ª—è '{module_name}' (—é–Ω–∏—Ç '{unit_name}', –∫–ª–∞—Å—Å '{class_name}') –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–π.", "warning")
        return redirect(url_for('sentence_scramble_select_module'))

    sentences_for_js = []
    for sentence_obj in sentences_query:
        sentences_for_js.append({
            'id': sentence_obj.id,
            'text': sentence_obj.text,
            'translation': sentence_obj.translation
            # Add other fields like classs, unit, module if needed by JS, but likely not for the game itself
        })

    # Shuffle the list of sentences for the game
    random.shuffle(sentences_for_js)

    return render_template('game_sentence_scramble.html',
                           sentences=sentences_for_js, # Pass the list of sentence dicts
                           class_name=class_name,
                           unit_name=unit_name,
                           module_name=module_name)

# hangman_select_module and hangman_game will be moved to games_bp

@app.route('/games/hangman/select', methods=['GET'])
def hangman_select_module():
    if 'user_id' not in session:
        return redirect(url_for('auth.login'))
    # Fetch all unique classes for the first dropdown
    classes = db.session.query(Word.classs).distinct().order_by(Word.classs).all()
    classes = [c[0] for c in classes if c[0]] # Ensure not None or empty
    return render_template('game_hangman_select_improved.html', classes=classes)

@app.route('/games/hangman/<class_name>/<unit_name>/<module_name>')
def hangman_game(class_name, unit_name, module_name):
    if 'user_id' not in session:
        flash("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–æ–π–¥–∏—Ç–µ –≤ —Å–∏—Å—Ç–µ–º—É.", "warning")
        return redirect(url_for('auth.login'))

    # Get game settings from URL parameters
    num_words = int(request.args.get('words', 10))  # Default 10 words
    timer_duration = int(request.args.get('timer', 0))  # Default no timer
    enable_stopwatch = request.args.get('stopwatch', 'false').lower() == 'true'
    difficulty = request.args.get('difficulty', 'medium')  # easy, medium, hard
    game_mode = request.args.get('mode', 'specific')  # specific, unit, class, multiple

    # Handle different game modes
    if game_mode == 'unit':
        words_query = Word.query.filter_by(classs=class_name, unit=unit_name).all()
    elif game_mode == 'class':
        words_query = Word.query.filter_by(classs=class_name).all()
    elif game_mode == 'multiple':
        modules = request.args.get('modules', '').split(',')
        if not modules or modules == ['']:
            flash("–ù–µ –≤—ã–±—Ä–∞–Ω—ã –º–æ–¥—É–ª–∏ –¥–ª—è –∏–≥—Ä—ã.", "warning")
            return redirect(url_for('hangman_select_module'))
        words_query = Word.query.filter(
            Word.classs == class_name,
            Word.unit == unit_name,
            Word.module.in_(modules)
        ).all()
    else:  # specific module
        words_query = Word.query.filter_by(classs=class_name, unit=unit_name, module=module_name).all()

    if not words_query:
        flash(f"–î–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –º–æ–¥—É–ª—è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ —Å–ª–æ–≤.", "warning")
        return redirect(url_for('hangman_select_module'))

    # Filter words by difficulty if specified
    if difficulty == 'easy':
        # Easy: words 3-5 letters
        words_query = [w for w in words_query if 3 <= len(w.word) <= 5]
    elif difficulty == 'medium':
        # Medium: words 4-8 letters
        words_query = [w for w in words_query if 4 <= len(w.word) <= 8]
    elif difficulty == 'hard':
        # Hard: words 6+ letters
        words_query = [w for w in words_query if len(w.word) >= 6]

    if not words_query:
        flash(f"–î–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö —Å–ª–æ–≤.", "warning")
        return redirect(url_for('hangman_select_module'))

    # Limit number of words and shuffle
    if len(words_query) > num_words:
        words_query = random.sample(words_query, num_words)
    else:
        random.shuffle(words_query)

    # Prepare words for the game
    game_words = []
    for word_obj in words_query:
        game_words.append({
            'id': word_obj.id,
            'word': word_obj.word.upper(),  # Uppercase for hangman
            'translation': word_obj.perevod,
            'definition': getattr(word_obj, 'definition', ''),
            'example': getattr(word_obj, 'example', '')
        })

    return render_template('game_hangman_improved.html',
                           words_data=game_words,
                           class_name=class_name,
                           unit_name=unit_name,
                           module_name=module_name,
                           timer_duration=timer_duration,
                           enable_stopwatch=enable_stopwatch,
                           difficulty=difficulty,
                           game_mode=game_mode,
                           num_words=len(game_words))


@app.route('/test_details_data/<int:test_id>')
def test_details_data(test_id):
    if 'user_id' not in session:
        return jsonify({'error': 'Authentication required'}), 401

    user = User.query.get(session['user_id'])
    if not user or user.teacher != 'yes': # Only teachers should access this live data endpoint
        return jsonify({'error': 'Forbidden for non-teachers'}), 403

    test = Test.query.get_or_404(test_id)
    if test.created_by != user.id:
        return jsonify({'error': 'Forbidden, not test creator'}), 403

    students_in_class = User.query.filter_by(class_number=test.classs, teacher='no').all()
    total_students_in_class = len(students_in_class)
    all_results_for_test = TestResult.query.filter(
        TestResult.test_id == test.id,
        TestResult.started_at >= test.created_at
    ).all()

    completed_students_details_json = []
    in_progress_students_details_json = []
    not_started_student_ids = {s.id for s in students_in_class}

    for result in all_results_for_test:
        student_user = User.query.get(result.user_id)
        if not student_user or student_user.teacher == 'yes':
            if student_user and result.user_id in not_started_student_ids:
                not_started_student_ids.remove(result.user_id)
            continue

        if result.user_id in not_started_student_ids:
            not_started_student_ids.remove(result.user_id)
        
        student_data = {
            'id': student_user.id,
            'fio': student_user.fio,
            'nick': student_user.nick,
            'result_id': result.id
        }

        if result.completed_at:
            student_data.update({
                'completed_at_iso': result.completed_at.isoformat() + "Z" if result.completed_at else None,
                'score': result.score,
                'correct_answers': result.correct_answers,
                'total_questions': result.total_questions,
                'time_taken_display': format_time_taken(result.time_taken),
                'time_taken_minutes': result.time_taken
            })
            completed_students_details_json.append(student_data)
        else: # In progress
            item_data_for_template = {
                'remaining_time_display': "–ë–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π",
                'has_time_limit': False,
                'end_time_utc_iso': None,
                'started_at_iso': result.started_at.isoformat() + "Z" if result.started_at else None
            }
            if test.time_limit and test.time_limit > 0 and result.started_at:
                end_time_utc = result.started_at + timedelta(minutes=test.time_limit)
                now_utc = datetime.utcnow()
                item_data_for_template['has_time_limit'] = True
                item_data_for_template['end_time_utc_iso'] = end_time_utc.isoformat() + "Z"
                if now_utc < end_time_utc:
                    remaining_delta = end_time_utc - now_utc
                    hours, remainder = divmod(remaining_delta.total_seconds(), 3600)
                    minutes, seconds_float = divmod(remainder, 60)
                    seconds = int(seconds_float)
                    if hours > 0:
                        item_data_for_template['remaining_time_display'] = f"{int(hours)}h {int(minutes)}m {seconds}s left"
                    else:
                        item_data_for_template['remaining_time_display'] = f"{int(minutes)}m {seconds}s left"
                else:
                    item_data_for_template['remaining_time_display'] = "–í—Ä–µ–º—è –≤—ã—à–ª–æ"
            student_data.update(item_data_for_template)
            in_progress_students_details_json.append(student_data)

    not_started_students_json = []
    for uid in not_started_student_ids:
        s_user = User.query.get(uid)
        if s_user:
            not_started_students_json.append({'id': s_user.id, 'fio': s_user.fio, 'nick': s_user.nick})
    
    completed_count = len(completed_students_details_json)
    progress_percentage = (completed_count / total_students_in_class * 100) if total_students_in_class > 0 else 0

    data_to_return = {
        'test_id': test.id,
        'test_title': test.title,
        'is_active': test.is_active,
        'total_students_in_class': total_students_in_class,
        'completed_students_count': completed_count,
        'in_progress_students_count': len(in_progress_students_details_json),
        'not_started_students_count': len(not_started_students_json),
        'progress_percentage': round(progress_percentage, 2),
        'completed_students': completed_students_details_json,
        'in_progress_students': in_progress_students_details_json,
        'not_started_students': not_started_students_json,
        'urls': { # For constructing links in JS if needed
            'test_results_base': url_for('test_results', test_id=test.id, result_id=0)[:-1] # remove trailing 0
        }
    }
    return jsonify(data_to_return)

@app.route('/games/flashcards/update_review', methods=['POST'])
def update_flashcard_review():
    if 'user_id' not in session:
        return jsonify({'error': 'Unauthorized', 'success': False}), 401

    data = request.get_json()
    word_id = data.get('word_id')
    quality = data.get('quality') # 0: Again, 1: Hard, 2: Good, 3: Easy

    if word_id is None or quality is None:
        return jsonify({'error': 'Missing word_id or quality', 'success': False}), 400

    try:
        quality = int(quality)
        word_id = int(word_id)
    except ValueError:
        return jsonify({'error': 'Invalid word_id or quality format', 'success': False}), 400

    user_id = session['user_id']
    review_item = UserWordReview.query.filter_by(user_id=user_id, word_id=word_id).first()

    if not review_item:
        review_item = UserWordReview(user_id=user_id, word_id=word_id)
        db.session.add(review_item)
        # For a new card, initial interval is often 1 day for "Good", or more for "Easy"
        # If "Again" or "Hard" on a new card, it might stay at 0 or 1 day.
        # Let's initialize with values that will be updated by the logic below.

    # Simplified SM-2 like logic
    # q (quality): 0-Again, 1-Hard, 2-Good, 3-Easy
    # EF (ease factor): Default 2.5. Min 1.3.
    # I(n) (interval after nth repetition):
    # I(1) = 1 day
    # I(2) = 6 days
    # For n > 2, I(n) = I(n-1) * EF

    if quality < 2: # Again (0) or Hard (1)
        review_item.interval_days = 1 # Reset or set to a short interval
        # For "Again", some might reset EF, but simplified SM-2 often just resets interval
        if quality == 0: # Strong "Again" - might penalize EF slightly
             review_item.ease_factor = max(1.3, review_item.ease_factor - 0.2)
        elif quality == 1: # "Hard" - penalize EF less
             review_item.ease_factor = max(1.3, review_item.ease_factor - 0.15)

    elif quality == 2: # Good
        if review_item.interval_days == 0: # First time seeing or after reset
            review_item.interval_days = 1
        elif review_item.interval_days == 1:
             review_item.interval_days = 6
        else:
            review_item.interval_days = round(review_item.interval_days * review_item.ease_factor)
        # EF is not changed for "Good" in basic SM-2 after initial setting
        # review_item.ease_factor remains same or small adjustment: ef = ef - 0.0 + 0.1 ....
        # No change to EF on "Good" after initial setting is common.

    elif quality == 3: # Easy
        if review_item.interval_days == 0:
            review_item.interval_days = 4 # Start with a longer interval for "Easy" new cards
        elif review_item.interval_days == 1:
             review_item.interval_days = 10 # Jump if it was a short interval
        else:
            review_item.interval_days = round(review_item.interval_days * review_item.ease_factor * 1.3) # Boost for easy
        review_item.ease_factor = min(3.0, review_item.ease_factor + 0.15) # Increase EF for "Easy"

    # Cap interval to avoid excessively long periods (e.g., 1 year)
    review_item.interval_days = min(review_item.interval_days, 365)


    review_item.next_review_at = datetime.utcnow() + timedelta(days=review_item.interval_days)
    review_item.last_reviewed_at = datetime.utcnow()

    try:
        db.session.commit()
        return jsonify({
            'success': True,
            'next_review_in_days': review_item.interval_days,
            'next_review_date': review_item.next_review_at.isoformat(),
            'ease_factor': review_item.ease_factor
        })
    except Exception as e:
        db.session.rollback()
        # Log the error e
        return jsonify({'error': 'Database commit failed', 'details': str(e), 'success': False}), 500

# API –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ —Ç–µ—Å—Ç–∞
@app.route('/api/test/<int:test_id>/save_progress', methods=['POST'])
def save_test_progress(test_id):
    """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –≤–æ –≤—Ä–µ–º—è –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏—è —Ç–µ—Å—Ç–∞"""
    if 'user_id' not in session:
        return jsonify({'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
    
    user = User.query.get(session['user_id'])
    if not user:
        return jsonify({'error': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 401
    
    # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π —Ç–µ—Å—Ç-—Ä–µ–∑—É–ª—å—Ç–∞—Ç
    test_result = TestResult.query.filter_by(
        test_id=test_id,
        user_id=user.id,
        completed_at=None
    ).first()
    
    if not test_result:
        return jsonify({'error': '–ê–∫—Ç–∏–≤–Ω—ã–π —Ç–µ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 404
    
    try:
        data = request.get_json()
        if not data or 'answers' not in data:
            return jsonify({'error': '–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –¥–∞–Ω–Ω—ã—Ö'}), 400
        
        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –æ—Ç–≤–µ—Ç–∞
        for answer_data in data['answers']:
            test_word_id = answer_data.get('test_word_id')
            user_answer = answer_data.get('user_answer', '')
            
            if not test_word_id:
                continue
                
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ test_word –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç —ç—Ç–æ–º—É —Ç–µ—Å—Ç—É
            test_word = TestWord.query.filter_by(id=test_word_id, test_id=test_id).first()
            if not test_word:
                continue
            
            # –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∑–∞–ø–∏—Å—å –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
            progress = TestProgress.query.filter_by(
                test_result_id=test_result.id,
                test_word_id=test_word_id
            ).first()
            
            if progress:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –∑–∞–ø–∏—Å—å
                progress.user_answer = json.dumps(user_answer) if isinstance(user_answer, (dict, list)) else str(user_answer)
                progress.last_updated = datetime.utcnow()
            else:
                # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é –∑–∞–ø–∏—Å—å
                progress = TestProgress(
                    test_result_id=test_result.id,
                    test_word_id=test_word_id,
                    user_answer=json.dumps(user_answer) if isinstance(user_answer, (dict, list)) else str(user_answer)
                )
                db.session.add(progress)
        
        db.session.commit()
        return jsonify({'success': True, 'message': '–ü—Ä–æ–≥—Ä–µ—Å—Å —Å–æ—Ö—Ä–∞–Ω–µ–Ω'})
        
    except Exception as e:
        db.session.rollback()
        return jsonify({'error': f'–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: {str(e)}'}), 500

@app.route('/api/test/<int:test_id>/load_progress', methods=['GET'])
def load_test_progress(test_id):
    """–ó–∞–≥—Ä—É–∂–∞–µ—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –ø—Ä–æ–º–µ–∂—É—Ç–æ—á–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
    if 'user_id' not in session:
        return jsonify({'error': '–ù–µ –∞–≤—Ç–æ—Ä–∏–∑–æ–≤–∞–Ω'}), 401
    
    user = User.query.get(session['user_id'])
    if not user:
        return jsonify({'error': '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω'}), 401
    
    # –ü–æ–ª—É—á–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π —Ç–µ—Å—Ç-—Ä–µ–∑—É–ª—å—Ç–∞—Ç
    test_result = TestResult.query.filter_by(
        test_id=test_id,
        user_id=user.id,
        completed_at=None
    ).first()
    
    if not test_result:
        return jsonify({'progress': {}})
    
    try:
        # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã
        progress_entries = TestProgress.query.filter_by(
            test_result_id=test_result.id
        ).all()
        
        progress_data = {}
        for entry in progress_entries:
            try:
                # –ü—ã—Ç–∞–µ–º—Å—è —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å JSON, –µ—Å–ª–∏ –Ω–µ –ø–æ–ª—É—á–∞–µ—Ç—Å—è - –∏—Å–ø–æ–ª—å–∑—É–µ–º –∫–∞–∫ —Å—Ç—Ä–æ–∫—É
                user_answer = json.loads(entry.user_answer) if entry.user_answer else ''
            except (json.JSONDecodeError, TypeError):
                user_answer = entry.user_answer or ''
            
            progress_data[str(entry.test_word_id)] = user_answer
        
        return jsonify({'progress': progress_data})
        
    except Exception as e:
        return jsonify({'error': f'–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: {str(e)}'}), 500

# Blueprints are already registered at the top of the file
# app.register_blueprint(tests_bp, url_prefix='/tests') # Example for future
# app.register_blueprint(games_bp, url_prefix='/games') # Example for future

@app.errorhandler(404)
def page_not_found(e):
    return render_template('404.html'), 404

if __name__ == "__main__":
    with app.app_context():
        db.create_all()
        # Add sample sentences if none exist
        if Sentence.query.count() == 0:
            sample_sentences = [
                Sentence(text="This is a simple sentence.", translation="–≠—Ç–æ –ø—Ä–æ—Å—Ç–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ.", classs="5", unit="1", module="Greetings"),
                Sentence(text="The cat sleeps on the mat.", translation="–ö–æ—à–∫–∞ —Å–ø–∏—Ç –Ω–∞ –∫–æ–≤—Ä–∏–∫–µ.", classs="5", unit="1", module="Greetings"),
                Sentence(text="I like to learn English.", translation="–ú–Ω–µ –Ω—Ä–∞–≤–∏—Ç—Å—è —É—á–∏—Ç—å –∞–Ω–≥–ª–∏–π—Å–∫–∏–π.", classs="5", unit="1", module="School"),
                Sentence(text="She reads a book every day.", translation="–û–Ω–∞ —á–∏—Ç–∞–µ—Ç –∫–Ω–∏–≥—É –∫–∞–∂–¥—ã–π –¥–µ–Ω—å.", classs="6", unit="2", module="Hobbies"),
                Sentence(text="They play football in the park.", translation="–û–Ω–∏ –∏–≥—Ä–∞—é—Ç –≤ —Ñ—É—Ç–±–æ–ª –≤ –ø–∞—Ä–∫–µ.", classs="6", unit="2", module="Hobbies")
            ]
            db.session.bulk_save_objects(sample_sentences)
            db.session.commit()
            print("Added sample sentences.")
        print("Database tables created (or already exist). Running test.py...") # Optional: for logging
        try:
            subprocess.run(["python", "test.py"], check=True, capture_output=True, text=True)
            print("test.py executed successfully.") # Optional: for logging
        except subprocess.CalledProcessError as e:
            print(f"Error running test.py: {e}") # Optional: for logging
            print(f"stdout: {e.stdout}")
            print(f"stderr: {e.stderr}")
            # Decide if you want to exit or continue if test.py fails
            # For now, it will continue to app.run()
    app.run("0.0.0.0", debug=True, port=1800)


site_1 ‚Äî –∫–æ–ø–∏—è.txt (/home/amir/Documents/Info/Duckly/site_1 ‚Äî –∫–æ–ø–∏—è.txt):
from markupsafe import escape
from flask import Flask, jsonify, request, render_template, redirect, url_for, flash, make_response
from flask_sqlalchemy import SQLAlchemy
import base64 as bs64
import time
import sqlite3



app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
app.secret_key = 'your-super-secret-key-12345'  # Added secret key for session management
db = SQLAlchemy(app)

class User(db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    fio = db.Column(db.String, nullable=False)
    nick = db.Column(db.String, unique=True, nullable=False)
    password = db.Column(db.String, nullable=False)
    secret_key = db.Column(db.String, nullable=False)
    teacher = db.Column(db.String, nullable=True)

class Word(db.Model):
    __tablename__ = 'words'
    id = db.Column(db.Integer, primary_key=True)
    word = db.Column(db.String, nullable=False)
    perevod = db.Column(db.String, nullable=False)
    classs = db.Column('class', db.String, nullable=False)
    unit = db.Column(db.String, nullable=False)
    module = db.Column(db.String, nullable=False)

class Test(db.Model):
    __tablename__ = 'tests'
    classs = db.Column('class', db.String, primary_key=True)
    unit = db.Column(db.String, primary_key=True)
    type = db.Column(db.String, nullable=False)
    link = db.Column(db.String, unique=True, nullable=False)



@app.route("/")
def index():
    return redirect('/hello', 302)

@app.route("/user/<name>")
def greet(name):
    return f"Hello, {name}!"

@app.route("/profile")
def profile():
    reqinnone = 0
    user = None
    for cookie_name in request.cookies:
        user_obj = User.query.filter_by(nick=cookie_name).first()
        if user_obj:
            secret_key = bs64.b64encode(str.encode(user_obj.nick + user_obj.password[:2])).decode("utf-8")
            if request.cookies.get(cookie_name) == secret_key:
                user = user_obj
                break
            elif request.cookies.get(cookie_name) is not None:
                res = make_response(redirect('hello', 302))
                res.set_cookie(cookie_name, request.cookies.get(cookie_name), max_age=0)
                return res
    if user is None:
        return redirect('/login', 302)
    return render_template('profile.html', nick=user.nick, fio=user.fio)


@app.route("/add_tests", methods=['POST', 'GET'])
def add_tests():
    if request.method == "POST":
        classs = request.form['classSelect']
        print(classs, request.form)
        unit = request.form['unit']
        types = request.form['type']
        print(classs, unit, types)
        times = str(time.time()).split(".")
        link = times[0]+times[1]
        print(link)
        new_test = Test(classs=classs, unit=unit, type=types, link=link)
        db.session.add(new_test)
        db.session.commit()
        return redirect('/tests', 302)
    else:
        return render_template("add_tests.html")

@app.route("/tests")
def tests():
    reqinnone = 0
    user = None
    for cookie_name in request.cookies:
        user_obj = User.query.filter_by(nick=cookie_name).first()
        if user_obj:
            secret_key = bs64.b64encode(str.encode(user_obj.nick + user_obj.password[:2])).decode("utf-8")
            if request.cookies.get(cookie_name) == secret_key:
                user = user_obj
                break
            elif request.cookies.get(cookie_name) is not None:
                res = make_response(redirect('hello', 302))
                res.set_cookie(cookie_name, request.cookies.get(cookie_name), max_age=0)
                return res
    if user is None:
        return redirect('/login', 302)

    tests = Test.query.all()
    return render_template('tests.html', tests=tests)

@app.route("/words/json")
def get_words_json():
    words = Word.query.all()
    data = {}
    for w in words:
        if w.classs not in data:
            data[w.classs] = {}
        if w.unit not in data[w.classs]:
            data[w.classs][w.unit] = []
        data[w.classs][w.unit].append([w.word, w.perevod])
    return jsonify(data)

@app.route("/tests/<id>", methods=['GET', 'POST'])
def test_id(id):
    user = None
    for cookie_name in request.cookies:
        user_obj = User.query.filter_by(nick=cookie_name).first()
        if user_obj:
            secret_key = bs64.b64encode(str.encode(user_obj.nick + user_obj.password[:2])).decode("utf-8")
            if request.cookies.get(cookie_name) == secret_key:
                user = user_obj
                break
            elif request.cookies.get(cookie_name) is not None:
                res = make_response(redirect('hello', 302))
                res.set_cookie(cookie_name, request.cookies.get(cookie_name), max_age=0)
                return res
    if user is None:
        return redirect('/login', 302)

    test = Test.query.filter_by(link=id).first()
    if not test:
        return "Test not found", 404

    classs = test.classs
    unit = test.unit
    test_type = test.type

    words = Word.query.filter_by(classs=classs, unit=unit).all()

    if request.method == 'POST':
        score = 0
        total = len(words)
        if test_type == 'dictation':
            for idx, word_obj in enumerate(words):
                answer = request.form.get(f'answer{idx}', '').strip().lower()
                if answer == word_obj.perevod.lower():
                    score += 1
        elif test_type == 'true_or_false':
            for idx, word_obj in enumerate(words):
                answer = request.form.get(f'answer{idx}', '').strip().lower()
                correct = 'true' if word_obj.perevod.lower() == 'true' else 'false'
                if answer == correct:
                    score += 1
        elif test_type == 'add_letter':
            for idx, word_obj in enumerate(words):
                answer = request.form.get(f'answer{idx}', '').strip().lower()
                if answer == word_obj.perevod.lower():
                    score += 1
        else:
            return "Unknown test type", 400

        return render_template('test_result.html', score=score, total=total, test_type=test_type)

    if test_type == 'dictation':
        return render_template('test_dictation.html', words=words, test_id=id)
    elif test_type == 'true_or_false':
        return render_template('test_true_or_false.html', words=words, test_id=id)
    elif test_type == 'add_letter':
        return render_template('test_add_letter.html', words=words, test_id=id)
    else:
        return "Unknown test type", 400

@app.route("/edit_profile")
def edit_profile():
    user = None
    for cookie_name in request.cookies:
        user_obj = User.query.filter_by(nick=cookie_name).first()
        if user_obj:
            secret_key = bs64.b64encode(str.encode(user_obj.nick + user_obj.password[:2])).decode("utf-8")
            if request.cookies.get(cookie_name) == secret_key:
                user = user_obj
                break
            elif request.cookies.get(cookie_name) is not None:
                res = make_response(redirect('hello', 302))
                res.set_cookie(cookie_name, request.cookies.get(cookie_name), max_age=0)
                return res
    if user is None:
        return redirect('/login', 302)
    return render_template('edit_profile.html', nick=user.nick, fio=user.fio)

@app.route("/save_profile", methods=["POST"])
def save_profile():
    fio = request.form.get("fio")
    nick = request.form.get("nick")

    user = User.query.filter_by(nick=nick).first()
    if user:
        user.fio = fio
        db.session.commit()

    return redirect("/profile")

@app.route("/add_words", methods=['POST', 'GET'])
def add_words():
    if request.method == "POST":
        class_val = request.form.get('classSelect')
        unit_val = request.form.get('unitSelect')
        module_val = request.form.get('moduleSelect')  # Changed from 'module'

        if class_val == 'add_new_class':
            classs = request.form.get('newClassInput', '').strip()
        else:
            classs = class_val

        if unit_val == 'add_new_unit':
            unit = request.form.get('newUnitInput', '').strip()
        else:
            unit = unit_val

        if module_val == 'add_new_module':
            module = request.form.get('newModuleInput', '').strip()
        else:
            module = module_val

        # Ensure classs, unit, and module are not None and provide defaults if necessary
        classs = classs if classs is not None else ""
        unit = unit if unit is not None else ""
        module = module if module is not None else ""

        words = []
        perevods = []

        for key, value in request.form.items():
            if key.startswith("word"):
                words.append(value)
            elif key.startswith("perevod"):
                perevods.append(value)

        for word, perevod in zip(words, perevods):
            new_word = Word(word=word, perevod=perevod, classs=classs, unit=unit, module=module)
            db.session.add(new_word)
        db.session.commit()
        return redirect('/words', 302)

    # GET method: query existing classes
    classes = [str(i) for i in range(1, 12)]
    return render_template("add_words.html", classes=classes)

@app.route("/get_units_for_class")
def get_units_for_class():
    class_name = request.args.get('class_name')
    if not class_name or class_name == 'add_new_class': # Handle placeholder
        return jsonify([])
    units = db.session.query(Word.unit).filter(Word.classs == class_name).distinct().all()
    # Ensure units are actual strings and not None, then sort
    units_list = sorted([u[0] for u in units if u[0]]) 
    return jsonify(units_list)

@app.route("/get_modules_for_unit")
def get_modules_for_unit():
    class_name = request.args.get('class_name')
    unit_name = request.args.get('unit_name')
    if not class_name or not unit_name or class_name == 'add_new_class' or unit_name == 'add_new_unit': # Handle placeholders
        return jsonify([])
    modules = db.session.query(Word.module).filter(Word.classs == class_name, Word.unit == unit_name).distinct().all()
    # Ensure modules are actual strings and not None, then sort
    modules_list = sorted([m[0] for m in modules if m[0]])
    return jsonify(modules_list)

@app.route('/words')
def words():
    words = Word.query.order_by(Word.classs).all()
    items = {}

    # Build items by class, unit, module
    for w in words:
        if w.classs not in items:
            items[w.classs] = {}
        if w.unit not in items[w.classs]:
            items[w.classs][w.unit] = {}
        if w.module not in items[w.classs][w.unit]:
            items[w.classs][w.unit][w.module] = []
        items[w.classs][w.unit][w.module].append([w.word, w.perevod])

    return render_template("words.html", items=items)

@app.route('/edit_word/<word>', methods=['GET', 'POST'])
def edit_word(word):
    classs = request.args.get('class')
    unit = request.args.get('unit')
    module = request.args.get('module')
    perevod = request.args.get('perevod')
    
    # Find the word in the database
    word_obj = Word.query.filter_by(word=word, classs=classs, unit=unit, module=module).first()
    
    if not word_obj:
        return "Word not found", 404
    
    if request.method == 'POST':
        # Update the word
        word_obj.word = request.form.get('word')
        word_obj.perevod = request.form.get('perevod')
        db.session.commit()
        return redirect('/words')
    
    # Get all classes for the dropdown
    all_classes = [str(i) for i in range(1, 12)]
    
    # GET request - render the edit form
    return render_template('edit_word.html', word=word_obj, classs=classs, unit=unit, module=module, all_classes=all_classes)

@app.route('/delete_word/<word>', methods=['POST'])
def delete_word(word):
    # Get the data from the JSON request
    data = request.get_json()
    classs = data.get('class')
    unit = data.get('unit')
    module = data.get('module')
    
    # Find the word in the database
    word_obj = Word.query.filter_by(word=word, classs=classs, unit=unit, module=module).first()
    
    if not word_obj:
        return jsonify({'success': False, 'error': 'Word not found'}), 404
    
    # Delete the word
    db.session.delete(word_obj)
    db.session.commit()
    
    return jsonify({'success': True})

@app.route('/login', methods=['POST', 'GET'])
def login():
    error = None
    if request.method == "POST":
        username = request.form['username']
        password = request.form['password']

        user = User.query.filter_by(nick=username, password=password).first()
        if user:
            secret_key = bs64.b64encode(str.encode(username + password[:2])).decode("utf-8")
            resp = make_response(redirect('hello', 302))
            resp.set_cookie(username, secret_key, 60*60*24*15)
            return resp
        else:
            error = 'Invalid username/password'

    return render_template('login.html', error=error)

@app.route("/logout")
def logout():
    username = None
    for cookie_name in request.cookies:
        if User.query.filter_by(nick=cookie_name).first():
            username = cookie_name
            break
    if username:
        res = make_response(redirect('/login', 302))
        res.set_cookie(username, '', expires=0)
        return res
    else:
        return redirect('/login', 302)

@app.route('/registration', methods=['POST', 'GET'])
def registration():
    error = None
    if request.method == 'POST':
        fio = request.form["fio"]
        username = request.form['username']
        password = request.form['password']

        secret_key = bs64.b64encode(str.encode(username + password[:2])).decode("utf-8")

        max_id = db.session.query(db.func.max(User.id)).scalar()
        if max_id is None:
            max_id = 0
        else:
            max_id += 1

        existing_user = User.query.filter_by(nick=username).first()

        fio_in_mass = fio.split(' ')
        if len(fio_in_mass) == 3:
            if existing_user is None:
                new_user = User(fio=fio, nick=username, password=password, secret_key=secret_key, teacher='no', id=max_id)
                db.session.add(new_user)
                db.session.commit()
                resp = make_response(redirect('hello', 302))
                resp.set_cookie(username, secret_key, 60*60*24*15)
                return resp
            else:
                error = "–í—ã–±—Ä–∞–Ω–Ω—ã–π –≤–∞–º–∏ Username —É–∂–µ –∑–∞–Ω—è—Ç"
        else:
            error = "–§–ò–û –¥–æ–ª–∂–Ω–æ —Å–æ—Å—Ç–æ—è—Ç—å –∏–∑ 3 —Å–ª–æ–≤"
    else:
        error = None

    return render_template('registration.html', error=error)

@app.route("/hello")
def hello():
    user = None
    for cookie_name in request.cookies:
        user_obj = User.query.filter_by(nick=cookie_name).first()
        if user_obj:
            secret_key = bs64.b64encode(str.encode(user_obj.nick + user_obj.password[:2])).decode("utf-8")
            if request.cookies.get(cookie_name) == secret_key:
                user = user_obj
                break
            elif request.cookies.get(cookie_name) is not None:
                res = make_response(redirect('hello', 302))
                res.set_cookie(cookie_name, request.cookies.get(cookie_name), max_age=0)
                return res
    if user is None:
        return redirect('/login', 302)

    fio_parts = user.fio.split(' ')
    try:
        letters = fio_parts[0][:1] + fio_parts[1][:1]
    except:
        letters = user.fio[0] + user.fio[1]

    return render_template('hello.html', username=user.nick, letters=letters)

@app.route("/about")
def about():
    return render_template("about.html")

# Old delete_word route removed in favor of the new route with more precise word identification

@app.route("/edit_word")
def edit_word_form():
    # Get word details from URL parameters
    word = request.args.get("word")
    perevod = request.args.get("perevod")
    classs = request.args.get("class")
    unit = request.args.get("unit")
    
    # Find the word by its attributes
    word_to_edit = db.session.query(Word).filter_by(
        word=word,
        perevod=perevod,
        classs=classs,
        unit=unit
    ).first()
    
    if not word_to_edit:
        flash("Word not found!", "error")
        return redirect(url_for('words'))

    all_classes = [str(i) for i in range(1, 12)] # Assuming classes are 1-11
    # Units and modules will be loaded dynamically by JS
    # The word_to_edit object contains current class, unit, module for pre-selection
    return render_template("edit_word.html", word=word_to_edit, all_classes=all_classes)

@app.route("/update_word", methods=["POST"])
def update_word():
    word_id = request.form.get("word_id")
    word_to_update = Word.query.get(word_id)

    if not word_to_update:
        flash("Word not found for update!", "error")
        return redirect(url_for('words'))

    # Get new values, handling 'add_new_...' for unit and module
    new_class_val = request.form.get('classSelect')
    new_unit_val = request.form.get('unitSelect')
    new_module_val = request.form.get('moduleSelect')

    word_to_update.classs = new_class_val # Assuming classSelect directly provides the class

    if new_unit_val == 'add_new_unit':
        word_to_update.unit = request.form.get('newUnitInput')
    else:
        word_to_update.unit = new_unit_val

    if new_module_val == 'add_new_module':
        word_to_update.module = request.form.get('newModuleInput')
    else:
        word_to_update.module = new_module_val
    
    word_to_update.word = request.form.get("word")
    word_to_update.perevod = request.form.get("perevod")

    try:
        db.session.commit()
        flash("Word updated successfully!", "success")
    except Exception as e:
        db.session.rollback()
        flash(f"Error updating word: {str(e)}", "error")

    return redirect(url_for('words', classs=word_to_update.classs, unit=word_to_update.unit, module=word_to_update.module))

@app.route("/add_unit_to_class")
def add_unit_to_class_form():
    class_name = request.args.get("class")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å —é–Ω–∏—Ç –≤ {class_name}</h2>
    <form action="/save_unit" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="text" name="unit" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ —é–Ω–∏—Ç–∞" required />
        <button type="submit">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
    </form>
    """
@app.route("/add_module_to_unit")
def add_module_to_unit_form():
    class_name = request.args.get("class")
    unit_name = request.args.get("unit")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å –º–æ–¥—É–ª—å –≤ {unit_name} ({class_name})</h2>
    <form action="/save_module" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="hidden" name="unit" value="{unit_name}" />
        <input type="text" name="module" placeholder="–ù–∞–∑–≤–∞–Ω–∏–µ –º–æ–¥—É–ª—è" required />
        <button type="submit">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
    </form>
    """

@app.route("/save_module", methods=["POST"])
def save_module():
    class_name = request.form.get("class")
    unit_name = request.form.get("unit")
    module_name = request.form.get("module")

    dummy_word = Word(word="dummy", perevod="–∑–∞–≥–ª—É—à–∫–∞", classs=class_name, unit=unit_name, module=module_name)
    db.session.add(dummy_word)
    db.session.commit()

    return redirect("/words")

@app.route("/add_word_to_module")
def add_word_to_module_form():
    class_name = request.args.get("class")
    unit_name = request.args.get("unit")
    module_name = request.args.get("module")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–æ –≤ –º–æ–¥—É–ª—å: {module_name} ({unit_name}, {class_name})</h2>
    <form action="/add_word" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="hidden" name="unit" value="{unit_name}" />
        <input type="hidden" name="module" value="{module_name}" />
        <label>–°–ª–æ–≤–æ:</label><br/>
        <input type="text" name="word" required /><br/>
        <label>–ü–µ—Ä–µ–≤–æ–¥:</label><br/>
        <input type="text" name="perevod" required /><br/>
        <button type="submit">–î–æ–±–∞–≤–∏—Ç—å</button>
    </form>
    """

@app.route("/save_unit", methods=["POST"])
def save_unit():
    class_name = request.form.get("class")
    unit_name = request.form.get("unit")

    # –ü—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º –ª—é–±–æ–µ —Å–ª–æ–≤–æ, —á—Ç–æ–±—ã —Å–æ–∑–¥–∞—Ç—å —Å–≤—è–∑—å –∫–ª–∞—Å—Å–∞ –∏ –º–æ–¥—É–ª—è
    dummy_word = Word(word="dummy", perevod="–∑–∞–≥–ª—É—à–∫–∞", classs=class_name, unit=unit_name)
    db.session.add(dummy_word)
    db.session.commit()

    return redirect("/words")

@app.route("/add_word_to_unit")
def add_word_to_unit_form():
    class_name = request.args.get("class")
    unit_name = request.args.get("unit")
    return f"""
    <h2>–î–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–æ –≤ {unit_name} ({class_name})</h2>
    <form action="/add_word" method="POST">
        <input type="hidden" name="class" value="{class_name}" />
        <input type="hidden" name="unit" value="{unit_name}" />
        <label>–°–ª–æ–≤–æ:</label><br/>
        <input type="text" name="word" required /><br/>
        <label>–ü–µ—Ä–µ–≤–æ–¥:</label><br/>
        <input type="text" name="perevod" required /><br/>
        <button type="submit">–î–æ–±–∞–≤–∏—Ç—å</button>
    </form>
    """

@app.route("/add_word", methods=["POST"])
def add_word():
    class_name = request.form.get("class")
    unit_name = request.form.get("unit")
    module_name = request.form.get("module")
    word = request.form.get("word")
    perevod = request.form.get("perevod")

    # Validate that all required fields are filled out
    if not class_name or not unit_name or not module_name:
        flash("–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å–ª–æ–≤–æ: –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–∞–ø–æ–ª–Ω–∏—Ç—å –∫–ª–∞—Å—Å, —é–Ω–∏—Ç –∏ –º–æ–¥—É–ª—å", "error")
        return redirect("/words")

    new_word = Word(word=word, perevod=perevod, classs=class_name, unit=unit_name, module=module_name)
    db.session.add(new_word)
    db.session.commit()

    return redirect("/words")



if __name__ == "__main__":
    with app.app_context():
        db.create_all()

start.sh (/home/amir/Documents/Info/Duckly/start.sh):
docker build -t duckly-app .
docker rm -f duckly-container || true
docker run -d \
  --name duckly-container \
  -p 1800:1800 \
  # Mount the local ./instance directory to /app/instance in the container
  # $(pwd) resolves to the current working directory (Linux/macOS)
  -v $(pwd)/instance:/app/instance \
  # –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–µ—Å—Å–∏–π
  -v $(pwd)/flask_session:/app/flask_session \
  # IMPORTANT: Change this SECRET_KEY for production environments!
  -e SECRET_KEY='your-development-secret-key-here' \
  duckly-app

static (/home/amir/Documents/Info/Duckly/static):


templates (/home/amir/Documents/Info/Duckly/templates):


test_progress_functionality.py (/home/amir/Documents/Info/Duckly/test_progress_functionality.py):
#!/usr/bin/env python3
"""
–¢–µ—Å—Ç–æ–≤—ã–π —Å–∫—Ä–∏–ø—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
"""

import requests
import json

def test_progress_api():
    """–¢–µ—Å—Ç–∏—Ä—É–µ—Ç API —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞"""
    
    base_url = "http://localhost:1800"
    
    # –¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
    test_id = 1  # –ó–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ —Ä–µ–∞–ª—å–Ω—ã–π ID —Ç–µ—Å—Ç–∞
    
    # –î–∞–Ω–Ω—ã–µ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è
    test_data = {
        "answers": [
            {
                "test_word_id": 1,
                "user_answer": "hello"
            },
            {
                "test_word_id": 2,
                "user_answer": "world"
            }
        ]
    }
    
    print("–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ API —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –∏ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞...")
    
    # –¢–µ—Å—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
    print(f"\n1. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –¥–ª—è —Ç–µ—Å—Ç–∞ {test_id}")
    try:
        response = requests.post(
            f"{base_url}/api/test/{test_id}/save_progress",
            json=test_data,
            headers={'Content-Type': 'application/json'}
        )
        print(f"–°—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–∞: {response.status_code}")
        print(f"–û—Ç–≤–µ—Ç: {response.text}")
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏: {e}")
    
    # –¢–µ—Å—Ç –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
    print(f"\n2. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≥—Ä—É–∑–∫–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ –¥–ª—è —Ç–µ—Å—Ç–∞ {test_id}")
    try:
        response = requests.get(f"{base_url}/api/test/{test_id}/load_progress")
        print(f"–°—Ç–∞—Ç—É—Å –æ—Ç–≤–µ—Ç–∞: {response.status_code}")
        print(f"–û—Ç–≤–µ—Ç: {response.text}")
    except Exception as e:
        print(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ: {e}")

if __name__ == "__main__":
    print("–ó–∞–ø—É—Å–∫ —Ç–µ—Å—Ç–æ–≤ —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ –ø—Ä–æ–≥—Ä–µ—Å—Å–∞...")
    test_progress_api()
    print("\n–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!")

test.py (/home/amir/Documents/Info/Duckly/test.py):
from site_1 import app, db, Word, User, Test, TestWord
from werkzeug.security import generate_password_hash
import random
import time
import json
import string

def create_word_with_missing_letters(word):
    """–°–æ–∑–¥–∞–µ—Ç —Å–ª–æ–≤–æ —Å –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–º–∏ –±—É–∫–≤–∞–º–∏ –¥–ª—è —Ç–µ—Å—Ç–∞ 'add_letter'"""
    if len(word) <= 2:
        return word[0] + '_' * (len(word) - 1)
    
    # –£–±–∏—Ä–∞–µ–º 1-2 –±—É–∫–≤—ã —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º
    word_list = list(word.lower())
    num_gaps = min(2, max(1, len(word) // 3))
    
    # –í—ã–±–∏—Ä–∞–µ–º —Å–ª—É—á–∞–π–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ –¥–ª—è –ø—Ä–æ–ø—É—Å–∫–æ–≤ (–Ω–µ –ø–µ—Ä–≤—É—é –∏ –Ω–µ –ø–æ—Å–ª–µ–¥–Ω—é—é)
    available_positions = list(range(1, len(word) - 1)) if len(word) > 2 else [0]
    gap_positions = random.sample(available_positions, min(num_gaps, len(available_positions)))
    
    for pos in gap_positions:
        word_list[pos] = '_'
    
    return ''.join(word_list)

def create_multiple_choice_options(correct_word, all_words):
    """–°–æ–∑–¥–∞–µ—Ç –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤ –¥–ª—è –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞"""
    # –ë–µ—Ä–µ–º 3 —Å–ª—É—á–∞–π–Ω—ã—Ö –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –≤–∞—Ä–∏–∞–Ω—Ç–∞
    other_words = [w.word for w in all_words if w.word.lower() != correct_word.lower()]
    wrong_options = random.sample(other_words, min(3, len(other_words)))
    
    # –î–æ–±–∞–≤–ª—è–µ–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –æ—Ç–≤–µ—Ç
    all_options = wrong_options + [correct_word]
    random.shuffle(all_options)
    
    return json.dumps(all_options)

def create_wrong_translation(correct_translation, all_words):
    """–°–æ–∑–¥–∞–µ—Ç –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –¥–ª—è —Ç–µ—Å—Ç–∞ 'true_false'"""
    # –ë–µ—Ä–µ–º —Å–ª—É—á–∞–π–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥ –¥—Ä—É–≥–æ–≥–æ —Å–ª–æ–≤–∞
    other_translations = [w.perevod for w in all_words if w.perevod != correct_translation]
    if other_translations:
        return random.choice(other_translations)
    return correct_translation

def generate_test_link():
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—É—é —Å—Å—ã–ª–∫—É –¥–ª—è —Ç–µ—Å—Ç–∞"""
    while True:
        link = ''.join(random.choices(string.ascii_letters + string.digits, k=10))
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–∞–∫–∞—è —Å—Å—ã–ª–∫–∞ –µ—â–µ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
        if not Test.query.filter_by(link=link).first():
            return link

def generate_test_data():
    # –°–ø–∏—Å–æ–∫ –∫–ª–∞—Å—Å–æ–≤ (1-11)
    classes = [str(i) for i in range(1, 12)]
    
    # –°–ø–∏—Å–æ–∫ —é–Ω–∏—Ç–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–ª–∞—Å—Å–∞
    units = {
        '1': ['Unit 1: Greetings', 'Unit 2: Numbers', 'Unit 3: Colors'],
        '2': ['Unit 1: Family', 'Unit 2: Animals', 'Unit 3: Food'],
        '3': ['Unit 1: School', 'Unit 2: Weather', 'Unit 3: Clothes'],
        '4': ['Unit 1: Hobbies', 'Unit 2: Sports', 'Unit 3: Music'],
        '5': ['Unit 1: Travel', 'Unit 2: City', 'Unit 3: Nature'],
        '6': ['Unit 1: Technology', 'Unit 2: Science', 'Unit 3: Space'],
        '7': ['Unit 1: History', 'Unit 2: Geography', 'Unit 3: Culture'],
        '8': ['Unit 1: Literature', 'Unit 2: Art', 'Unit 3: Media'],
        '9': ['Unit 1: Business', 'Unit 2: Economy', 'Unit 3: Politics'],
        '10': ['Unit 1: Medicine', 'Unit 2: Law', 'Unit 3: Education'],
        '11': ['Unit 1: Philosophy', 'Unit 2: Psychology', 'Unit 3: Sociology']
    }
    
    # –°–ø–∏—Å–æ–∫ –º–æ–¥—É–ª–µ–π –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —é–Ω–∏—Ç–∞
    modules = {
        'Unit 1: Greetings': ['Basic Greetings', 'Formal Greetings', 'Informal Greetings'],
        'Unit 2: Numbers': ['Cardinal Numbers', 'Ordinal Numbers', 'Fractions'],
        'Unit 3: Colors': ['Basic Colors', 'Shades', 'Color Combinations'],
        'Unit 1: Family': ['Family Members', 'Relationships', 'Family Activities'],
        'Unit 2: Animals': ['Pets', 'Wild Animals', 'Farm Animals'],
        'Unit 3: Food': ['Fruits', 'Vegetables', 'Meals'],
        'Unit 1: School': ['School Subjects', 'School Supplies', 'School Activities'],
        'Unit 2: Weather': ['Weather Conditions', 'Seasons', 'Weather Forecast'],
        'Unit 3: Clothes': ['Basic Clothes', 'Accessories', 'Fashion'],
        'Unit 1: Hobbies': ['Sports', 'Arts', 'Collecting'],
        'Unit 2: Sports': ['Team Sports', 'Individual Sports', 'Sports Equipment'],
        'Unit 3: Music': ['Musical Instruments', 'Music Genres', 'Music Terms'],
        'Unit 1: Travel': ['Transportation', 'Accommodation', 'Tourism'],
        'Unit 2: City': ['City Places', 'City Services', 'City Life'],
        'Unit 3: Nature': ['Landscapes', 'Plants', 'Natural Phenomena'],
        'Unit 1: Technology': ['Computers', 'Internet', 'Gadgets'],
        'Unit 2: Science': ['Physics', 'Chemistry', 'Biology'],
        'Unit 3: Space': ['Solar System', 'Space Exploration', 'Astronomy'],
        'Unit 1: History': ['Ancient History', 'Modern History', 'Historical Events'],
        'Unit 2: Geography': ['Countries', 'Capitals', 'Landmarks'],
        'Unit 3: Culture': ['Traditions', 'Customs', 'Festivals'],
        'Unit 1: Literature': ['Genres', 'Authors', 'Literary Terms'],
        'Unit 2: Art': ['Art Forms', 'Artists', 'Art History'],
        'Unit 3: Media': ['News', 'Entertainment', 'Social Media'],
        'Unit 1: Business': ['Companies', 'Marketing', 'Management'],
        'Unit 2: Economy': ['Economics', 'Finance', 'Trade'],
        'Unit 3: Politics': ['Government', 'Elections', 'International Relations'],
        'Unit 1: Medicine': ['Diseases', 'Treatment', 'Healthcare'],
        'Unit 2: Law': ['Legal System', 'Rights', 'Crimes'],
        'Unit 3: Education': ['Education System', 'Learning', 'Teaching'],
        'Unit 1: Philosophy': ['Philosophical Concepts', 'Philosophers', 'Ethics'],
        'Unit 2: Psychology': ['Mental Processes', 'Behavior', 'Personality'],
        'Unit 3: Sociology': ['Society', 'Social Groups', 'Social Issues']
    }
    
    # –°–ª–æ–≤–∞—Ä—å —Å —Ç–µ—Å—Ç–æ–≤—ã–º–∏ —Å–ª–æ–≤–∞–º–∏ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –º–æ–¥—É–ª—è
    test_words = {
        'Basic Greetings': [
            ('hello', '–ø—Ä–∏–≤–µ—Ç'),
            ('goodbye', '–¥–æ —Å–≤–∏–¥–∞–Ω–∏—è'),
            ('good morning', '–¥–æ–±—Ä–æ–µ —É—Ç—Ä–æ'),
            ('good afternoon', '–¥–æ–±—Ä—ã–π –¥–µ–Ω—å'),
            ('good evening', '–¥–æ–±—Ä—ã–π –≤–µ—á–µ—Ä'),
            ('how are you', '–∫–∞–∫ –¥–µ–ª–∞'),
            ('fine, thank you', '—Ö–æ—Ä–æ—à–æ, —Å–ø–∞—Å–∏–±–æ')
        ],
        'Formal Greetings': [
            ('pleased to meet you', '—Ä–∞–¥ –ø–æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è'),
            ('how do you do', '–∑–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ (—Ñ–æ—Ä–º–∞–ª—å–Ω–æ)'),
            ('it\'s a pleasure', '—ç—Ç–æ —É–¥–æ–≤–æ–ª—å—Å—Ç–≤–∏–µ'),
            ('may I introduce', '–ø–æ–∑–≤–æ–ª—å—Ç–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç—å'),
            ('farewell', '–ø—Ä–æ—â–∞–π—Ç–µ')
        ],
        'Informal Greetings': [
            ('hi', '–ø—Ä–∏–≤–µ—Ç'),
            ('bye', '–ø–æ–∫–∞'),
            ('see ya', '—É–≤–∏–¥–∏–º—Å—è'),
            ('what\'s up', '–∫–∞–∫ –¥–µ–ª–∞ (—Å–ª.)'),
            ('long time no see', '–¥–∞–≤–Ω–æ –Ω–µ –≤–∏–¥–µ–ª–∏—Å—å')
        ],
        'Cardinal Numbers': [
            ('one', '–æ–¥–∏–Ω'), ('two', '–¥–≤–∞'), ('three', '—Ç—Ä–∏'), ('four', '—á–µ—Ç—ã—Ä–µ'),
            ('five', '–ø—è—Ç—å'), ('ten', '–¥–µ—Å—è—Ç—å'), ('twenty', '–¥–≤–∞–¥—Ü–∞—Ç—å'), ('one hundred', '—Å—Ç–æ')
        ],
        'Ordinal Numbers': [
            ('first', '–ø–µ—Ä–≤—ã–π'), ('second', '–≤—Ç–æ—Ä–æ–π'), ('third', '—Ç—Ä–µ—Ç–∏–π'),
            ('fourth', '—á–µ—Ç–≤–µ—Ä—Ç—ã–π'), ('fifth', '–ø—è—Ç—ã–π'), ('tenth', '–¥–µ—Å—è—Ç—ã–π'),
            ('twentieth', '–¥–≤–∞–¥—Ü–∞—Ç—ã–π')
        ],
        'Fractions': [
            ('half', '–ø–æ–ª–æ–≤–∏–Ω–∞'), ('quarter', '—á–µ—Ç–≤–µ—Ä—Ç—å'), ('one third', '–æ–¥–Ω–∞ —Ç—Ä–µ—Ç—å'),
            ('two thirds', '–¥–≤–µ —Ç—Ä–µ—Ç–∏'), ('three quarters', '—Ç—Ä–∏ —á–µ—Ç–≤–µ—Ä—Ç–∏')
        ],
        'Basic Colors': [
            ('red', '–∫—Ä–∞—Å–Ω—ã–π'), ('blue', '—Å–∏–Ω–∏–π'), ('green', '–∑–µ–ª–µ–Ω—ã–π'),
            ('yellow', '–∂–µ–ª—Ç—ã–π'), ('black', '—á–µ—Ä–Ω—ã–π'), ('white', '–±–µ–ª—ã–π'),
            ('orange', '–æ—Ä–∞–Ω–∂–µ–≤—ã–π'), ('purple', '—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π')
        ],
        'Shades': [
            ('light blue', '—Å–≤–µ—Ç–ª–æ-—Å–∏–Ω–∏–π'), ('dark green', '—Ç–µ–º–Ω–æ-–∑–µ–ª–µ–Ω—ã–π'),
            ('bright red', '—è—Ä–∫–æ-–∫—Ä–∞—Å–Ω—ã–π'), ('pale yellow', '–±–ª–µ–¥–Ω–æ-–∂–µ–ª—Ç—ã–π'),
            ('deep purple', '—Ç–µ–º–Ω–æ-—Ñ–∏–æ–ª–µ—Ç–æ–≤—ã–π'), ('navy blue', '—Ç–µ–º–Ω–æ-—Å–∏–Ω–∏–π')
        ],
        'Color Combinations': [
            ('red and blue', '–∫—Ä–∞—Å–Ω—ã–π –∏ —Å–∏–Ω–∏–π'), ('black and white', '—á–µ—Ä–Ω—ã–π –∏ –±–µ–ª—ã–π'),
            ('green and yellow', '–∑–µ–ª–µ–Ω—ã–π –∏ –∂–µ–ª—Ç—ã–π'), ('blue and white', '—Å–∏–Ω–∏–π –∏ –±–µ–ª—ã–π'),
            ('red and green', '–∫—Ä–∞—Å–Ω—ã–π –∏ –∑–µ–ª–µ–Ω—ã–π'), ('orange and black', '–æ—Ä–∞–Ω–∂–µ–≤—ã–π –∏ —á–µ—Ä–Ω—ã–π')
        ],
        'Family Members': [
            ('mother', '–º–∞—Ç—å'), ('father', '–æ—Ç–µ—Ü'), ('sister', '—Å–µ—Å—Ç—Ä–∞'),
            ('brother', '–±—Ä–∞—Ç'), ('grandmother', '–±–∞–±—É—à–∫–∞'), ('grandfather', '–¥–µ–¥—É—à–∫–∞'),
            ('aunt', '—Ç–µ—Ç—è'), ('uncle', '–¥—è–¥—è'), ('cousin', '–¥–≤–æ—é—Ä–æ–¥–Ω—ã–π –±—Ä–∞—Ç/—Å–µ—Å—Ç—Ä–∞')
        ],
        'Relationships': [
            ('family', '—Å–µ–º—å—è'), ('parents', '—Ä–æ–¥–∏—Ç–µ–ª–∏'), ('children', '–¥–µ—Ç–∏'),
            ('relatives', '—Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏'), ('spouse', '—Å—É–ø—Ä—É–≥/—Å—É–ø—Ä—É–≥–∞'),
            ('niece', '–ø–ª–µ–º—è–Ω–Ω–∏—Ü–∞'), ('nephew', '–ø–ª–µ–º—è–Ω–Ω–∏–∫')
        ],
        'Family Activities': [
            ('cook dinner', '–≥–æ—Ç–æ–≤–∏—Ç—å —É–∂–∏–Ω'), ('clean the house', '—É–±–∏—Ä–∞—Ç—å –¥–æ–º'),
            ('play games', '–∏–≥—Ä–∞—Ç—å –≤ –∏–≥—Ä—ã'), ('read books', '—á–∏—Ç–∞—Ç—å –∫–Ω–∏–≥–∏'),
            ('watch TV', '—Å–º–æ—Ç—Ä–µ—Ç—å —Ç–µ–ª–µ–≤–∏–∑–æ—Ä'), ('go for a walk', '–≥—É–ª—è—Ç—å'),
            ('visit relatives', '–ø–æ—Å–µ—â–∞—Ç—å —Ä–æ–¥—Å—Ç–≤–µ–Ω–Ω–∏–∫–æ–≤')
        ],
        'Pets': [
            ('dog', '—Å–æ–±–∞–∫–∞'), ('cat', '–∫–æ—à–∫–∞'), ('bird', '–ø—Ç–∏—Ü–∞'),
            ('fish', '—Ä—ã–±–∞'), ('hamster', '—Ö–æ–º—è–∫'), ('guinea pig', '–º–æ—Ä—Å–∫–∞—è —Å–≤–∏–Ω–∫–∞'),
            ('rabbit', '–∫—Ä–æ–ª–∏–∫')
        ],
        'Wild Animals': [
            ('lion', '–ª–µ–≤'), ('tiger', '—Ç–∏–≥—Ä'), ('elephant', '—Å–ª–æ–Ω'),
            ('monkey', '–æ–±–µ–∑—å—è–Ω–∞'), ('giraffe', '–∂–∏—Ä–∞—Ñ'), ('zebra', '–∑–µ–±—Ä–∞'),
            ('bear', '–º–µ–¥–≤–µ–¥—å'), ('wolf', '–≤–æ–ª–∫')
        ],
        'Farm Animals': [
            ('cow', '–∫–æ—Ä–æ–≤–∞'), ('pig', '—Å–≤–∏–Ω—å—è'), ('sheep', '–æ–≤—Ü–∞'),
            ('chicken', '–∫—É—Ä–∏—Ü–∞'), ('horse', '–ª–æ—à–∞–¥—å'), ('duck', '—É—Ç–∫–∞'),
            ('goat', '–∫–æ–∑–∞')
        ],
        'Fruits': [
            ('apple', '—è–±–ª–æ–∫–æ'), ('banana', '–±–∞–Ω–∞–Ω'), ('orange', '–∞–ø–µ–ª—å—Å–∏–Ω'),
            ('grape', '–≤–∏–Ω–æ–≥—Ä–∞–¥'), ('strawberry', '–∫–ª—É–±–Ω–∏–∫–∞'), ('blueberry', '—á–µ—Ä–Ω–∏–∫–∞'),
            ('pineapple', '–∞–Ω–∞–Ω–∞—Å'), ('mango', '–º–∞–Ω–≥–æ')
        ],
        'Vegetables': [
            ('carrot', '–º–æ—Ä–∫–æ–≤—å'), ('potato', '–∫–∞—Ä—Ç–æ—Ñ–µ–ª—å'), ('tomato', '–ø–æ–º–∏–¥–æ—Ä'),
            ('cucumber', '–æ–≥—É—Ä–µ—Ü'), ('onion', '–ª—É–∫'), ('broccoli', '–±—Ä–æ–∫–∫–æ–ª–∏'),
            ('spinach', '—à–ø–∏–Ω–∞—Ç'), ('pepper', '–ø–µ—Ä–µ—Ü')
        ],
        'Meals': [
            ('breakfast', '–∑–∞–≤—Ç—Ä–∞–∫'), ('lunch', '–æ–±–µ–¥'), ('dinner', '—É–∂–∏–Ω'),
            ('snack', '–ø–µ—Ä–µ–∫—É—Å'), ('dessert', '–¥–µ—Å–µ—Ä—Ç'), ('supper', '—É–∂–∏–Ω (–ø–æ–∑–¥–Ω–∏–π)'),
            ('brunch', '–ø–æ–∑–¥–Ω–∏–π –∑–∞–≤—Ç—Ä–∞–∫')
        ],
        'School Subjects': [
            ('math', '–º–∞—Ç–µ–º–∞—Ç–∏–∫–∞'), ('science', '–Ω–∞—É–∫–∞'), ('history', '–∏—Å—Ç–æ—Ä–∏—è'),
            ('geography', '–≥–µ–æ–≥—Ä–∞—Ñ–∏—è'), ('literature', '–ª–∏—Ç–µ—Ä–∞—Ç—É—Ä–∞'),
            ('art', '–∏—Å–∫—É—Å—Å—Ç–≤–æ'), ('music', '–º—É–∑—ã–∫–∞'), ('physical education', '—Ñ–∏–∑–∫—É–ª—å—Ç—É—Ä–∞')
        ],
        'School Supplies': [
            ('pencil', '–∫–∞—Ä–∞–Ω–¥–∞—à'), ('notebook', '—Ç–µ—Ç—Ä–∞–¥—å'), ('book', '–∫–Ω–∏–≥–∞'),
            ('ruler', '–ª–∏–Ω–µ–π–∫–∞'), ('eraser', '–ª–∞—Å—Ç–∏–∫'), ('backpack', '—Ä—é–∫–∑–∞–∫'),
            ('pen', '—Ä—É—á–∫–∞'), ('scissors', '–Ω–æ–∂–Ω–∏—Ü—ã')
        ],
        'School Activities': [
            ('study', '—É—á–∏—Ç—å—Å—è'), ('read', '—á–∏—Ç–∞—Ç—å'), ('write', '–ø–∏—Å–∞—Ç—å'),
            ('draw', '—Ä–∏—Å–æ–≤–∞—Ç—å'), ('calculate', '–≤—ã—á–∏—Å–ª—è—Ç—å'), ('listen to', '—Å–ª—É—à–∞—Ç—å'),
            ('speak', '–≥–æ–≤–æ—Ä–∏—Ç—å'), ('discuss', '–æ–±—Å—É–∂–¥–∞—Ç—å')
        ],
        'Weather Conditions': [
            ('sunny', '—Å–æ–ª–Ω–µ—á–Ω–æ'), ('rainy', '–¥–æ–∂–¥–ª–∏–≤–æ'), ('cloudy', '–æ–±–ª–∞—á–Ω–æ'),
            ('windy', '–≤–µ—Ç—Ä–µ–Ω–æ'), ('snowy', '—Å–Ω–µ–∂–Ω–æ'), ('stormy', '—à—Ç–æ—Ä–º–æ–≤–æ–π'),
            ('foggy', '—Ç—É–º–∞–Ω–Ω–æ'), ('icy', '–≥–æ–ª–æ–ª–µ–¥–∏—Ü–∞')
        ],
        'Seasons': [
            ('spring', '–≤–µ—Å–Ω–∞'), ('summer', '–ª–µ—Ç–æ'), ('autumn', '–æ—Å–µ–Ω—å'),
            ('winter', '–∑–∏–º–∞'), ('season', '—Å–µ–∑–æ–Ω')
        ],
        'Weather Forecast': [
            ('temperature', '—Ç–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞'), ('forecast', '–ø—Ä–æ–≥–Ω–æ–∑ –ø–æ–≥–æ–¥—ã'),
            ('degree Celsius', '–≥—Ä–∞–¥—É—Å –¶–µ–ª—å—Å–∏—è'), ('weather report', '—Å–≤–æ–¥–∫–∞ –ø–æ–≥–æ–¥—ã'),
            ('climate change', '–∏–∑–º–µ–Ω–µ–Ω–∏–µ –∫–ª–∏–º–∞—Ç–∞'), ('humidity', '–≤–ª–∞–∂–Ω–æ—Å—Ç—å')
        ],
        'Basic Clothes': [
            ('shirt', '—Ä—É–±–∞—à–∫–∞'), ('pants', '–±—Ä—é–∫–∏'), ('dress', '–ø–ª–∞—Ç—å–µ'),
            ('jacket', '–∫—É—Ä—Ç–∫–∞'), ('shoes', '–æ–±—É–≤—å'), ('skirt', '—é–±–∫–∞'),
            ('sweater', '—Å–≤–∏—Ç–µ—Ä'), ('socks', '–Ω–æ—Å–∫–∏')
        ],
        'Accessories': [
            ('hat', '—à–ª—è–ø–∞'), ('scarf', '—à–∞—Ä—Ñ'), ('gloves', '–ø–µ—Ä—á–∞—Ç–∫–∏'),
            ('belt', '—Ä–µ–º–µ–Ω—å'), ('watch', '—á–∞—Å—ã'), ('glasses', '–æ—á–∫–∏'),
            ('jewelry', '—é–≤–µ–ª–∏—Ä–Ω—ã–µ –∏–∑–¥–µ–ª–∏—è')
        ],
        'Fashion': [
            ('style', '—Å—Ç–∏–ª—å'), ('trend', '—Ç—Ä–µ–Ω–¥'), ('design', '–¥–∏–∑–∞–π–Ω'),
            ('brand', '–±—Ä–µ–Ω–¥'), ('collection', '–∫–æ–ª–ª–µ–∫—Ü–∏—è'), ('fashionable', '–º–æ–¥–Ω—ã–π'),
            ('outfit', '–Ω–∞—Ä—è–¥')
        ],
        'Team Sports': [
            ('football', '—Ñ—É—Ç–±–æ–ª'), ('basketball', '–±–∞—Å–∫–µ—Ç–±–æ–ª'), ('volleyball', '–≤–æ–ª–µ–π–±–æ–ª'),
            ('hockey', '—Ö–æ–∫–∫–µ–π'), ('soccer', '—Ñ—É—Ç–±–æ–ª (–∞–º–µ—Ä–∏–∫–∞–Ω—Å–∫–∏–π)') # –£—Ç–æ—á–Ω–µ–Ω–∏–µ –¥–ª—è –∞–º–µ—Ä–∏–∫–∞–Ω—Å–∫–æ–≥–æ —Ñ—É—Ç–±–æ–ª–∞
        ],
        'Individual Sports': [
            ('running', '–±–µ–≥'), ('swimming', '–ø–ª–∞–≤–∞–Ω–∏–µ'), ('cycling', '–≤–µ–ª–æ—Å–ø–æ—Ä—Ç'),
            ('tennis', '—Ç–µ–Ω–Ω–∏—Å'), ('gymnastics', '–≥–∏–º–Ω–∞—Å—Ç–∏–∫–∞')
        ],
        'Sports Equipment': [
            ('ball', '–º—è—á'), ('racket', '—Ä–∞–∫–µ—Ç–∫–∞'), ('helmet', '—à–ª–µ–º'),
            ('skates', '–∫–æ–Ω—å–∫–∏'), ('uniform', '—Ñ–æ—Ä–º–∞')
        ],
        'Musical Instruments': [
            ('guitar', '–≥–∏—Ç–∞—Ä–∞'), ('piano', '–ø–∏–∞–Ω–∏–Ω–æ'), ('drums', '–±–∞—Ä–∞–±–∞–Ω—ã'),
            ('violin', '—Å–∫—Ä–∏–ø–∫–∞'), ('flute', '—Ñ–ª–µ–π—Ç–∞')
        ],
        'Music Genres': [
            ('pop', '–ø–æ–ø-–º—É–∑—ã–∫–∞'), ('rock', '—Ä–æ–∫-–º—É–∑—ã–∫–∞'), ('jazz', '–¥–∂–∞–∑'),
            ('classical music', '–∫–ª–∞—Å—Å–∏—á–µ—Å–∫–∞—è –º—É–∑—ã–∫–∞'), ('hip hop', '—Ö–∏–ø-—Ö–æ–ø')
        ],
        'Music Terms': [
            ('melody', '–º–µ–ª–æ–¥–∏—è'), ('rhythm', '—Ä–∏—Ç–º'), ('harmony', '–≥–∞—Ä–º–æ–Ω–∏—è'),
            ('composer', '–∫–æ–º–ø–æ–∑–∏—Ç–æ—Ä'), ('lyrics', '—Ç–µ–∫—Å—Ç –ø–µ—Å–Ω–∏')
        ],
        'Transportation': [
            ('car', '–º–∞—à–∏–Ω–∞'), ('bus', '–∞–≤—Ç–æ–±—É—Å'), ('train', '–ø–æ–µ–∑–¥'),
            ('plane', '—Å–∞–º–æ–ª–µ—Ç'), ('bicycle', '–≤–µ–ª–æ—Å–∏–ø–µ–¥'), ('ship', '–∫–æ—Ä–∞–±–ª—å')
        ],
        'Accommodation': [
            ('hotel', '–æ—Ç–µ–ª—å'), ('apartment', '–∫–≤–∞—Ä—Ç–∏—Ä–∞'), ('hostel', '—Ö–æ—Å—Ç–µ–ª'),
            ('tent', '–ø–∞–ª–∞—Ç–∫–∞'), ('resort', '–∫—É—Ä–æ—Ä—Ç')
        ],
        'Tourism': [
            ('travel', '–ø—É—Ç–µ—à–µ—Å—Ç–≤–∏–µ'), ('tourist', '—Ç—É—Ä–∏—Å—Ç'), ('sightseeing', '–æ—Å–º–æ—Ç—Ä –¥–æ—Å—Ç–æ–ø—Ä–∏–º–µ—á–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–µ–π'),
            ('attraction', '–¥–æ—Å—Ç–æ–ø—Ä–∏–º–µ—á–∞—Ç–µ–ª—å–Ω–æ—Å—Ç—å'), ('souvenir', '—Å—É–≤–µ–Ω–∏—Ä')
        ],
        'City Places': [
            ('park', '–ø–∞—Ä–∫'), ('museum', '–º—É–∑–µ–π'), ('library', '–±–∏–±–ª–∏–æ—Ç–µ–∫–∞'),
            ('restaurant', '—Ä–µ—Å—Ç–æ—Ä–∞–Ω'), ('supermarket', '—Å—É–ø–µ—Ä–º–∞—Ä–∫–µ—Ç')
        ],
        'City Services': [
            ('police station', '–ø–æ–ª–∏—Ü–µ–π—Å–∫–∏–π —É—á–∞—Å—Ç–æ–∫'), ('fire station', '–ø–æ–∂–∞—Ä–Ω–∞—è —Å—Ç–∞–Ω—Ü–∏—è'),
            ('hospital', '–±–æ–ª—å–Ω–∏—Ü–∞'), ('post office', '–ø–æ—á—Ç–æ–≤–æ–µ –æ—Ç–¥–µ–ª–µ–Ω–∏–µ'),
            ('bank', '–±–∞–Ω–∫')
        ],
        'City Life': [
            ('traffic', '–¥–æ—Ä–æ–∂–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ'), ('pedestrian', '–ø–µ—à–µ—Ö–æ–¥'),
            ('public transport', '–æ–±—â–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Ç—Ä–∞–Ω—Å–ø–æ—Ä—Ç'), ('commute', '–ø–æ–µ–∑–¥–∫–∞ –Ω–∞ —Ä–∞–±–æ—Ç—É'),
            ('skyscraper', '–Ω–µ–±–æ—Å–∫—Ä–µ–±')
        ],
        'Landscapes': [
            ('mountain', '–≥–æ—Ä–∞'), ('river', '—Ä–µ–∫–∞'), ('lake', '–æ–∑–µ—Ä–æ'),
            ('forest', '–ª–µ—Å'), ('desert', '–ø—É—Å—Ç—ã–Ω—è'), ('beach', '–ø–ª—è–∂')
        ],
        'Plants': [
            ('tree', '–¥–µ—Ä–µ–≤–æ'), ('flower', '—Ü–≤–µ—Ç–æ–∫'), ('grass', '—Ç—Ä–∞–≤–∞'),
            ('bush', '–∫—É—Å—Ç'), ('leaf', '–ª–∏—Å—Ç')
        ],
        'Natural Phenomena': [
            ('earthquake', '–∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏–µ'), ('volcano', '–≤—É–ª–∫–∞–Ω'), ('tsunami', '—Ü—É–Ω–∞–º–∏'),
            ('flood', '–Ω–∞–≤–æ–¥–Ω–µ–Ω–∏–µ'), ('drought', '–∑–∞—Å—É—Ö–∞'), ('lightning', '–º–æ–ª–Ω–∏—è')
        ],
        'Computers': [
            ('keyboard', '–∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞'), ('mouse', '–º—ã—à—å'), ('screen', '—ç–∫—Ä–∞–Ω'),
            ('laptop', '–Ω–æ—É—Ç–±—É–∫'), ('desktop', '–Ω–∞—Å—Ç–æ–ª—å–Ω—ã–π –∫–æ–º–ø—å—é—Ç–µ—Ä')
        ],
        'Internet': [
            ('website', '–≤–µ–±-—Å–∞–π—Ç'), ('email', '—ç–ª–µ–∫—Ç—Ä–æ–Ω–Ω–∞—è –ø–æ—á—Ç–∞'), ('search engine', '–ø–æ–∏—Å–∫–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞'),
            ('social media', '—Å–æ—Ü–∏–∞–ª—å–Ω—ã–µ —Å–µ—Ç–∏'), ('online', '–æ–Ω–ª–∞–π–Ω')
        ],
        'Gadgets': [
            ('smartphone', '—Å–º–∞—Ä—Ç—Ñ–æ–Ω'), ('tablet', '–ø–ª–∞–Ω—à–µ—Ç'), ('headphones', '–Ω–∞—É—à–Ω–∏–∫–∏'),
            ('smartwatch', '—É–º–Ω—ã–µ —á–∞—Å—ã'), ('drone', '–¥—Ä–æ–Ω')
        ],
        'Physics': [
            ('gravity', '–≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è'), ('energy', '—ç–Ω–µ—Ä–≥–∏—è'), ('force', '—Å–∏–ª–∞'),
            ('motion', '–¥–≤–∏–∂–µ–Ω–∏–µ'), ('electricity', '—ç–ª–µ–∫—Ç—Ä–∏—á–µ—Å—Ç–≤–æ')
        ],
        'Chemistry': [
            ('atom', '–∞—Ç–æ–º'), ('molecule', '–º–æ–ª–µ–∫—É–ª–∞'), ('element', '—ç–ª–µ–º–µ–Ω—Ç'),
            ('compound', '—Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ'), ('reaction', '—Ä–µ–∞–∫—Ü–∏—è')
        ],
        'Biology': [
            ('cell', '–∫–ª–µ—Ç–∫–∞'), ('gene', '–≥–µ–Ω'), ('organism', '–æ—Ä–≥–∞–Ω–∏–∑–º'),
            ('ecosystem', '—ç–∫–æ—Å–∏—Å—Ç–µ–º–∞'), ('evolution', '—ç–≤–æ–ª—é—Ü–∏—è')
        ],
        'Solar System': [
            ('sun', '—Å–æ–ª–Ω—Ü–µ'), ('moon', '–ª—É–Ω–∞'), ('planet', '–ø–ª–∞–Ω–µ—Ç–∞'),
            ('star', '–∑–≤–µ–∑–¥–∞'), ('galaxy', '–≥–∞–ª–∞–∫—Ç–∏–∫–∞')
        ],
        'Space Exploration': [
            ('astronaut', '–∫–æ—Å–º–æ–Ω–∞–≤—Ç'), ('spaceship', '–∫–æ—Å–º–∏—á–µ—Å–∫–∏–π –∫–æ—Ä–∞–±–ª—å'),
            ('satellite', '—Å–ø—É—Ç–Ω–∏–∫'), ('telescope', '—Ç–µ–ª–µ—Å–∫–æ–ø'), ('universe', '–≤—Å–µ–ª–µ–Ω–Ω–∞—è')
        ],
        'Astronomy': [
            ('constellation', '—Å–æ–∑–≤–µ–∑–¥–∏–µ'), ('observatory', '–æ–±—Å–µ—Ä–≤–∞—Ç–æ—Ä–∏—è'),
            ('celestial body', '–Ω–µ–±–µ—Å–Ω–æ–µ —Ç–µ–ª–æ'), ('comet', '–∫–æ–º–µ—Ç–∞'), ('meteor', '–º–µ—Ç–µ–æ—Ä')
        ],
        'Ancient History': [
            ('pyramid', '–ø–∏—Ä–∞–º–∏–¥–∞'), ('empire', '–∏–º–ø–µ—Ä–∏—è'), ('pharaoh', '—Ñ–∞—Ä–∞–æ–Ω'),
            ('gladiator', '–≥–ª–∞–¥–∏–∞—Ç–æ—Ä'), ('civilization', '—Ü–∏–≤–∏–ª–∏–∑–∞—Ü–∏—è')
        ],
        'Modern History': [
            ('revolution', '—Ä–µ–≤–æ–ª—é—Ü–∏—è'), ('world war', '–º–∏—Ä–æ–≤–∞—è –≤–æ–π–Ω–∞'), ('cold war', '—Ö–æ–ª–æ–¥–Ω–∞—è –≤–æ–π–Ω–∞'),
            ('globalization', '–≥–ª–æ–±–∞–ª–∏–∑–∞—Ü–∏—è'), ('digital age', '—Ü–∏—Ñ—Ä–æ–≤–∞—è —ç–ø–æ—Ö–∞')
        ],
        'Historical Events': [
            ('discovery', '–æ—Ç–∫—Ä—ã—Ç–∏–µ'), ('invention', '–∏–∑–æ–±—Ä–µ—Ç–µ–Ω–∏–µ'), ('treaty', '–¥–æ–≥–æ–≤–æ—Ä'),
            ('battle', '–±–∏—Ç–≤–∞'), ('declaration', '–¥–µ–∫–ª–∞—Ä–∞—Ü–∏—è')
        ],
        'Countries': [
            ('country', '—Å—Ç—Ä–∞–Ω–∞'), ('capital', '—Å—Ç–æ–ª–∏—Ü–∞'), ('continent', '–∫–æ–Ω—Ç–∏–Ω–µ–Ω—Ç'),
            ('ocean', '–æ–∫–µ–∞–Ω'), ('border', '–≥—Ä–∞–Ω–∏—Ü–∞')
        ],
        'Capitals': [
            ('Moscow', '–ú–æ—Å–∫–≤–∞'), ('London', '–õ–æ–Ω–¥–æ–Ω'), ('Paris', '–ü–∞—Ä–∏–∂'),
            ('Berlin', '–ë–µ—Ä–ª–∏–Ω'), ('Tokyo', '–¢–æ–∫–∏–æ')
        ],
        'Landmarks': [
            ('Eiffel Tower', '–≠–π—Ñ–µ–ª–µ–≤–∞ –±–∞—à–Ω—è'), ('Great Wall', '–í–µ–ª–∏–∫–∞—è —Å—Ç–µ–Ω–∞'),
            ('Pyramids of Giza', '–ü–∏—Ä–∞–º–∏–¥—ã –ì–∏–∑—ã'), ('Colosseum', '–ö–æ–ª–∏–∑–µ–π'),
            ('Statue of Liberty', '–°—Ç–∞—Ç—É—è –°–≤–æ–±–æ–¥—ã')
        ],
        'Traditions': [
            ('tradition', '—Ç—Ä–∞–¥–∏—Ü–∏—è'), ('custom', '–æ–±—ã—á–∞–π'), ('ritual', '—Ä–∏—Ç—É–∞–ª'),
            ('ceremony', '—Ü–µ—Ä–µ–º–æ–Ω–∏—è'), ('folklore', '—Ñ–æ–ª—å–∫–ª–æ—Ä')
        ],
        'Customs': [
            ('greeting', '–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ'), ('farewell', '–ø—Ä–æ—â–∞–Ω–∏–µ'), ('dining etiquette', '—Å—Ç–æ–ª–æ–≤—ã–π —ç—Ç–∏–∫–µ—Ç'),
            ('social norms', '—Å–æ—Ü–∏–∞–ª—å–Ω—ã–µ –Ω–æ—Ä–º—ã'), ('taboo', '—Ç–∞–±—É')
        ],
        'Festivals': [
            ('festival', '—Ñ–µ—Å—Ç–∏–≤–∞–ª—å'), ('holiday', '–ø—Ä–∞–∑–¥–Ω–∏–∫'), ('celebration', '–ø—Ä–∞–∑–¥–Ω–æ–≤–∞–Ω–∏–µ'),
            ('parade', '–ø–∞—Ä–∞–¥'), ('carnival', '–∫–∞—Ä–Ω–∞–≤–∞–ª')
        ],
        'Genres': [
            ('novel', '—Ä–æ–º–∞–Ω'), ('poem', '—Å—Ç–∏—Ö–æ—Ç–≤–æ—Ä–µ–Ω–∏–µ'), ('play', '–ø—å–µ—Å–∞'),
            ('short story', '–∫–æ—Ä–æ—Ç–∫–∏–π —Ä–∞—Å—Å–∫–∞–∑'), ('essay', '—ç—Å—Å–µ')
        ],
        'Authors': [
            ('writer', '–ø–∏—Å–∞—Ç–µ–ª—å'), ('poet', '–ø–æ—ç—Ç'), ('dramatist', '–¥—Ä–∞–º–∞—Ç—É—Ä–≥'),
            ('novelist', '—Ä–æ–º–∞–Ω–∏—Å—Ç'), ('biographer', '–±–∏–æ–≥—Ä–∞—Ñ')
        ],
        'Literary Terms': [
            ('plot', '—Å—é–∂–µ—Ç'), ('character', '–ø–µ—Ä—Å–æ–Ω–∞–∂'), ('theme', '—Ç–µ–º–∞'),
            ('metaphor', '–º–µ—Ç–∞—Ñ–æ—Ä–∞'), ('symbolism', '—Å–∏–º–≤–æ–ª–∏–∑–º')
        ],
        'Art Forms': [
            ('painting', '–∂–∏–≤–æ–ø–∏—Å—å'), ('sculpture', '—Å–∫—É–ª—å–ø—Ç—É—Ä–∞'), ('drawing', '—Ä–∏—Å—É–Ω–æ–∫'),
            ('photography', '—Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—è'), ('architecture', '–∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞')
        ],
        'Artists': [
            ('painter', '—Ö—É–¥–æ–∂–Ω–∏–∫'), ('sculptor', '—Å–∫—É–ª—å–ø—Ç–æ—Ä'), ('photographer', '—Ñ–æ—Ç–æ–≥—Ä–∞—Ñ'),
            ('architect', '–∞—Ä—Ö–∏—Ç–µ–∫—Ç–æ—Ä'), ('musician', '–º—É–∑—ã–∫–∞–Ω—Ç')
        ],
        'Art History': [
            ('Renaissance', '–í–æ–∑—Ä–æ–∂–¥–µ–Ω–∏–µ'), ('Baroque', '–ë–∞—Ä–æ–∫–∫–æ'), ('Impressionism', '–ò–º–ø—Ä–µ—Å—Å–∏–æ–Ω–∏–∑–º'),
            ('Cubism', '–ö—É–±–∏–∑–º'), ('Surrealism', '–°—é—Ä—Ä–µ–∞–ª–∏–∑–º')
        ],
        'News': [
            ('headline', '–∑–∞–≥–æ–ª–æ–≤–æ–∫'), ('reporter', '—Ä–µ–ø–æ—Ä—Ç–µ—Ä'), ('article', '—Å—Ç–∞—Ç—å—è'),
            ('broadcast', '—Ç—Ä–∞–Ω—Å–ª—è—Ü–∏—è'), ('journalism', '–∂—É—Ä–Ω–∞–ª–∏—Å—Ç–∏–∫–∞')
        ],
        'Entertainment': [
            ('movie', '—Ñ–∏–ª—å–º'), ('music', '–º—É–∑—ã–∫–∞'), ('theater', '—Ç–µ–∞—Ç—Ä'),
            ('concert', '–∫–æ–Ω—Ü–µ—Ä—Ç'), ('game', '–∏–≥—Ä–∞')
        ],
        'Social Media': [
            ('post', '–ø–æ—Å—Ç'), ('like', '–ª–∞–π–∫'), ('share', '–ø–æ–¥–µ–ª–∏—Ç—å—Å—è'),
            ('follower', '–ø–æ–¥–ø–∏—Å—á–∏–∫'), ('hashtag', '—Ö–µ—à—Ç–µ–≥')
        ],
        'Companies': [
            ('company', '–∫–æ–º–ø–∞–Ω–∏—è'), ('corporation', '–∫–æ—Ä–ø–æ—Ä–∞—Ü–∏—è'), ('startup', '—Å—Ç–∞—Ä—Ç–∞–ø'),
            ('business', '–±–∏–∑–Ω–µ—Å'), ('enterprise', '–ø—Ä–µ–¥–ø—Ä–∏—è—Ç–∏–µ')
        ],
        'Marketing': [
            ('advertisement', '—Ä–µ–∫–ª–∞–º–∞'), ('brand', '–±—Ä–µ–Ω–¥'), ('customer', '–∫–ª–∏–µ–Ω—Ç'),
            ('sales', '–ø—Ä–æ–¥–∞–∂–∏'), ('promotion', '–ø—Ä–æ–¥–≤–∏–∂–µ–Ω–∏–µ')
        ],
        'Management': [
            ('manager', '–º–µ–Ω–µ–¥–∂–µ—Ä'), ('leadership', '–ª–∏–¥–µ—Ä—Å—Ç–≤–æ'), ('teamwork', '–∫–æ–º–∞–Ω–¥–Ω–∞—è —Ä–∞–±–æ—Ç–∞'),
            ('strategy', '—Å—Ç—Ä–∞—Ç–µ–≥–∏—è'), ('project', '–ø—Ä–æ–µ–∫—Ç')
        ],
        'Economics': [
            ('economy', '—ç–∫–æ–Ω–æ–º–∏–∫–∞'), ('supply and demand', '—Å–ø—Ä–æ—Å –∏ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ'),
            ('inflation', '–∏–Ω—Ñ–ª—è—Ü–∏—è'), ('recession', '—Ä–µ—Ü–µ—Å—Å–∏—è'), ('market', '—Ä—ã–Ω–æ–∫')
        ],
        'Finance': [
            ('money', '–¥–µ–Ω—å–≥–∏'), ('bank', '–±–∞–Ω–∫'), ('investment', '–∏–Ω–≤–µ—Å—Ç–∏—Ü–∏—è'),
            ('budget', '–±—é–¥–∂–µ—Ç'), ('stock market', '—Ñ–æ–Ω–¥–æ–≤—ã–π —Ä—ã–Ω–æ–∫')
        ],
        'Trade': [
            ('export', '—ç–∫—Å–ø–æ—Ä—Ç'), ('import', '–∏–º–ø–æ—Ä—Ç'), ('tariff', '—Ç–∞—Ä–∏—Ñ'),
            ('global trade', '–º–∏—Ä–æ–≤–∞—è —Ç–æ—Ä–≥–æ–≤–ª—è'), ('agreement', '—Å–æ–≥–ª–∞—à–µ–Ω–∏–µ')
        ],
        'Government': [
            ('government', '–ø—Ä–∞–≤–∏—Ç–µ–ª—å—Å—Ç–≤–æ'), ('president', '–ø—Ä–µ–∑–∏–¥–µ–Ω—Ç'), ('parliament', '–ø–∞—Ä–ª–∞–º–µ–Ω—Ç'),
            ('democracy', '–¥–µ–º–æ–∫—Ä–∞—Ç–∏—è'), ('constitution', '–∫–æ–Ω—Å—Ç–∏—Ç—É—Ü–∏—è')
        ],
        'Elections': [
            ('election', '–≤—ã–±–æ—Ä—ã'), ('vote', '–≥–æ–ª–æ—Å–æ–≤–∞—Ç—å'), ('candidate', '–∫–∞–Ω–¥–∏–¥–∞—Ç'),
            ('campaign', '–∫–∞–º–ø–∞–Ω–∏—è'), ('ballot', '–∏–∑–±–∏—Ä–∞—Ç–µ–ª—å–Ω—ã–π –±—é–ª–ª–µ—Ç–µ–Ω—å')
        ],
        'International Relations': [
            ('diplomacy', '–¥–∏–ø–ª–æ–º–∞—Ç–∏—è'), ('treaty', '–¥–æ–≥–æ–≤–æ—Ä'), ('alliance', '–∞–ª—å—è–Ω—Å'),
            ('conflict', '–∫–æ–Ω—Ñ–ª–∏–∫—Ç'), ('peace', '–º–∏—Ä')
        ],
        'Diseases': [
            ('disease', '–±–æ–ª–µ–∑–Ω—å'), ('symptom', '—Å–∏–º–ø—Ç–æ–º'), ('infection', '–∏–Ω—Ñ–µ–∫—Ü–∏—è'),
            ('virus', '–≤–∏—Ä—É—Å'), ('bacteria', '–±–∞–∫—Ç–µ—Ä–∏–∏')
        ],
        'Treatment': [
            ('medicine', '–ª–µ–∫–∞—Ä—Å—Ç–≤–æ'), ('therapy', '—Ç–µ—Ä–∞–ø–∏—è'), ('surgery', '—Ö–∏—Ä—É—Ä–≥–∏—è'),
            ('vaccine', '–≤–∞–∫—Ü–∏–Ω–∞'), ('diagnosis', '–¥–∏–∞–≥–Ω–æ–∑')
        ],
        'Healthcare': [
            ('hospital', '–±–æ–ª—å–Ω–∏—Ü–∞'), ('doctor', '–≤—Ä–∞—á'), ('nurse', '–º–µ–¥—Å–µ—Å—Ç—Ä–∞'),
            ('patient', '–ø–∞—Ü–∏–µ–Ω—Ç'), ('clinic', '–∫–ª–∏–Ω–∏–∫–∞')
        ],
        'Legal System': [
            ('law', '–∑–∞–∫–æ–Ω'), ('court', '—Å—É–¥'), ('judge', '—Å—É–¥—å—è'),
            ('lawyer', '–∞–¥–≤–æ–∫–∞—Ç'), ('justice', '—Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ—Å—Ç—å')
        ],
        'Rights': [
            ('right', '–ø—Ä–∞–≤–æ'), ('freedom', '—Å–≤–æ–±–æ–¥–∞'), ('equality', '—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ'),
            ('human rights', '–ø—Ä–∞–≤–∞ —á–µ–ª–æ–≤–µ–∫–∞'), ('citizen', '–≥—Ä–∞–∂–¥–∞–Ω–∏–Ω')
        ],
        'Crimes': [
            ('crime', '–ø—Ä–µ—Å—Ç—É–ø–ª–µ–Ω–∏–µ'), ('theft', '–∫—Ä–∞–∂–∞'), ('murder', '—É–±–∏–π—Å—Ç–≤–æ'),
            ('fraud', '–º–æ—à–µ–Ω–Ω–∏—á–µ—Å—Ç–≤–æ'), ('arrest', '–∞—Ä–µ—Å—Ç')
        ],
        'Education System': [
            ('school', '—à–∫–æ–ª–∞'), ('university', '—É–Ω–∏–≤–µ—Ä—Å–∏—Ç–µ—Ç'), ('curriculum', '—É—á–µ–±–Ω—ã–π –ø–ª–∞–Ω'),
            ('grade', '–æ—Ü–µ–Ω–∫–∞'), ('diploma', '–¥–∏–ø–ª–æ–º')
        ],
        'Learning': [
            ('learn', '—É—á–∏—Ç—å—Å—è'), ('knowledge', '–∑–Ω–∞–Ω–∏–µ'), ('skill', '–Ω–∞–≤—ã–∫'),
            ('practice', '–ø—Ä–∞–∫—Ç–∏–∫–∞'), ('understand', '–ø–æ–Ω–∏–º–∞—Ç—å')
        ],
        'Teaching': [
            ('teach', '—É—á–∏—Ç—å'), ('teacher', '—É—á–∏—Ç–µ–ª—å'), ('lesson', '—É—Ä–æ–∫'),
            ('classroom', '–∫–ª–∞—Å—Å–Ω–∞—è –∫–æ–º–Ω–∞—Ç–∞'), ('pedagogy', '–ø–µ–¥–∞–≥–æ–≥–∏–∫–∞')
        ],
        'Philosophical Concepts': [
            ('existence', '—Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ'), ('truth', '–∏—Å—Ç–∏–Ω–∞'), ('reality', '—Ä–µ–∞–ª—å–Ω–æ—Å—Ç—å'),
            ('knowledge', '–∑–Ω–∞–Ω–∏–µ'), ('morality', '–º–æ—Ä–∞–ª—å')
        ],
        'Philosophers': [
            ('Plato', '–ü–ª–∞—Ç–æ–Ω'), ('Aristotle', '–ê—Ä–∏—Å—Ç–æ—Ç–µ–ª—å'), ('Kant', '–ö–∞–Ω—Ç'),
            ('Nietzsche', '–ù–∏—Ü—à–µ'), ('Socrates', '–°–æ–∫—Ä–∞—Ç')
        ],
        'Ethics': [
            ('ethics', '—ç—Ç–∏–∫–∞'), ('virtue', '–¥–æ–±—Ä–æ–¥–µ—Ç–µ–ª—å'), ('justice', '—Å–ø—Ä–∞–≤–µ–¥–ª–∏–≤–æ—Å—Ç—å'),
            ('duty', '–¥–æ–ª–≥'), ('conscience', '—Å–æ–≤–µ—Å—Ç—å')
        ],
        'Mental Processes': [
            ('thought', '–º—ã—Å–ª—å'), ('memory', '–ø–∞–º—è—Ç—å'), ('perception', '–≤–æ—Å–ø—Ä–∏—è—Ç–∏–µ'),
            ('emotion', '—ç–º–æ—Ü–∏—è'), ('cognition', '–ø–æ–∑–Ω–∞–Ω–∏–µ')
        ],
        'Behavior': [
            ('behavior', '–ø–æ–≤–µ–¥–µ–Ω–∏–µ'), ('habit', '–ø—Ä–∏–≤—ã—á–∫–∞'), ('reaction', '—Ä–µ–∞–∫—Ü–∏—è'),
            ('instinct', '–∏–Ω—Å—Ç–∏–Ω–∫—Ç'), ('adaptation', '–∞–¥–∞–ø—Ç–∞—Ü–∏—è')
        ],
        'Personality': [
            ('personality', '–ª–∏—á–Ω–æ—Å—Ç—å'), ('trait', '—á–µ—Ä—Ç–∞ —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∞'), ('temperament', '—Ç–µ–º–ø–µ—Ä–∞–º–µ–Ω—Ç'),
            ('character', '—Ö–∞—Ä–∞–∫—Ç–µ—Ä'), ('self-esteem', '—Å–∞–º–æ–æ—Ü–µ–Ω–∫–∞')
        ],
        'Society': [
            ('society', '–æ–±—â–µ—Å—Ç–≤–æ'), ('culture', '–∫—É–ª—å—Ç—É—Ä–∞'), ('community', '—Å–æ–æ–±—â–µ—Å—Ç–≤–æ'),
            ('institution', '–∏–Ω—Å—Ç–∏—Ç—É—Ç'), ('social norm', '—Å–æ—Ü–∏–∞–ª—å–Ω–∞—è –Ω–æ—Ä–º–∞')
        ],
        'Social Groups': [
            ('family', '—Å–µ–º—å—è'), ('peer group', '–≥—Ä—É–ø–ø–∞ —Å–≤–µ—Ä—Å—Ç–Ω–∏–∫–æ–≤'), ('organization', '–æ—Ä–≥–∞–Ω–∏–∑–∞—Ü–∏—è'),
            ('class', '–∫–ª–∞—Å—Å (—Å–æ—Ü–∏–∞–ª—å–Ω—ã–π)'), ('nation', '–Ω–∞—Ü–∏—è')
        ],
        'Social Issues': [
            ('poverty', '–±–µ–¥–Ω–æ—Å—Ç—å'), ('inequality', '–Ω–µ—Ä–∞–≤–µ–Ω—Å—Ç–≤–æ'), ('crime', '–ø—Ä–µ—Å—Ç—É–ø–Ω–æ—Å—Ç—å'),
            ('discrimination', '–¥–∏—Å–∫—Ä–∏–º–∏–Ω–∞—Ü–∏—è'), ('unemployment', '–±–µ–∑—Ä–∞–±–æ—Ç–∏—Ü–∞')
        ]
    }

    with app.app_context():
        # –û—á–∏—Å—Ç–∫–∞ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –¥–∞–Ω–Ω—ã—Ö
        TestWord.query.delete()
        Test.query.delete()
        Word.query.delete()
        User.query.delete()
        db.session.commit() # –ö–æ–º–º–∏—Ç –¥–ª—è –æ—á–∏—Å—Ç–∫–∏

        # –°–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —É—á–∏—Ç–µ–ª—è
        hashed_teacher_password = generate_password_hash('teacher')
        teacher = User(
            fio='–¢–µ—Å—Ç–æ–≤—ã–π –£—á–∏—Ç–µ–ª—å',
            nick='teacher',
            password=hashed_teacher_password,
            teacher='yes'
        )
        db.session.add(teacher)
        db.session.commit()

        # –°–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ —Å—Ç—É–¥–µ–Ω—Ç–∞
        hashed_student_password = generate_password_hash('student')
        student = User(
            fio='–¢–µ—Å—Ç–æ–≤—ã–π –°—Ç—É–¥–µ–Ω—Ç',
            nick='student',
            password=hashed_student_password,
            teacher='no',
            class_number='1'
        )
        db.session.add(student)
        
        # –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –¥–∞–Ω–Ω—ã–º–∏: –Ω–∏–∫ "a", –ø–∞—Ä–æ–ª—å "a", –∫–ª–∞—Å—Å "10", –§–ò–û "a a a"
        hashed_a_password = generate_password_hash('a')
        user_a = User(
            fio='a a a',
            nick='a',
            password=hashed_a_password,
            teacher='no',
            class_number='10'
        )
        db.session.add(user_a)
        db.session.commit()

        # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ª–æ–≤ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
        for class_num in classes:
            for unit in units[class_num]:
                for module in modules[unit]:
                    # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–ª–æ–≤–∞ –∏–∑ —Å–ª–æ–≤–∞—Ä—è test_words
                    if module in test_words:
                        words_to_add = test_words[module]
                    else:
                        # –ï—Å–ª–∏ –º–æ–¥—É–ª—è –Ω–µ—Ç –≤ —Å–ª–æ–≤–∞—Ä–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º –±–∞–∑–æ–≤—ã–µ —Å–ª–æ–≤–∞ –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –æ—à–∏–±–æ–∫
                        print(f"Warning: Module '{module}' not found in test_words. Using 'Basic Greetings' words.")
                        words_to_add = test_words['Basic Greetings'] # Fallback
                    
                    for word_en, word_ru in words_to_add:
                        new_word = Word(
                            word=word_en,
                            perevod=word_ru,
                            classs=class_num,
                            unit=unit,
                            module=module
                        )
                        db.session.add(new_word)
        db.session.commit() # –ö–æ–º–º–∏—Ç –ø–æ—Å–ª–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤—Å–µ—Ö —Å–ª–æ–≤

        # –°–æ–∑–¥–∞–Ω–∏–µ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö —Ç–µ—Å—Ç–æ–≤ –¥–ª—è 10 –∫–ª–∞—Å—Å–∞
        test_class = '10'
        
        # –¢–∏–ø—ã —Ç–µ—Å—Ç–æ–≤ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è
        test_types = [
            {'type': 'dictation', 'title_prefix': '–î–∏–∫—Ç–∞–Ω—Ç'},
            {'type': 'add_letter', 'title_prefix': '–î–æ–±–∞–≤–∏—Ç—å –±—É–∫–≤—É'},
            {'type': 'true_false', 'title_prefix': '–ü—Ä–∞–≤–¥–∞/–õ–æ–∂—å'},
            {'type': 'multiple_choice_single', 'title_prefix': '–í—ã–±–æ—Ä –æ—Ç–≤–µ—Ç–∞'},
            {'type': 'fill_word', 'title_prefix': '–ó–∞–ø–æ–ª–Ω–∏—Ç—å —Å–ª–æ–≤–æ'}
        ]
        
        # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç—ã –¥–ª—è –≤—Å–µ—Ö –º–æ–¥—É–ª–µ–π 10 –∫–ª–∞—Å—Å–∞
        for unit in units[test_class]:
            for module in modules[unit]:
                # –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç—ã —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –º–æ–¥—É–ª—è
                for test_type_info in test_types:
                    test_link = generate_test_link()
                    
                    test = Test(
                        title=f'{test_type_info["title_prefix"]}: {module} ({unit})',
                        classs=test_class,
                        unit=unit,
                        module=module,
                        type=test_type_info['type'],
                        link=test_link,
                        created_by=teacher.id,
                        is_active=True,
                        word_order='random'
                    )
                    db.session.add(test)
                    db.session.commit()

                    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Å–ª–æ–≤ –≤ —Ç–µ—Å—Ç –∏–∑ –≤—ã–±—Ä–∞–Ω–Ω–æ–≥–æ –º–æ–¥—É–ª—è
                    words_for_test = Word.query.filter_by(
                        classs=test_class,
                        unit=unit,
                        module=module
                    ).all()

                    if not words_for_test:
                        print(f"Warning: No words found for test module '{module}'. Test will be empty.")
                        continue

                    for idx, word_obj in enumerate(words_for_test):
                        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –¥–∞–Ω–Ω—ã—Ö –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —Ç–µ—Å—Ç–∞
                        test_word_data = {
                            'test_id': test.id,
                            'word': word_obj.word,
                            'perevod': word_obj.perevod,
                            'correct_answer': word_obj.word,
                            'word_order': idx
                        }
                        
                        # –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ —Ç–µ—Å—Ç–æ–≤
                        if test_type_info['type'] == 'add_letter':
                            # –î–ª—è —Ç–µ—Å—Ç–∞ "–¥–æ–±–∞–≤–∏—Ç—å –±—É–∫–≤—É" —Å–æ–∑–¥–∞–µ–º —Å–ª–æ–≤–æ —Å –ø—Ä–æ–ø—É—â–µ–Ω–Ω—ã–º–∏ –±—É–∫–≤–∞–º–∏
                            word_with_gaps = create_word_with_missing_letters(word_obj.word)
                            test_word_data['missing_letters'] = word_with_gaps
                            test_word_data['word'] = word_with_gaps
                        elif test_type_info['type'] == 'multiple_choice_single':
                            # –î–ª—è –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –≤—ã–±–æ—Ä–∞ —Å–æ–∑–¥–∞–µ–º –≤–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤
                            options = create_multiple_choice_options(word_obj.word, words_for_test)
                            test_word_data['options'] = options
                        elif test_type_info['type'] == 'true_false':
                            # –î–ª—è –ø—Ä–∞–≤–¥–∞/–ª–æ–∂—å –∏–Ω–æ–≥–¥–∞ –¥–µ–ª–∞–µ–º –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥
                            if random.choice([True, False]):
                                # –°–æ–∑–¥–∞–µ–º –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π –ø–µ—Ä–µ–≤–æ–¥
                                wrong_translation = create_wrong_translation(word_obj.perevod, words_for_test)
                                test_word_data['perevod'] = wrong_translation
                                test_word_data['correct_answer'] = 'False'
                            else:
                                test_word_data['correct_answer'] = 'True'
                        
                        test_word = TestWord(**test_word_data)
                        db.session.add(test_word)
                    
                    print(f"Created test: {test.title} with {len(words_for_test)} words")
        
        db.session.commit() # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –≤—Å–µ—Ö –∏–∑–º–µ–Ω–µ–Ω–∏–π
        print("Test data has been successfully loaded into the database!")

if __name__ == "__main__":
    with app.app_context():
        generate_test_data()


test_time_formatting.py (/home/amir/Documents/Info/Duckly/test_time_formatting.py):
#!/usr/bin/env python3
"""
–¢–µ—Å—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤.
"""

def format_time_taken(minutes):
    """
    –ë–µ–∑–æ–ø–∞—Å–Ω–æ —Ñ–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –≤—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Ç–µ—Å—Ç–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è.
    
    Args:
        minutes: –í—Ä–µ–º—è –≤ –º–∏–Ω—É—Ç–∞—Ö (–º–æ–∂–µ—Ç –±—ã—Ç—å None, 0 –∏–ª–∏ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–º)
    
    Returns:
        str: –û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –≤—Ä–µ–º–µ–Ω–∏
    """
    if minutes is None or minutes < 0:
        return "0 –º–∏–Ω"
    
    if minutes == 0:
        return "<1 –º–∏–Ω"
    
    hours = minutes // 60
    remaining_minutes = minutes % 60
    
    if hours == 0:
        return f"{remaining_minutes} –º–∏–Ω"
    elif remaining_minutes == 0:
        return f"{hours} —á"
    else:
        return f"{hours} —á {remaining_minutes} –º–∏–Ω"

def test_time_formatting():
    """–¢–µ—Å—Ç–∏—Ä—É–µ—Ç —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Å–ª—É—á–∞–∏ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤—Ä–µ–º–µ–Ω–∏."""
    test_cases = [
        (None, "0 –º–∏–Ω"),
        (-5, "0 –º–∏–Ω"),
        (0, "<1 –º–∏–Ω"),
        (1, "1 –º–∏–Ω"),
        (5, "5 –º–∏–Ω"),
        (59, "59 –º–∏–Ω"),
        (60, "1 —á"),
        (61, "1 —á 1 –º–∏–Ω"),
        (65, "1 —á 5 –º–∏–Ω"),
        (120, "2 —á"),
        (125, "2 —á 5 –º–∏–Ω"),
        (180, "3 —á"),
        (185, "3 —á 5 –º–∏–Ω")
    ]
    
    print("–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ñ—É–Ω–∫—Ü–∏–∏ format_time_taken:")
    print("=" * 50)
    
    all_passed = True
    for input_minutes, expected in test_cases:
        result = format_time_taken(input_minutes)
        status = "‚úì" if result == expected else "‚úó"
        if result != expected:
            all_passed = False
        print(f"{status} {input_minutes} –º–∏–Ω -> '{result}' (–æ–∂–∏–¥–∞–ª–æ—Å—å: '{expected}')")
    
    print("=" * 50)
    if all_passed:
        print("‚úì –í—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—à–ª–∏ —É—Å–ø–µ—à–Ω–æ!")
    else:
        print("‚úó –ù–µ–∫–æ—Ç–æ—Ä—ã–µ —Ç–µ—Å—Ç—ã –Ω–µ –ø—Ä–æ—à–ª–∏!")
    
    return all_passed

if __name__ == "__main__":
    test_time_formatting()

